<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Emilia&#39;s Blog</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-30T14:36:51.551Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Emilia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TSP, How to?</title>
    <link href="http://yoursite.com/2023/01/14/TSP/"/>
    <id>http://yoursite.com/2023/01/14/TSP/</id>
    <published>2023-01-14T11:49:32.000Z</published>
    <updated>2023-01-30T14:36:51.551Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>曾經在morris的<a href="https://morris821028.github.io/2017/01/18/jg-20007/">淺談旅行推銷員問題 (Travelling Salesman Problem) 搜索加速</a>看過他寫道:「看看維基百科上，就有那上萬點的極佳近似解算法」，就讓我好奇那些近似演算法就是是怎麼做到的。<br>故有了這次的side project。</p><h1 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h1><p>給定n個城市的二維座標，請找出可以遍歷所有城市，並回到起點(起點任意)的最短路徑長度。</p><h1 id="經典解法"><a href="#經典解法" class="headerlink" title="經典解法"></a>經典解法</h1><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>很正常簡單的方法，把每個可能的排列都試過一遍。</p><h2 id="貪心"><a href="#貪心" class="headerlink" title="貪心"></a>貪心</h2><p>先選定起點，對於目前的城市選擇一個最近的未走過城市，直到回到起點。這個方法不能保證解的正確性，但用來估解答的上界挺有用的，branch &amp; bound跟ACS都有用到。</p><h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>這個是老方法了，一般會宣告一個二維陣列$\text{DP}[S][x]$，$S$為已走過的城市集合，而$x$為已走過的集合的最後一個城市。由此可以很方便的記憶化搜尋:<br>$\text{DP}[S\cup y][y]=min\{\text{DP}[S\sup y][y],\text{DP}[S][x]+\text{dis}[x][y]\}$<br>實作上為了方便、空間以及速度，我用一個64位元的整數來表達這個集合。(第i個bit是1代表有走過)</p><h1 id="啟發式演算法"><a href="#啟發式演算法" class="headerlink" title="啟發式演算法"></a>啟發式演算法</h1><p>啟發式演算法對於NP問題可以得到不錯的近似解，我這裡試了Simulated Annealing、Ant Colony Optimization、Ant Colony System，而測試資料有三個，分別是berlin52、eil51、eil101。</p><h2 id="Simulated-Annealing"><a href="#Simulated-Annealing" class="headerlink" title="Simulated Annealing"></a>Simulated Annealing</h2><p>假設目前有一解(未必是最佳解)，在此解的鄰域中隨機找另一解，然後通過<code>E()</code>計算兩個解的”能量”，如果後者的能量小於前者，就更新全域最佳解並將目前解設為後者，若前者較大，則目前的解有一定概率轉移至後者。<br>虛擬碼如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// temperture cooling down</span></span><br><span class="line"><span class="keyword">while</span>(T &gt; EndT)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MaxIter; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// find a candidate solution by current solution</span></span><br><span class="line">nexSol = <span class="built_in">neighbour</span>(nowSol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate energy</span></span><br><span class="line">dt = <span class="built_in">E</span>(nexSol) - <span class="built_in">E</span>(nowSol);</span><br><span class="line"></span><br><span class="line"><span class="comment">// transition</span></span><br><span class="line"><span class="keyword">if</span> (dt &lt; <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">uniform_rand_in</span>(<span class="number">0</span>, <span class="number">1</span>) &lt; <span class="built_in">exp</span>(-dt / (k*T)) )</span><br><span class="line">&#123;</span><br><span class="line">nowSol = nexSol;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>這是退火模擬的主架構。其中<code>neighbour()</code>有許多方法實作，這裡使用的是交換兩點的進入順序，例如:a-&gt;b-&gt;c-&gt;d-&gt;e，交換a,d變成d-&gt;b-&gt;c-&gt;a-&gt;e。<br>而能量計算可以很簡單的定義為解的長度就好。<br>虛擬碼如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">neighbour</span>(Sol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(Sol[<span class="built_in">random</span>(<span class="number">0</span>, Sol.size<span class="number">-1</span>)], Sol[<span class="built_in">random</span>(<span class="number">0</span>, Sol.size<span class="number">-1</span>)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">E</span>(Sol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Sol.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>SA的收斂過程:</p><p>berlin52:<br><img src="https://i.imgur.com/NouMqWv.gif" alt=""></p><p>eil101:<br><img src="http://i.imgur.com/aW8Zpz6h.gif" alt=""><br><em>*這個gif顯示貌似壞掉了，可以到這個<a href="https://imgur.com/a/POpFdTC">連結</a>看</em></p><p>eil51:<br><img src="https://i.imgur.com/ydJArOJ.gif" alt=""></p><h2 id="Simulated-Annealing-with-2-opt"><a href="#Simulated-Annealing-with-2-opt" class="headerlink" title="Simulated Annealing with 2-opt"></a>Simulated Annealing with 2-opt</h2><p>這個方法只有一個地方要改，在解的鄰域中隨機找一解的過程不再是隨機交換兩點，而是改成將隨機兩點中的路徑顛倒，例如:a-&gt;b-&gt;c-&gt;d-&gt;e，交換b到d的路徑變成a-&gt;d-&gt;c-&gt;b-&gt;e。<br>這樣可以很大程度的把交叉路徑解開，故可以提升解的正確性許多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">neighbour</span>(Sol)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(Sol, <span class="built_in">random</span>(<span class="number">0</span>, Sol.size<span class="number">-1</span>), <span class="built_in">random</span>(<span class="number">0</span>, Sol.size<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SA-2opt的收斂過程:</p><p>berlin52:<br><img src="https://i.imgur.com/fujzR6D.gif" alt=""></p><p>eil101:<br><img src="http://i.imgur.com/3hrOiYEh.gif" alt=""><br><em>*這個gif顯示貌似壞掉了，可以到這個<a href="https://imgur.com/3hrOiYE">連結</a>看</em></p><p>eil51:<br><img src="https://i.imgur.com/5PGbKwO.gif" alt=""></p><h2 id="Ant-System"><a href="#Ant-System" class="headerlink" title="Ant System"></a>Ant System</h2><p>類似蟻群尋找的行為，尋找解的路徑上會累積費洛蒙，且走的越長留下的費洛蒙越少，以此就可以找到好的解答。另外費洛蒙有蒸發機制。<br>主架構的虛擬碼如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set_parameters</span>();</span><br><span class="line"><span class="built_in">Initialize_pheromone_trails</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">not</span> termination)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// every ants construct their solutions</span></span><br><span class="line"><span class="built_in">ConstructAntSolutions</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the best solution</span></span><br><span class="line"><span class="built_in">ApplyLocalSearch</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// update pheromones</span></span><br><span class="line"><span class="built_in">UpdatePheromones</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>裡面三個函式的虛擬碼:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ConstructAntSolutions</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line"><span class="keyword">while</span> (ant.solution.size &lt; n)</span><br><span class="line">ant.<span class="built_in">choose_next</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ApplyLocalSearch</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line"><span class="keyword">if</span> (best_solution &gt; ant.solution)</span><br><span class="line">best_solution = ant.solution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UpdatePheromones</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ant.solution.size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A = city[ant.solution[i]], B = city[ant.solution[(i+<span class="number">1</span>) % ant.solution.size]];</span><br><span class="line"></span><br><span class="line">Pheromones[A][B] = Pheromones[A][B] * (<span class="number">1</span> - rho) + rho * (Q / ant.solution.length);</span><br><span class="line"><span class="comment">// the reverse must update too</span></span><br><span class="line">Pheromones[B][A] = Pheromones[B][A] * (<span class="number">1</span> - rho) + rho * (Q / ant.solution.length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>ConstructAntSolutions()</code>中，<code>choose_next()</code>的實作是依據下列機率選擇。<br>假設目前螞蟻在城市$i$，走到為走過的城市$j$的機率為$p_{ij}=\frac{\tau_{ij}^\alpha\eta_{ij}^\beta}{\sum_{\text{city k hasn’t been visited}} \tau_{ik}^\alpha\eta_{ik}^\beta}$<br>$\tau_{ij}$是城市$i$到城市$j$的費洛蒙濃度，$\eta_{ij}$是城市$i$到城市$j$的路徑長的倒數($\frac1{d_{ij}}$)，$\alpha,\beta$是定義好的參數，$\alpha$越大螞蟻就越傾向往費洛蒙濃的城市走，$\beta$越大螞蟻就越傾向走最近的城市。<br>實作上可以不用管分母，避免浮點數誤差。</p><p>而<code>UpdatePheromones()</code>中的<code>Q</code>是一個常數，也可以設定為任意數值，越大收斂越快但逃出區域最佳解的能力越差，反之。</p><p>另外初始的費洛蒙濃度我設定為0.001，實際上可以設定為任意數值，只要能保證<code>choose_next</code>能正常運作就好。</p><p>AS收斂的過程:</p><p>berlin52:<br><img src="https://i.imgur.com/bWIjkcn.gif" alt=""></p><p>eil101:<br><img src="https://i.imgur.com/xUsAPwK.gif" alt=""></p><p>eil51:<br><img src="https://i.imgur.com/FJA4hvy.gif" alt=""></p><h2 id="Ant-System-with-2opt"><a href="#Ant-System-with-2opt" class="headerlink" title="Ant System with 2opt"></a>Ant System with 2opt</h2><p>每隻螞蟻建構出一個解後，隨機取兩個點，顛倒兩點的路徑，重複這個過程$n$次(可以調整為其他數值)，取最好的解。<br>這個方法同樣會讓解開交叉路徑的機率增加，以此提升解的正確性。<br>基本上就是在<code>ConstructAntSolutions()</code>裡增加一小段程式碼而已:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ConstructAntSolutions</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (ant.solution.size &lt; n)</span><br><span class="line">ant.<span class="built_in">choose_next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 2-opt ***/</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="number">2</span>opt(ant.solution);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AS-2opt收斂的過程:</p><p>berlin52:<br><img src="https://i.imgur.com/w5BQjlj.gif" alt=""></p><p>eil101:<br><img src="https://i.imgur.com/QYHuJg1.gif" alt=""></p><p>eil51:<br><img src="https://i.imgur.com/Fw2I3Nl.gif" alt=""></p><h2 id="Ant-Colony-System"><a href="#Ant-Colony-System" class="headerlink" title="Ant Colony System"></a>Ant Colony System</h2><p>跟Ant System不太一樣，首先螞蟻選擇城市的模式改成如下(假設目前螞蟻位於城市$i$):</p><ul><li>先隨機選擇一個均勻分布於$[0,1]$的隨機變數$q_0$<ul><li>如果$q \leq q_0$，則下一個選擇的城市為$\arg\max_{\text{city j hasn’t been visited}}\{\tau_{ij}\cdot\eta_{ij}^\beta\}$</li><li>如果$q&lt;q_0$，則使用剛剛Ant Colony Optimization的方法選擇。</li></ul></li></ul><p>第二個不同是費洛蒙的更新規則，變成global update跟local update。<br>global update會把最好的解更新上去: $\forall (i,j)\in \text{best solution}\tau_{ij} = (1-\alpha)\tau_{ij} + \alpha L^{-1}$，其中$L$是最好的解的路徑長度。<br>而local update則是螞蟻在建構解的途中就會更新費洛蒙: $\tau_{ij} = (1-\rho)\tau_{ij}+\rho\Delta\tau_{ij}$，其中$\Delta\tau_{ij}$的選擇方式有很多方法，Q-learning algorithm($\Delta\tau_{ij}=\gamma\max_{\text{city k hasn’t been visited}}\{\tau_{j, k}\}$)、$\tau_0$(初始費洛蒙值)、甚至直接設為$0$也可以。<br>根據Dorigo在1997寫的論文[3]，直接設為$\tau_0$的效果最好。($\tau_0$被設定為$(n\cdot L_{nn})^{-1}$，其中$L_{nn}$是最近鄰居啟發式搜尋找到的長度，跟上面提到的greedy方法一樣)</p><p>虛擬碼如下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set_parameters</span>();</span><br><span class="line"><span class="built_in">Initialize_pheromone_trails</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">not</span> termination)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// every ants construct their solutions</span></span><br><span class="line"><span class="built_in">ConstructAntSolutions</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the best solution</span></span><br><span class="line"><span class="built_in">ApplyLocalSearch</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// global update pheromones</span></span><br><span class="line"><span class="built_in">GlobalUpdatePheromones</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ConstructAntSolutions</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line"><span class="keyword">while</span> (ant.solution.size &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">ant.<span class="built_in">choose_next</span>();</span><br><span class="line"><span class="built_in">LocalUpdatePheromones</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ApplyLocalSearch</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ant : ants)</span><br><span class="line"><span class="keyword">if</span> (best_solution &gt; ant.solution)</span><br><span class="line">best_solution = ant.solution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">GlobalUpdatePheromones</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; best_ant.solution.size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A = city[best_ant.solution[i]], B = city[best_ant.solution[(i+<span class="number">1</span>) % best_ant.solution.size]];</span><br><span class="line"></span><br><span class="line">Pheromones[A][B] = Pheromones[A][B] * (<span class="number">1</span> - alpha) + alpha * tau0;</span><br><span class="line"><span class="comment">// the reverse must update too</span></span><br><span class="line">Pheromones[B][A] = Pheromones[B][A] * (<span class="number">1</span> - alpha) + alpha * tau0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ACS收斂的過程:</p><p>berlin52:<br><img src="https://i.imgur.com/3NsmcLh.gif" alt=""></p><p>eil101:<br><img src="https://i.imgur.com/CCU9XJ0.gif" alt=""></p><p>eil51:<br><img src="https://i.imgur.com/UNhUT10.gif" alt=""></p><h1 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h1><p>所有的程式碼都放在 <a href="https://github.com/OEmiliatanO/TSP_sol">https://github.com/OEmiliatanO/TSP_sol</a></p><h1 id="比較"><a href="#比較" class="headerlink" title="比較"></a>比較</h1><p>我用berlin52, eil51, eil101做對SA,SA-2opt,AS,AS-2opt,ACS做測試，每個做十遍，找到的路徑結果如下:</p><p><img src="https://i.imgur.com/vlgdAfG.png" alt=""></p><p>可以看見ACS表現最好，SA-2opt次好，接著是AS跟AS-2opt，SA則表現最差。<br>根據Dorigo在1997寫的論文，ACS的表現會比AS還要好的主因是local update，local update讓已經探索過的路徑上的費洛蒙濃度降低，阻止螞蟻們都收斂到區域最佳解上，以此探索更多的路徑。<br>另外兩點交換的SA表現雖然不好，但是SA-2opt的表現很好，且收斂速度也不錯。</p><p>(注意這裡的參數不一定都是最好的)</p><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>這次的side project很有趣，可以看到各個不同方法對解決TSP的效果如何，不過啟發式的程式碼很不好debug，因為有錯的話只能看表現有沒有到預期，而且就算知道有錯，也要整個程式碼+論文全部重新看過一遍。<br>不過寫爛了其實可以套2opt的強制增加表現，雖然時間會上升一點。只能說2opt真的是一個很簡單卻又很有效果的方法。<br>未來可能可以寫寫看Branch &amp; Bound跟GA。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] Kirkpatrick, S., Gelatt, C. D. and Vecchi, M. P., “Optimization by Simulated Annealing”, doi: 10.1126/science.220.4598.671.<br>[2] M. Dorigo, M. Birattari and T. Stutzle, “Ant colony optimization,” in IEEE Computational Intelligence Magazine, vol. 1, no. 4, pp. 28-39, Nov. 2006, doi: 10.1109/MCI.2006.329691.<br>[3] M. Dorigo and L. M. Gambardella, “Ant colony system: a cooperative learning approach to the traveling salesman problem,” in IEEE Transactions on Evolutionary Computation, vol. 1, no. 1, pp. 53-66, April 1997, doi: 10.1109/4235.585892.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;曾經在morris的&lt;a href=&quot;https://morris821028.github.io/2017/01/18/jg-20007/</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>熱傳導與傅立葉</title>
    <link href="http://yoursite.com/2022/05/06/%E7%86%B1%E5%82%B3%E5%B0%8E%E8%88%87%E5%82%85%E7%AB%8B%E8%91%89/"/>
    <id>http://yoursite.com/2022/05/06/%E7%86%B1%E5%82%B3%E5%B0%8E%E8%88%87%E5%82%85%E7%AB%8B%E8%91%89/</id>
    <published>2022-05-06T05:18:02.000Z</published>
    <updated>2023-05-17T05:46:11.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微積分(其實是教basic fourier analysis)期末專題。<br>我研究的主題是<a href="https://en.wikipedia.org/wiki/Heat_equation">熱傳導方程式</a> ，並使用python模擬熱傳導的模型。</p><hr><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>傅立葉冷卻定律描述熱在介質中傳播的規律，可以用兩種形式表達:</p><ol><li><p>微分形式，關注局部的熱傳導率</p><script type="math/tex; mode=display">\frac{\partial u}{\partial t}=\alpha \nabla^2 u</script></li><li><p>積分形式，關注流出/入部分介質表面的熱</p><script type="math/tex; mode=display">P=-k\oint_S\vec{\nabla}T\cdot\vec{dA}</script></li></ol><p>我使用的熱傳導方程就是<a href="https://en.wikipedia.org/wiki/Thermal_conduction#Fourier&#39;s_law">傅立葉冷卻定律</a> 的微分形式，來描述區域內溫度的演化。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="有限一維模型-數學推導"><a href="#有限一維模型-數學推導" class="headerlink" title="有限一維模型-數學推導"></a>有限一維模型-數學推導</h2><p><img src="https://imgur.com/1fse45u.png" alt=""></p><p>考慮一個理想的長棍，若$t=0$時，長棍上各點的溫度可用$f(x)$表達。<br>若可用一函數$u(x,t)$表達長棍一點的溫度於特定時間，求$u(x,t)$。</p><p>可知熱傳導方程式為: $\frac{\partial u}{\partial t}=\alpha \nabla^2 u$<br>因此處模型只有一維，故式中laplacian可改為: $\frac{\partial u}{\partial t}=\alpha \frac{\partial^2 u}{\partial x^2}$<br>在物理意義上為溫度隨時間改變的速度正比於相鄰溫差之差。</p><p>使用Neumann boundary condition: $\frac{\partial u}{\partial x}(0,t)=\frac{\partial u}{\partial x}(l,t)=0$<br>當然也可以使用Dirichlet boundary condition: $u(0,t)=u(l,t)=0$，但這裡只展示Neumann條件下的推導而已。</p><p>用分離變數法，假設$u(x,t)=X(x)T(t)$。<br>從$\frac{\partial u}{\partial t}=\alpha \nabla^2u$可知，$X(x)T’(t)=\alpha X’’(x)T(t)$。<br>令$\lambda=\alpha T(t)/T’(t)= X(x)/X’’(x)$。</p><p>先解出$X(x)$的部分，$\lambda X’’(x)-X(x)=0$。<br>利用特稱方程解此ODE，$\lambda m^2-1=0\iff m=\pm\sqrt\frac1\lambda$，所以$X(x)$的通解為$X(x)=c_1e^{\frac x{\sqrt\lambda}}+c_2e^{-\frac x{\sqrt\lambda}}$</p><p>檢查邊界條件。<br>$X’(x)=\frac{c_1}{\sqrt\lambda}e^{\frac x{\sqrt\lambda}}-\frac{c_2}{\sqrt\lambda}e^{-\frac x{\sqrt\lambda}}$.<br>$X’(0)=\frac{c_1}{\sqrt\lambda}-\frac{c_2}{\sqrt\lambda}=0\Rightarrow c_1=c_2$<br>$X’(l)=\frac{c_1}{\sqrt\lambda}e^{\frac l{\sqrt\lambda}}-\frac{c_2}{\sqrt\lambda}e^{-\frac l{\sqrt\lambda}}=0=\frac{c_1}{\sqrt\lambda}(e^{\frac{l}{\sqrt\lambda}}-e^{-\frac{l}{\sqrt\lambda}})\Rightarrow e^{\frac{l}{\sqrt\lambda}}=e^{-\frac{l}{\sqrt\lambda}}$</p><p>分別討論$\lambda$的正負:<br>若$\lambda&gt;0$，無解。<br>若$\lambda=0$，$X(x)=0, u(x,t)=0$，此為平凡解。<br>若$\lambda&lt;0$, $e^{i\frac{l}{\sqrt{|\lambda|}}}=e^{-i\frac{l}{\sqrt{|\lambda|}}}$。<br>利用歐拉公式，上式化簡為$2isin(\frac l{\sqrt{|\lambda|}})=0\iff|\lambda|=\frac{l^2}{n^2\pi^2}$。<br>由此可知，$|\lambda|$必滿足$|\lambda|=\frac{l^2}{n^2\pi^2}$。</p><p>回頭解$T(t)$，$\alpha T(t)/T’(t)=\lambda\Rightarrow\alpha T(t)=\lambda T’(t)\Rightarrow\alpha dt=\frac{\lambda}{T}dT\Rightarrow\int\frac \alpha\lambda dt=\int\frac1{T}dT=\frac\alpha\lambda t=ln(T)\Rightarrow ce^{t\frac \alpha\lambda}=T(t)$</p><p>最後，利用上述的解得到$u(x,t)=X(x)T(t)=K_ne^{-\alpha t\frac{n^2\pi^2}{l^2}}cos(x\frac{n\pi}{l})$</p><p>但注意此處有自由變數$n$，而根據此PDE的線性性質(若有$n$個解$f_i$，則$\sum_{i=1}^n f_i$構成解空間)，所以通解要寫成</p><p>$u(x,t)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_ncos(x\frac{n\pi}{l})e^{-\alpha t\frac{n^2\pi^2}{l^2}}$</p><p>當$t=0$時，$u(x,0)=f(x)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_ncos(x\frac{n\pi}{l})$</p><p>若改成用Dirichlet boundary condition，解則變為$u(x,t)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_nsin(x\frac{n\pi}{l})e^{-\alpha t\frac{n^2\pi^2}{l^2}}$</p><p>正是因為這兩種解都牽涉到將函數轉成用三角函數表達，而促使傅立葉發展出傅立葉級數。</p><hr><h2 id="有限一維模型-程式模擬"><a href="#有限一維模型-程式模擬" class="headerlink" title="有限一維模型-程式模擬"></a>有限一維模型-程式模擬</h2><p>我是用python的matplotlib的套件來畫圖，想看這套件的用法請參考我<a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">以前的文章</a>。<br>定積分用黎曼和計算。</p><p>2D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line">l = np.pi</span><br><span class="line">maxn = <span class="number">1000</span></span><br><span class="line">K = [<span class="number">0</span>] * maxn</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)), np.logical_not(np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.cos(x)</span><br><span class="line"><span class="comment">#return np.cos(np.sin(x * np.pi / l))</span></span><br><span class="line"><span class="comment">#return 1/3 * (x**3) - l/2 * (x**2)</span></span><br><span class="line"><span class="comment">#return (1/5) * (x**5) - ((7 + l) / 4) * (x**4) + ((10 + 7 * l) / 3) * (x**3) - 5*l *(x**2)</span></span><br><span class="line"><span class="comment">#return np.sin(np.pi * x**2 / (2 * l**2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient cos series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_cos</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.cos(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line">K[<span class="number">0</span>] /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient sin series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_sin</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.sin(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn</span>(<span class="params">mode = <span class="string">&quot;cos&quot;</span></span>):</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;cos&quot;</span>:</span><br><span class="line">calKn_cos()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">calKn_sin()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;error argument&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># solution function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">1000</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">s += K[n] * np.cos(x * n * np.pi / l) * np.exp(-alpha * t * (n * np.pi / l) ** <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0.5</span>, l - <span class="number">0.5</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">calKn()</span><br><span class="line"></span><br><span class="line">plt.plot(X, u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=0&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=1&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=2&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>3D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line">l = np.pi</span><br><span class="line">maxn = <span class="number">1000</span></span><br><span class="line">K = [<span class="number">0</span>] * maxn</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)), np.logical_not(np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.cos(x)</span><br><span class="line"><span class="comment">#return np.cos(np.sin(x * np.pi / l))</span></span><br><span class="line"><span class="comment">#return 1/3 * (x**3) - l/2 * (x**2)</span></span><br><span class="line"><span class="comment">#return (1/5) * (x**5) - ((7 + l) / 4) * (x**4) + ((10 + 7 * l) / 3) * (x**3) - 5*l *(x**2)</span></span><br><span class="line"><span class="comment">#return np.sin(np.pi * x**2 / (2 * l**2))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_cos</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.cos(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line">K[<span class="number">0</span>] /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_sin</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.sin(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn</span>(<span class="params">mode = <span class="string">&quot;cos&quot;</span></span>):</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;cos&quot;</span>:</span><br><span class="line">calKn_cos()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">calKn_sin()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;error argument&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">1000</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">s += K[n] * np.cos(x * n * np.pi / l) * np.exp(-alpha * t * (n * np.pi / l) ** <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection = <span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0.5</span>, l - <span class="number">0.5</span>, <span class="number">1024</span>)</span><br><span class="line">T = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">calKn()</span><br><span class="line"></span><br><span class="line">X, T = np.meshgrid(X, T)</span><br><span class="line">U = u(X, T, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;temperature&#x27;</span>)</span><br><span class="line">ax.plot_surface(X, T, U, cmap = <span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>圖片:</p><p>$f(x) = cos(x), l = 2\pi, \alpha = 0.5$<br><img src="https://i.imgur.com/0yMl4b5.png" alt=""></p><p><img src="https://i.imgur.com/dpwXK3M.png" alt=""></p><p>$f(x) = cos(x), l = \pi, \alpha = 0.5$<br><img src="https://i.imgur.com/wLDnDYE.png" alt=""></p><p><img src="https://i.imgur.com/786ARJu.png" alt=""></p><p>$f(x) = cos(sin(x * \pi/l)), l = 5, \alpha = 0.5$<br><img src="https://i.imgur.com/0LrMCvt.png" alt=""></p><p><img src="https://i.imgur.com/YAOzHtZ.png" alt=""></p><p>$f(x) = \frac15x^5 - \frac{7+l}4x^4+\frac{10+7l}3x^3 - 5lx^2, l=5, \alpha = 0.5$<br><img src="https://i.imgur.com/8kR9wrk.png" alt=""></p><p><img src="https://i.imgur.com/MEFUehg.png" alt=""></p><p>$f(x) = \begin{cases}1&amp;,|x-2.5|&lt;0.5\\\\0&amp;,\text{else}\end{cases}, l=5, \alpha = 0.5$<br>原函數為方波。可以很清楚的看見吉布斯現象。<br><img src="https://i.imgur.com/YjjszDZ.png" alt=""></p><p><img src="https://i.imgur.com/IR1N5WI.png" alt=""></p><hr><h2 id="無限長一維模型-數學推導"><a href="#無限長一維模型-數學推導" class="headerlink" title="無限長一維模型-數學推導"></a>無限長一維模型-數學推導</h2><p>具邊界條件的模型，距離邊界越近的地方，誤差值越大，若改成使用”無限長”的長棍，則在有限區間內幾乎無誤差值。</p><p>因現在模型為無限長，故沒有邊界條件，但熱方程與初始條件仍一樣。</p><p>同樣，假設$u(x,t)=X(x)T(t)$，同樣也會得到$\lambda=\frac{X(x)}{X’’(x)}=\frac{\alpha T(t)}{T’(t)}$，也同樣要解$\lambda X’’(x)-X(x)=0$。<br>但與有限長的長棍不同處即在此。</p><p>由前一例可知$\lambda &lt; 0$，$X(x)=c_1e^{i\frac{x}{\sqrt{|\lambda|}}}+c_2e^{-i\frac{x}{\sqrt{|\lambda|}}}$<br>因無邊界條件，所以需要用其他方法化簡$X(x)$。<br>把$X(x)$寫成$\frac{c_1+c_2}2e^{i\frac{x}{\sqrt{|\lambda|}}}+\frac{c_1+c_2}2e^{-i\frac{x}{\sqrt{|\lambda|}}}+\frac{c_1-c_2}2e^{i\frac{x}{\sqrt{|\lambda|}}}-\frac{c_1-c_2}2e^{-i\frac{x}{\sqrt{|\lambda|}}}$<br>得到$X(x)=(c_1+c_2)cos(\frac{x}{\sqrt{|\lambda|}})+i(c_1-c_2)sin(\frac{x}{\sqrt{|\lambda|}})=Acos(\frac{x}{\sqrt{|\lambda|}})+Bsin(\frac{x}{\sqrt{|\lambda|}})$</p><p>$T(t)$則與前例一樣，$T(t)=ce^{t\frac \alpha\lambda}$</p><p>得到特解$u_{\lambda}(x,t)=(A_{\lambda}cos(\frac{x}{\sqrt{|\lambda|}})+B_{\lambda}sin(\frac{x}{\sqrt{|\lambda|}}))e^{-\frac{t\alpha}{|\lambda|}}$。<br>為了讓他好看點，令$p=\frac1{\sqrt{|\lambda|}}$。<br>則特解變為: $u_p(x,t)=(A_{p}cos(px)+B_{p}sin(px))e^{-p^2t\alpha}$<br>依據這個PDE的線性性質，即乘上一常數($\Delta p$)後仍為解答，$\sum^\infty_{n=0}\Delta p u_{n\Delta p}(x,t)$為通解。</p><p>$\lim_{\Delta p\to 0}\sum^\infty_{n=0}\Delta p u_{n\Delta p}(x,t)=\int^\infty_0u_p(x,t)dp=\int^\infty_0(A_{p}cos(px)+B_{p}sin(px))e^{-p^2t\alpha}dp=u(x,t)$</p><p>當$t=0$時，$u(x,0)=f(x)=\int^\infty_0(A_{p}cos(px)+B_{p}sin(px))dp$，其中，$A_p=\frac1\pi\int^\infty_{-\infty}f(x)cos(px)dx$ and $B_p=\frac1\pi\int^\infty_{-\infty}f(x)sin(px)dx$</p><p>可以自己驗證看看，這個解仍符合原先的PDE。</p><p>上式可進一步變換成複數型傅立葉轉換，過程與一般的傅立葉積分變成複數型傅立葉轉換一樣，故在此省略，直接寫出公式:<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}F(p)e^{ipx}e^{-t\alpha p^2}dp$ ，其中， $F(p)=\int^{\infty}_{-\infty}f(v)e^{-ipv}dv$</p><p>一般會認為到此結束，但實際上因為$e^{-t\alpha p^2}$這項的存在，導致可以”交換積分順序”。<br>為何如此?<br>根據Fubini’s theorem，只要 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}|dv)dp$ 與 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}|dp)dv$ 兩者都收斂，則<br>$\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}dv)dp$ 與 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}dp)dv$同樣收斂，且結果相同。</p><p>檢查 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dv)dp$ 是否收斂:<br>$\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|e^{ip(x-v)}f(v)|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|f(v)cos(p(x-v))+if(v)sin(p(x-v))|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}\sqrt{f^2(v)cos^2(p(x-v))+f^2(v)sin^2(p(x-v))}dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|f(v)|dv)dp$</p><p>檢查 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dp)dv$ 是否收斂的步驟與上面相似，故省略。</p><p>兩者收斂的條件相同，都是需要$f(x)$在$\Bbb R$上絕對收斂，而這也正是傅立葉轉換存在的條件之一。</p><p>注意一般使用傅立葉轉換不能交換積分順序，原因是因為 $\frac{1}{2\pi}\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|f(v)e^{-i\omega v} e^{i\omega x}| dv) d\omega$ 並不收斂(實際上兩種皆不收斂)。</p><p>利用交換積分順序<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}f(v)(\int^{\infty}_{-\infty}e^{ip(x-v)}e^{-t\alpha p^2}dp)dv$。</p><p>注意中間的積分項<br>$\int^{\infty}_{-\infty}e^{ip(x-v)}e^{-t\alpha p^2}dp=\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))+ie^{-t\alpha p^2}sin(p(x-v))\,dp$<br>其中虛部為奇函數，故可消去，變為$\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))dp$</p><p>這個不定積分無法用初等函數寫出，但其定積分有很多做法: 曲線積分、積分內取微分、級數展開。<br>這裡用”積分內取微分”來解:<br>簡化上面的積分為 $\int^\infty_0e^{-s^2}cos(bs)ds$，<br>$I(b)=\int^\infty_0e^{-s^2}cos(bs)ds$<br>$I’(b)=\int^\infty_0\frac{\partial}{\partial b}(e^{-s^2}cos(bs))ds=\int^\infty_0-se^{-s^2}sin(bs)ds=-\frac12 bI(b)$<br>解此ODE:<br>$I’(b)=-\frac12 bI(b)\Rightarrow I(b)=\frac{\sqrt\pi}2e^{-\frac{b^2}4}$</p><p>令上述積分的$t\alpha p^2=s^2$ and $b=\frac{x-v}{\sqrt{t\alpha}}$，所以，$\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))dp=\sqrt\frac{\pi}{t\alpha}e^{-\frac{(x-v)^2}{4t\alpha}}$</p><p>答案變為<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}f(v)(\sqrt\frac{\pi}{t\alpha}e^{-\frac{(x-v)^2}{4t\alpha}})dv=\frac1{2\sqrt{\pi t \alpha}}\int^{\infty}_{-\infty}f(v)e^{-\frac{(x-v)^2}{4t\alpha}}dv$</p><p>因為$t$在分母，會令$t=0$時程式實作不方便，可以令$z=\frac{v-x}{2\sqrt{t\alpha}}$，則最終答案:<br><img src="https://i.imgur.com/dxUt3Ez.png" alt=""></p><hr><h2 id="無限長一維模型-程式模擬"><a href="#無限長一維模型-程式模擬" class="headerlink" title="無限長一維模型-程式模擬"></a>無限長一維模型-程式模擬</h2><p>這裡牽涉到上下界無限的瑕積分，我寫了兩種方法:<br>第一是直接截斷，將上下界當作一個很大的值，再直接當定積分做；<br>第二是利用變數變換，考慮$\int_{\Bbb R}f(x)dx$，令$x=tan k$，則剛剛的積分可寫為$\int^{\pi/2}_{-\pi/2}f(tan k)\cdot sec^2(k)dk$，如此，上下界無限的積分就可變為一般的定積分，<br>(若要更精確，還可以將$[\pi/2-\Delta k, \pi/2]$以及$[-\pi/2,-\pi/2+\Delta k]$這兩個被捨去的區間一律當作$f(tan(\pm\pi/2\mp\Delta k))\cdot sec^2(\pm\pi/2\mp\Delta k)$計算)<br>(不過在我實際測試中，肉眼看不太出來兩種方法的差別，我猜測是因為收斂速度很快導致的。)</p><p>2D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.exp(-x**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tan(k)-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = np.pi / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn):</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk * n) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>)</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(np.pi / <span class="number">2</span> - dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>) * (sec(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># non-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonsub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, L = -<span class="number">100</span>, R = <span class="number">100</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = (R - L) / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn - <span class="number">1</span>):</span><br><span class="line">s += f(x + <span class="number">2</span> * (L + dk * n) * np.sqrt(t * alpha)) * np.exp(-(L + dk * n)**<span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=0&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=1&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=2&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>3D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="keyword">return</span> np.sinc(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tan(k)-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = np.pi / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn):</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk * n) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>)</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(np.pi / <span class="number">2</span> - dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>) * (sec(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># non-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonsub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, L = -<span class="number">100</span>, R = <span class="number">100</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = (R - L) / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn - <span class="number">1</span>):</span><br><span class="line">s += f(x + <span class="number">2</span> * (L + dk * n) * np.sqrt(t * alpha)) * np.exp(-(L + dk * n)**<span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection = <span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line">T = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">X, T = np.meshgrid(X, T)</span><br><span class="line">U = sub_u(X, T, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;temperature&#x27;</span>)</span><br><span class="line">ax.plot_surface(X, T, U, cmap = <span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>圖片:</p><p>$f(x)=e^{-x^2}, \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://i.imgur.com/33X8liB.png" alt=""></p><p><img src="https://i.imgur.com/JWtbA2G.png" alt=""></p><p>變數替換:<br><img src="https://i.imgur.com/o7MIhvA.png" alt=""></p><p><img src="https://imgur.com/x39ndEL.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://imgur.com/OmyMtZZ.png" alt=""></p><p><img src="https://imgur.com/xikIRne.png" alt=""></p><p>變數替換:<br><img src="https://imgur.com/BBRTe9s.png" alt=""></p><p><img src="https://imgur.com/JVYhixq.png" alt=""></p><p>$f(x)=sinc(x), \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://imgur.com/sKGN7F4.png" alt=""></p><p><img src="https://imgur.com/AZEXi9h.png" alt=""></p><p>變數替換:<br><img src="https://imgur.com/uPk9Umj.png" alt=""></p><p><img src="https://imgur.com/aKPUXjc.png" alt=""></p><hr><h2 id="無限長一維模型-離散化-1"><a href="#無限長一維模型-離散化-1" class="headerlink" title="無限長一維模型-離散化 1"></a>無限長一維模型-離散化 1</h2><p>既然都有CFT了，那試試看DFT能不能也產生同樣的效果。<br>將原函數取樣成一個個數據點，接著就可以利用DFT以及非正常(?)IDFT來處理:</p><p>直接寫出答案: $u(n,t)=\frac1{L}\sum^{L-1}_{k=0}(\sum^{L-1}_{m=0}f[m]e^{-i\frac{2\pi}{L}km})e^{i\frac{2\pi}{L}nk}e^{-t\alpha k^2}$<br>其中$\hat{f}[k] = \sum^{L-1}_{m=0}f[m]e^{-i\frac{2\pi}{L}km}$就是DFT。</p><hr><h2 id="無限長一維模型-離散化-1-程式模擬"><a href="#無限長一維模型-離散化-1-程式模擬" class="headerlink" title="無限長一維模型-離散化 1-程式模擬:"></a>無限長一維模型-離散化 1-程式模擬:</h2><p>離散型就沒畫成3D圖了，只有2D疊層圖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.exp(-x**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line">L = <span class="number">100</span></span><br><span class="line">W_L = np.exp(-<span class="number">2j</span> * np.pi / L)</span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sample of original function</span></span><br><span class="line"><span class="comment"># n shall be in [0, maxn - 1]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>(<span class="params">n</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">return</span> f(l + dk * n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># naive DFT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hatf</span>(<span class="params">k</span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">s += samplef(m) * (W_L**(k*m))</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># naive IDFT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">s += hatf(k) * (W_L**(-k*n)) * np.exp(-t * alpha * (k**<span class="number">2</span>))</span><br><span class="line">s /= L</span><br><span class="line"><span class="keyword">return</span> s.real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.array([*<span class="built_in">range</span>(L)])</span><br><span class="line">t0 = u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map the [1, L) to (l, r)</span></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l</span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=2&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2},\alpha = 0.5$<br><img src="https://imgur.com/rJMNtSC.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, \alpha = 0.5$<br><img src="https://imgur.com/sWiby2j.png" alt=""></p><p>$f(x)=sinc(x), \alpha = 0.5$<br><img src="https://imgur.com/KMF1DH4.png" alt=""></p><p>雖然看起來蠻正確的，但對比連續的模型誤差蠻大的，看下圖:</p><p>$f(x)=e^{-x^2},\alpha = 0.5$</p><p>離散模擬:<br><img src="https://imgur.com/cnGY4dc.png" alt=""></p><p>連續模擬:<br><img src="https://imgur.com/urTBuA3.png" alt=""></p><p>我猜測是因為隨隨便便就把$e^{-t\alpha k^2}$離散化導致的。</p><hr><h2 id="無限長一維模型-離散化-2"><a href="#無限長一維模型-離散化-2" class="headerlink" title="無限長一維模型-離散化 2"></a>無限長一維模型-離散化 2</h2><p>仔細想想剛剛那樣不嚴謹的轉換有點糟糕，認真分析一下:<br>最開始的解為:<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}f(v)e^{-ipv}dv)e^{ipx}e^{-t\alpha p^2}dp$</p><p>左思右想，這不就是$u(x, t)=\mathscr F^{-1}[\mathscr F[f(x)]\cdot e^{-t\alpha p^2}]$。<br>改寫一下，<img src="https://i.imgur.com/pHZbDVV.png" alt=""><br>先計算出<img src="https://i.imgur.com/7TOsJAo.png" alt=""><br>所以答案又可以寫成<img src="https://i.imgur.com/ZIpFvI7.png" alt=""></p><p>先寫個連續的摺積試試看效果:<br><img src="https://imgur.com/NKQ1LOX.png" alt=""></p><p><img src="https://imgur.com/WGEMj0X.png" alt=""></p><p><img src="https://imgur.com/ES6pZWq.png" alt=""></p><p>可以看見都沒有剛剛隨便離散導致的誤差問題。</p><p>那既然，連續的摺積可以了，那離散的呢?</p><p>先切樣本出來，假設我們是在$[l,r]$上切出$L$個樣本。<br><img src="https://i.imgur.com/KlkPerB.png" alt="">，其中<img src="https://i.imgur.com/BkiwaQC.png" alt=""><br><img src="https://i.imgur.com/fl5VwBP.png" alt=""></p><p>將摺積離散化後: $u(n,t)=\Delta k \sum_{m=0}^{2L-1}f[n-m]G_t[m]$</p><p>裡面的$\Delta k$是歸一化係數，一定要乘，否則數據會失準。</p><hr><h2 id="無限長一維模型-離散化-2-程式模擬"><a href="#無限長一維模型-離散化-2-程式模擬" class="headerlink" title="無限長一維模型-離散化 2-程式模擬"></a>無限長一維模型-離散化 2-程式模擬</h2><p>實作上有個小缺陷，當$t=0$時，會產生divided by zero exception所以我用$t=0.01$去逼近。<br>那如果從數學的角度看，當$\lim_{t\to0}$時，$\mathscr F^{-1}[e^{-t\alpha p^2}]=\delta(x)$<br>$(f * \delta)(x)=f(x)$，所以數學上是沒問題的。</p><p>很巧合地(應該是必然的結果)，$\lim_{t\to0}\frac1{\sqrt{\pi t\alpha}}e^{-\frac{x^2}{4t\alpha}}$，可以寫成另一種形式(令$a=2\sqrt{t\alpha}$): $\lim_{a\to0}\frac1{a\sqrt{\pi}}e^{-\frac{x^2}{a^2}}$，而這正是$\delta(x)$在分佈意義上的定義。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> np.piecewise(x, [np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>), np.logical_not(np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>))], [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heat transfer characteristic function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">x, t, alpha</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * np.sqrt(<span class="number">1</span> / (t * alpha * np.pi)) * np.exp(-(x**<span class="number">2</span>) / (<span class="number">4</span> * t * alpha))</span><br><span class="line"></span><br><span class="line">L = <span class="number">100</span></span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sf = np.array([<span class="number">0.0</span>] * (<span class="number">3</span>*L))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>():</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sf[i] = f(l + dk * i)</span><br><span class="line"></span><br><span class="line">sG = np.array([<span class="number">0.0</span>] * (<span class="number">3</span>*L))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sampleG</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sG[i] = G(l + dk * i, t, alpha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>: <span class="keyword">return</span> sf[n];</span><br><span class="line">sampleG(t, alpha)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * L):</span><br><span class="line">s += sf[n - m] * sG[m]</span><br><span class="line">s *= dk</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample the original function first</span></span><br><span class="line">samplef()</span><br><span class="line">X = np.array([*<span class="built_in">range</span>(<span class="number">2</span> * L)])</span><br><span class="line"></span><br><span class="line">t0 = u(X, <span class="number">0.01</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t4 = u(X, <span class="number">50</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map the [1, 2L-1] to [2l, 2r)</span></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0.01&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=4&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t4, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=50&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2}, l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/C6GTC9W.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/l83G7J0.png" alt=""></p><p>$f(x)=sinc(x), l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/1QVyy7D.png" alt=""></p><p>顯然結果比隨便離散化好多了。</p><hr><h2 id="無限長一維模型-離散化-FFT-ver"><a href="#無限長一維模型-離散化-FFT-ver" class="headerlink" title="無限長一維模型-離散化-FFT ver."></a>無限長一維模型-離散化-FFT ver.</h2><p>那既然有摺積了，何不來點FFT加速?</p><p><img src="https://i.imgur.com/WJbpjDp.png" alt=""> ，其中 <img src="https://i.imgur.com/2RtVAeV.png" alt=""><br><img src="https://i.imgur.com/Z3GSyb0.png" alt=""></p><p>$u(n,t)=(f*G_t)[n]=\mathscr F^{-1}[\mathscr F[f]\cdot\mathscr F[G_t]][n]$</p><p>將FFT套用進DFT，就可以加速整體運算。</p><hr><h2 id="無限長一維模型-離散化-FFT-ver-程式模擬"><a href="#無限長一維模型-離散化-FFT-ver-程式模擬" class="headerlink" title="無限長一維模型-離散化-FFT ver.-程式模擬"></a>無限長一維模型-離散化-FFT ver.-程式模擬</h2><p>這裡我參考正向的蝶形網路，先將數據點重新排列，再不斷的計算小部分的傅立葉轉換。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> np.piecewise(x, [np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>), np.logical_not(np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>))], [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heat transfer characteristic function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">x, t, alpha</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * np.sqrt(<span class="number">1</span> / (t * alpha * np.pi)) * np.exp(-(x**<span class="number">2</span>) / (<span class="number">4</span> * t * alpha))</span><br><span class="line"></span><br><span class="line">L = <span class="number">256</span></span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sf = np.zeros((L), dtype = <span class="built_in">complex</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>():</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sf[i] = f(l + dk * i)</span><br><span class="line"></span><br><span class="line">sG = np.zeros((L), dtype = <span class="built_in">complex</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sampleG</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sG[i] = G(l + dk * i, t, alpha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fft</span>(<span class="params">X, mode = <span class="string">&#x27;fft&#x27;</span></span>):</span><br><span class="line">tmp = np.zeros((<span class="number">2</span>, (Len:=<span class="built_in">len</span>(X))), dtype = <span class="built_in">complex</span>)</span><br><span class="line">tmp[<span class="number">0</span>] = np.copy(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reorder</span></span><br><span class="line">N = <span class="built_in">len</span>(tmp[<span class="number">0</span>])</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">k = N &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> ((j := j ^ k) &amp; k):</span><br><span class="line">k &gt;&gt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; j):</span><br><span class="line">tmp[<span class="number">0</span>][i], tmp[<span class="number">0</span>][j] = tmp[<span class="number">0</span>][j], tmp[<span class="number">0</span>][i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># fft</span></span><br><span class="line">N = <span class="number">2</span></span><br><span class="line">W = np.exp((-<span class="number">1</span> <span class="keyword">if</span> mode == <span class="string">&#x27;fft&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>) * <span class="number">2j</span> * np.pi / N)</span><br><span class="line">lev = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> N &lt;= Len:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Len):</span><br><span class="line"><span class="keyword">if</span> i % N &lt; (N &gt;&gt; <span class="number">1</span>):</span><br><span class="line">base = (i // N) * N</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][(i + (<span class="number">1</span> &lt;&lt; lev)) % N + base] += tmp[lev &amp; <span class="number">1</span>][i]</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][i % N + base] += tmp[lev &amp; <span class="number">1</span>][i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">base = (i // N) * N</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][(i + (<span class="number">1</span> &lt;&lt; lev)) % N + base] += tmp[lev &amp; <span class="number">1</span>][i] * ( W ** ((i + (<span class="number">1</span> &lt;&lt; lev)) % N) )</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][i % N + base] += tmp[lev &amp; <span class="number">1</span>][i] * ( W ** (i % N) )</span><br><span class="line">tmp[lev &amp; <span class="number">1</span>] = np.zeros((Len))</span><br><span class="line">W **= <span class="number">0.5</span></span><br><span class="line">lev += <span class="number">1</span></span><br><span class="line">N &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp[(lev) &amp; <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ifft</span>(<span class="params">X</span>):</span><br><span class="line"><span class="keyword">return</span> fft(X, mode = <span class="string">&#x27;ifft&#x27;</span>) / <span class="built_in">len</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calu</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>: <span class="keyword">return</span> sf[n];</span><br><span class="line">sampleG(t, alpha)</span><br><span class="line"></span><br><span class="line">cpsf = np.append(sf, np.zeros((L)))</span><br><span class="line">cpsG = np.append(sG, np.zeros((L)))</span><br><span class="line">s = ifft(fft(cpsf) * fft(cpsG))</span><br><span class="line">s *= dk</span><br><span class="line"><span class="keyword">return</span> s.real</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">s = calu(t, alpha)</span><br><span class="line"><span class="keyword">return</span> s[n]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">samplef()</span><br><span class="line">X = np.array([*<span class="built_in">range</span>(<span class="number">2</span> * L)])</span><br><span class="line"></span><br><span class="line">t0 = u(X, <span class="number">0.01</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t4 = u(X, <span class="number">50</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0.01&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=4&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t4, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=50&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2}, l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/us07TMl.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/566gh5Q.png" alt=""></p><p>$f(x)=sinc(x), l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/D9eJqx8.png" alt=""></p><hr><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><p><a href="https://github.com/OEmiliatanO/heat_transfer_simulation">https://github.com/OEmiliatanO/heat_transfer_simulation</a></p><hr><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>這次的專題做的特別久，大概花了我3、4天的時間，但也收穫頗豐。<br>複習了以前做過的ODE解法，也學到了一點PDE解法、Leibniz integral rule、還有數值方法的技巧。<br>雖然推導過程不算太嚴謹，有一些步驟我沒有辦法判斷是否合法，例如從有限變成無限時，要乘上一常數，然後取極限，且這個常數是解的參數，從直覺上來講，這感覺就非法的，但結果是對的。<br>不確定其他類似的PDE也可以這樣做，希望有人可以指點迷津。</p><p>最後的離散化應該是我苦惱最久的，前面的連續版本只花一個晚上就推導出來了，之後就開始寫code、debug，寫完之後才處理離散化的問題，接著想了一整天才想到怎麼好好離散化。</p><p>blog的上一篇跟這篇隔了整整一年呢。</p><p>2023.5.17 更: 網站的render好像有改版，有一些數學公式都壞了，所以換成圖片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;微積分(其實是教basic fourier analysis)期末專題。&lt;br&gt;我研究的主題是&lt;a href=&quot;https://en.wik</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>最速降線問題-變分法</title>
    <link href="http://yoursite.com/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E8%AE%8A%E5%88%86%E6%B3%95/"/>
    <id>http://yoursite.com/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E8%AE%8A%E5%88%86%E6%B3%95/</id>
    <published>2021-04-13T13:28:13.000Z</published>
    <updated>2021-04-15T05:43:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。<br>總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是歐拉、拉格朗日提出的解法(當初雅各布·伯努利的解法也用到了變分的思想所以就統一寫一起了)、第三個比較特別，不是最速降線，但結果同樣是擺線。<br>這是第二篇。</p><hr><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>在無摩擦力、只有重力的情況下，一質點從一點A為起點，由速率0開始沿著某曲線滑，至B點(高度不超過A)，且 <strong>耗時最短</strong> ，求此曲線。</p><hr><h1 id="變分法推導"><a href="#變分法推導" class="headerlink" title="變分法推導"></a>變分法推導</h1><p>最速降線問題是在找$\int^{x_1}_{x_0} \sqrt{\frac{1+y’^2}{2gy}} dx$這個式子的極值。(不知道這個式子怎麼來的可以看<a href="https://oemiliatano.github.io/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/">上一篇</a>)<br>將這類型問題一般化後可以寫出</p><p>$\int^{x_1}_{x_0} F(x, y, y’) dx$</p><p>其中，$y, y’$是$x$的函數。</p><p>我們想要通過選擇最好的y來得到極值，類似於以前一般函數選取好的x值求極值，但是現在是 <strong>選取好的函數再求目標函數極值</strong><br>相仿於一般函數，可以寫出<br>$I(y) = \int^{x_1}_{x_0} F(x, y, y’) dx$，而這個$I$則被稱為泛函數。<br>也相仿於一般函數求極值，若對泛函求導後使其=0，就可以得到極值，但是該怎麼定義$\frac{dI}{dy}$ ?</p><p>假定有一函數$y$可以使得$I$到達極值，可以構造出這樣一個東西: $g(\epsilon) = I(y + \epsilon \eta) = I(\hat{y})$，$\hat{y’} = y’ + \epsilon \eta’$<br>$\eta$是任意函數(但兩端點都必須為0)，$\epsilon$是任意實數，由此將這個問題轉為一般的函數求極值問題。<br><img src="https://imgur.com/x78iM1p.png" alt=""></p><p>通過$g(\epsilon)$對$\epsilon$求導數:</p><p>$\frac{dg}{d\epsilon} = \frac{d}{d\epsilon} \int^{x_1}_{x_0} F(x, \hat{y}, \hat{y’}) dx$</p><p>求導跟積分互換<br>$\frac{dg}{d\epsilon} = \int^{x_1}_{x_0} \frac{d}{d\epsilon} F(x, \hat{y}, \hat{y’}) dx$</p><p>現在要求$dF(x, \hat{y}, \hat{y’})$，利用全微分:<br>$dF = F_x dx + F_{\hat{y}} d\hat{y} + F_{\hat{y’}} d\hat{y’}$<br>兩邊同除$d\epsilon$得</p><p>$\frac{dF}{d\epsilon} = F_x \frac{dx}{d\epsilon} + F_{\hat{y}} \frac{d\hat{y}}{d\epsilon} + F_{\hat{y’}}\frac{d\hat{y’}}{d\epsilon}$<br>(底標代表對那個變數的偏微分)</p><p>明顯$\frac{dx}{d\epsilon}=0$, $\frac{d\hat{y}}{d\epsilon} = \eta$, $\frac{d\hat(y’)}{d\epsilon} = \eta’$</p><p>$\frac{dF}{d\epsilon} = F_{\hat{y}}\eta + F_{\hat{y’}}\eta’$</p><p>將上述結果代回去</p><p>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} F_{\hat{y}}\eta dx + \int_{x_0}^{x_1} F_{\hat{y’}}\eta’ dx$</p><p>將後項分部積分:<br><img src="https://imgur.com/IyiNQDd.png" alt=""></p><p>顯然，$F_{\hat{y’}}\eta|^{x_1}_{x_0} = 0$</p><p>$\int_{x_0}^{x_1} F_{\hat{y}}\eta dx - \int_{x_0}^{x_1} \frac{dF_{\hat{y’}}}{dx}\eta dx$</p><p>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} (F_{\hat{y}} - \frac{dF_{\hat{y’}}}{dx})\eta dx$</p><p>由定義可以知道，當$\epsilon = 0$就可以得到極值，$\frac{dg}{d\epsilon} |^{\epsilon = 0} = 0$，而$\epsilon = 0$時，$\hat{y} = y$, $\hat{y’} = y’$<br>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} (F_{y} - \frac{dF_{y’}}{dx})\eta dx$</p><p>最後一步要證明$\int_{a}^{b} f(x)\eta dx = 0$，且$\eta$為任意函數(同樣兩端為0)，則$f(x) = 0$</p><p>定 $r(a) = r(b) = 0$，且$r(x) &gt; 0, x\in[a, b]$</p><p>令 $f(x) = r(x)\eta(x)$</p><p>$\int^{b}_{a} r(x)\eta^2(x) dx = 0$</p><p>因為$r(x)$在$(a,b)$大於0，所以$f(x)$在$(a, b)$中必為0</p><hr><p>利用上面的證明可以知道</p><p>$(F_{y} - \frac{dF_{y’}}{dx}) = 0$</p><p>這就是 <strong>歐拉-拉格朗日方程式</strong></p><p>而這個方程式有兩個特殊形式:</p><ol><li><p>若f(x, y, y’) = f(x, y’)，可寫成 $F_{y’} = C$</p></li><li><p>若f(x, y, y’) = f(y, y’)，可寫成 $F - y’F_{y’} = C$</p></li></ol><hr><h1 id="利用變分法解決最速降線"><a href="#利用變分法解決最速降線" class="headerlink" title="利用變分法解決最速降線"></a>利用變分法解決最速降線</h1><p>回到一開始的式子</p><p>$\int_{x_0}^{x_1} \sqrt{\frac{1+y’^2}{2gy}} dx$</p><p>$\sqrt{\frac{1+y’^2}{2gy}}$就是$F(x, y, y’)$，只需要求解$(F_{y} - \frac{dF_{y’}}{dx}) = 0$就可以得到答案。</p><p>注意到$F$符合第二個特殊形式，故寫成<br>$\sqrt{\frac{1+y’^2}{2gy}} - y’\sqrt{\frac{y’^2}{2(1+y’^2)gy}} = C$<br>整理:<br>$\frac{1+y’^2}{\sqrt{2(1+y’^2)gy}} - \frac{y’^2}{\sqrt{2(1+y’^2)gy}} = C$</p><p>$\frac{1}{\sqrt{2(1+y’^2)gy}}= C$</p><p>$\frac{1}{(1+y’^2)y}= 2gC^2$</p><p>$\frac{1}{(1+y’^2)}= yK$, $K = 2gC^2$</p><p>$y’^2 = (yK)^{-1} - 1$</p><p>$y’ = \sqrt{(yK)^{-1} - 1}$</p><p>$((yK)^{-1} - 1)^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{1 - yK}{yK})^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{yK}{1 - yK})^{\frac{1}{2}} dy = dx$<br>兩邊積分<br>$\int (\frac{yK}{1 - yK})^{\frac{1}{2}} dy = \int dx$</p><p>令$y = \frac{sin^2\theta}{K}$, $dy = \frac{2sin\theta cos\theta}{K} d\theta$</p><p>$\int \frac{2sin^2\theta}{K} d\theta = x$</p><p>$\frac{1}{K}\int 2sin^2\theta d\theta = x$</p><p>$\frac{1}{K}(\theta - \frac{1}{2}sin2\theta) + C = x$</p><p>$\frac{1}{2K}(2\theta - sin2\theta) + C = x$</p><p>整理好，令$\alpha = 2\theta$<br>$x = \frac{1}{4gC^2}(\alpha - sin\alpha) + C$<br>$y = \frac{sin^2\theta}{K} = \frac{1}{4gC^2}(1-cos\alpha)$</p><p>這個即是 <strong>擺線的參數方程式</strong>。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個方法比起光解法更難，也更具一般性，通過這個方法也可以解決懸鏈線、最小曲面問題。<br>總的來說，這是一個比光解法更加精采的解法。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/brachistochrone.pdf">http://www.cust.edu.tw/mathmet/brachistochrone.pdf</a><br><a href="https://zhuanlan.zhihu.com/p/20718489">https://zhuanlan.zhihu.com/p/20718489</a><br><a href="http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html">http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations">https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations</a><br><a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B">https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B</a><br><a href="https://www.zhihu.com/question/39494645">https://www.zhihu.com/question/39494645</a><br><a href="https://www.jianshu.com/p/961e890e88b2">https://www.jianshu.com/p/961e890e88b2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。&lt;br&gt;總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>最速降線問題-光解法</title>
    <link href="http://yoursite.com/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/"/>
    <id>http://yoursite.com/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/</id>
    <published>2021-04-13T12:54:05.000Z</published>
    <updated>2021-04-15T05:43:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。<br>總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是歐拉、拉格朗日提出的解法(當初雅各布·伯努利的解法也用到了變分的思想所以就統一寫一起了)、第三個比較特別，不是最速降線，但結果同樣是擺線。<br>這是第一篇。</p><hr><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>在無摩擦力、只有重力的情況下，一質點從一點A為起點，由速率0開始沿著某曲線滑，至B點(高度不超過A)，且 <strong>耗時最短</strong> ，求此曲線。</p><hr><h1 id="光解法"><a href="#光解法" class="headerlink" title="光解法"></a>光解法</h1><p>約翰·伯努利(歐拉的老師)提出這個解法。</p><p>由費馬原理可以知道光總是走耗時最少的路徑，可以利用光來類比質點，求得最速路徑。</p><p>首先，可以知道一質點垂直方向下降$y$時的速度，$v = \sqrt{2gy}$。<br>可以構造出無限多層、但總厚度固定的不同介質，使得光速也滿足上面的速度條件。<br>又由於折射定律$\frac{sin\theta_k}{v_k} = C$<br><img src="https://imgur.com/3NYHjHZ.png" alt=""><br>得$\frac{sin\theta}{\sqrt{y}} = C\sqrt{2g}$</p><p>這個式子代表，這個曲線的任一點都滿足此條件，由此可以計算出此曲線。</p><p>將$sin\theta$換成$dx,dy,ds$的形式:<br>$\frac{\frac{dx}{ds}}{\sqrt{y}} = C’$</p><p>$\frac{\frac{dx}{\sqrt{dx^2 + dy^2}}}{\sqrt{y}} = C’$</p><p>$\frac{\frac{dx^2}{dx^2 + dy^2}}{y} = C’^2$</p><p>$\frac{dx^2}{dx^2 + dy^2} = yK$, $K = 2gC^2$</p><p>左式上下同除$dx^2$<br>$\frac{1}{1 + y’^2} = yK$</p><p>$y’^2 = (yK)^{-1} - 1$</p><p>$y’ = \sqrt{(yK)^{-1} - 1}$</p><p>$((yK)^{-1} - 1)^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{1 - yK}{yK})^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{yK}{1 - yK})^{\frac{1}{2}} dy = dx$<br>兩邊積分<br>$\int (\frac{yK}{1 - yK})^{\frac{1}{2}} dy = \int dx$</p><p>令$y = \frac{sin^2\theta}{K}$, $dy = \frac{2sin\theta cos\theta}{K} d\theta$</p><p>$\int \frac{2sin^2\theta}{K} d\theta = x$</p><p>$\frac{1}{K}\int 2sin^2\theta d\theta = x$</p><p>$\frac{1}{K}(\theta - \frac{1}{2}sin2\theta) + C = x$</p><p>$\frac{1}{2K}(2\theta - sin2\theta) + C = x$</p><p>整理好，令$\alpha = 2\theta$<br>$x = \frac{1}{4gC^2}(\alpha - sin\alpha) + C$<br>$y = \frac{sin^2\theta}{K} = \frac{1}{4gC^2}(1-cos\alpha)$</p><p>這個即是 <strong>擺線的參數方程式</strong>。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個方法跟變分法比起來缺乏一般性，但這不影響這個解法非常精采。<br>表面上看起來缺乏變分的想法，但實際上，「光的路徑」這一概念可以連結到最小作用量，也就是說，這個解法將變分包裝了起來，本質上還是變分的想法。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/brachistochrone.pdf">http://www.cust.edu.tw/mathmet/brachistochrone.pdf</a><br><a href="https://zhuanlan.zhihu.com/p/20718489">https://zhuanlan.zhihu.com/p/20718489</a><br><a href="http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html">http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations">https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations</a><br><a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B">https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B</a><br><a href="https://www.zhihu.com/question/39494645">https://www.zhihu.com/question/39494645</a><br><a href="https://www.jianshu.com/p/961e890e88b2">https://www.jianshu.com/p/961e890e88b2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。&lt;br&gt;總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>語法樹</title>
    <link href="http://yoursite.com/2021/03/22/%E8%AA%9E%E6%B3%95%E6%A8%B9/"/>
    <id>http://yoursite.com/2021/03/22/%E8%AA%9E%E6%B3%95%E6%A8%B9/</id>
    <published>2021-03-22T13:34:28.000Z</published>
    <updated>2021-03-30T12:46:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在玩編譯器的實作，裡面有提到語法樹，正好是我國中時看到但是無法實作的東西，就來填自己以前的坑囉。</p><hr><h1 id="開頭問題"><a href="#開頭問題" class="headerlink" title="開頭問題"></a>開頭問題</h1><p>實作出可以四則運算的計算機。</p><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>四則運算必須考慮到$+$, $-$, $\times$, $\div$的運算優先度，還有()的使用。<br>乍看之下很複雜，但是可以感覺的某種遞迴的關係，例如:$5+9 \times 7$，可以看成$(5)+(9 \times 7)$，而右邊的括號又可以看成一個獨立的算式。<br>根據上面的規則可以將算式寫成樹，每個節點都是不同的運算子或數字。<br><img src="https://imgur.com/SQz2ogg.png" alt="Imgur"><br>將左子樹跟右子樹算好後，再根據此節點的符號運算，就可以得到答案。</p><hr><h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><p>實作上可以先將運算式拆成一個個token後，利用list串起來。<br>例如: $5 + 9 \times 7$，”5”是數字類型的token、”+”是符號類型，token的好處是可以以避免不必要的麻煩，例如空白、非法字元等。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>首先定義token的種類:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    TK_sign, <span class="comment">// 符號</span></span><br><span class="line">    TK_num,  <span class="comment">// 數字</span></span><br><span class="line">    TK_EOL,  <span class="comment">// end of line</span></span><br><span class="line">&#125; TokenKind;</span><br></pre></td></tr></table></figure></p><p>token本體:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Token</span> Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line">    TokenKind kind;</span><br><span class="line">    Token* nex;</span><br><span class="line">    <span class="type">int64_t</span> num;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>new一個token，並設定種類<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Token* <span class="title">new_Token</span><span class="params">(TokenKind TKK, <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Token* tmp = (Token *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(Token));</span><br><span class="line">    tmp-&gt;kind = TKK;</span><br><span class="line">    tmp-&gt;str = str;</span><br><span class="line">    tmp-&gt;nex = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>將算式處理成token。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Token* <span class="title">tokenize</span><span class="params">(<span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Token head; <span class="comment">// head is a EMPTY token, and shouldn&#x27;t be returned</span></span><br><span class="line">    head.nex = <span class="literal">nullptr</span>;</span><br><span class="line">    Token* tail = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 跳過空白</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            ++s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判斷是否是合法的符號，是自定義的函式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSign</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;nex = <span class="built_in">new_Token</span>(TK_sign, s++);</span><br><span class="line">            tail = tail-&gt;nex;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判斷是否是數字</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;nex = <span class="built_in">new_Token</span>(TK_num, s);</span><br><span class="line">            tail = tail-&gt;nex;</span><br><span class="line">            tail-&gt;num = <span class="built_in">strtol</span>(s, &amp;s, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tokenize ERROR&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;nex = <span class="built_in">new_Token</span>(TK_EOL, s);</span><br><span class="line">    tail = tail-&gt;nex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="語法樹"><a href="#語法樹" class="headerlink" title="語法樹"></a>語法樹</h2><p>接著必須剖析一個「算式」的組成。<br>假設目前的算式已經處理好比$+$,$-$優先度高的運算，只剩下$+$,$-$，可以利用正規表達式定義:<br>expr = mul(+mul | -mul)*</p><p>而$\times$,$\div$的運算式，可以定義為:<br>mul = term(*term | \/term)*</p><p>最後()裡的算式定義為:<br>term = (num | (expr))</p><p>將上述的定義套用至語法樹的「生成」上(看code可能比較好理解)。</p><p>節點種類:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    NK_add, <span class="comment">// 加法</span></span><br><span class="line">    NK_sub, <span class="comment">// 減法</span></span><br><span class="line">    NK_mul, <span class="comment">// 乘法</span></span><br><span class="line">    NK_div, <span class="comment">// 除法</span></span><br><span class="line">    NK_num  <span class="comment">// 數字</span></span><br><span class="line">&#125;NodeKind;</span><br></pre></td></tr></table></figure></p><p>節點本體:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    NodeKind kind;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="type">int64_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>new Node，分成符號與數字類型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(NodeKind NKK, node* l, node* r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = (node *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(node));</span><br><span class="line">    p-&gt;kind = NKK;</span><br><span class="line">    p-&gt;l = l;</span><br><span class="line">    p-&gt;r = r;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字類型沒有左右子樹</span></span><br><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(NodeKind NKK, <span class="type">int64_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = (node*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(node));</span><br><span class="line">    p-&gt;kind = NKK;</span><br><span class="line">    p-&gt;val = n;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>expr()生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">expr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="built_in">mul</span>(); <span class="comment">// 遞迴判斷是否有乘除法運算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;+&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;+&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_add, Node, <span class="built_in">mul</span>()); <span class="comment">// 生成節點，將目前的node變為父節點，一路建構上去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;-&#x27;</span>)) <span class="comment">// // 判斷目前的token是否是&#x27;-&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_sub, Node, <span class="built_in">mul</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> Node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mul()生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">mul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="built_in">term</span>(); <span class="comment">// 遞迴判斷是否是另一個expr或num</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;*&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;*&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_mul, Node, <span class="built_in">term</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;/&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;/&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_div, Node, <span class="built_in">term</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>term生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">term</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        now_token = now_token-&gt;nex;</span><br><span class="line">        Node = <span class="built_in">expr</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">TK_isSign</span>(<span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;term ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        now_token = now_token-&gt;nex;</span><br><span class="line">        <span class="keyword">return</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node = <span class="built_in">new_node</span>(NK_num, <span class="built_in">TK_takeInt</span>()); <span class="comment">// 不是另一個expr，直接生成數字節點</span></span><br><span class="line">    now_token = now_token-&gt;nex;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>計算語法樹的最終答案，每個運算結果都會放在stack裡，回傳後再進行運算，最終答案就是stack的頂端數字:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int64_t</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(node* p)</span> <span class="comment">// 呼叫時，應代語法樹的根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kind == NK_num)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cal</span>(p-&gt;l); <span class="built_in">cal</span>(p-&gt;r); <span class="comment">// 計算左右子樹</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>(); <span class="comment">// 因為stack的性質，後面的運算元應該先pop出來</span></span><br><span class="line">    <span class="type">long</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;kind)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> NK_add:</span><br><span class="line">        st.<span class="built_in">push</span>(a + b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_sub:</span><br><span class="line">        st.<span class="built_in">push</span>(a - b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_mul:</span><br><span class="line">        st.<span class="built_in">push</span>(a * b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_div:</span><br><span class="line">        st.<span class="built_in">push</span>(a / b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(完整程式碼: <a href="https://github.com/OEmiliatanO/Project/tree/main/Syntax%20tree">https://github.com/OEmiliatanO/Project/tree/main/Syntax%20tree</a>)</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>語法樹比起中序轉後序還要複雜一點，但是寫起來很有規則；且如果要增加其他的運算子，例如開根號等，只需要多加幾行code就可以實現。<br>不只是四則運算，語法樹對於許多語法分析來說都很有用，例如編譯器。</p><p>我的這顆語法樹也是參考編譯器實作裡學來的。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://koshizuow.gitbook.io/compilerbook/">https://koshizuow.gitbook.io/compilerbook/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在玩編譯器的實作，裡面有提到語法樹，正好是我國中時看到但是無法實作的東西，就來填自己以前的坑囉。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;開頭</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>3.19 仲春夜</title>
    <link href="http://yoursite.com/2021/03/20/%E4%BB%B2%E6%98%A5%E5%A4%9C/"/>
    <id>http://yoursite.com/2021/03/20/%E4%BB%B2%E6%98%A5%E5%A4%9C/</id>
    <published>2021-03-20T08:43:34.000Z</published>
    <updated>2021-03-20T10:34:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>3月中旬已經可以感受的到夏天穿越時間的熱浪，隨之而來的還有如棘刺一般的學測分數篩選跟備審，揮之不去的縈繞在心頭。<br>觀仰以前的模範備審，我只能感受到無力感，我真的很獨特嗎? 盡力做出了努力，但總感覺有種東西哽在喉嚨，既無法呼吸也無法倒出自己的聲音。<br>在別人眼中閃亮的戰績，是否只是一種假象? 畢竟這些戰績似乎不過一般人做些努力就可以得到，自己卻是盡力至無力才可能沾得一點。<br>這些知識就算理解，也不過是走前人走過的路途，小時幻想著自己是獨一無二，實際上我早已走入兩條路之中，大多數人走的那條路。</p><p>或許我在高一時就該選擇生奧，興趣跟專長是兩種分開的性質，興趣會驅使我走下去，但不能使我越過「天分」，直到我被天分的門檻絆倒；狠狠重跌至地面時才察覺到這件事。<br>木已刻，而水已落，有關時間的選擇是依賴時間的變數，對於我只能讀而不能寫。</p><p>但這就是小時的我曾夢想的，現在的我也不過是依賴著自己曾有夢想走著罷了，如同大多數人般追逐夢想，追得到就成功，追不到就說一句:「追不到的才叫夢想」。<br>我無法這樣妥協，但也沒有辦法，只能死命掙扎著。<br>依照自己心的代價就是如此龐大，這就是電影跟現實的差別。</p><p>夜已深，而我卻被燥熱刺醒，只不知熱是來自夏天，亦或來自已醒的夢中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3月中旬已經可以感受的到夏天穿越時間的熱浪，隨之而來的還有如棘刺一般的學測分數篩選跟備審，揮之不去的縈繞在心頭。&lt;br&gt;觀仰以前的模範備審，我只能感受到無力感，我真的很獨特嗎? 盡力做出了努力，但總感覺有種東西哽在喉嚨，既無法呼吸也無法倒出自己的聲音。&lt;br&gt;在別人眼中閃亮</summary>
      
    
    
    
    <category term="隨筆" scheme="http://yoursite.com/categories/%E9%9A%A8%E7%AD%86/"/>
    
    
  </entry>
  
  <entry>
    <title>不同方式求sum, gcd</title>
    <link href="http://yoursite.com/2021/03/11/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%A9%A6%E9%A1%8C/"/>
    <id>http://yoursite.com/2021/03/11/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%A9%A6%E9%A1%8C/</id>
    <published>2021-03-11T13:19:20.000Z</published>
    <updated>2021-03-14T07:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這在我高二就有做過了，不過舊的那篇只有放code，沒講實作細節跟原因，在這裡補上。</p><hr><h1 id="問題-1"><a href="#問題-1" class="headerlink" title="問題 1"></a>問題 1</h1><p>請實作一函數，不得使用乘法、除法、for、while、goto、if-else、switch、case、條件運算子等，算出$\sum^n_{i = 1} i$。</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>如果不能使用迴圈，就只能往遞迴的方向思考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(n - <span class="number">1</span>) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>標準遞迴</p></blockquote><p>但是遞迴受限於條件判斷來中止，若是有辦法替換條件判斷的語句才可以實現。<br>這個解答大概要看過才知道。<br>陣列可以存指標，而C++存在函式指標，利用這個就可以判斷終止條件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義函式指標為&quot;Func&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int64_t</span><span class="params">(*Func)</span><span class="params">(<span class="type">int64_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">stop</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Func arr[<span class="number">2</span>] = &#123;stop, cal&#125;;</span><br><span class="line"><span class="keyword">return</span> x + arr[!!x](x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函式指標解</p></blockquote><hr><p>如果懂一點物件導向，應該知道”多型”的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// to be defined</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> : <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// cat eat</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> : <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// dog eat</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal house[] = &#123;dog, cat&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>標準多型概念</p></blockquote><p>同樣利用陣列也可以達成跟函式指標一樣的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;</span><br><span class="line"></span><br><span class="line">Base* arr[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">sum</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">sum</span><span class="params">(<span class="type">int64_t</span> x)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + arr[!!x](x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Base;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Cal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>]-&gt;<span class="built_in">sum</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多型解</p></blockquote><hr><h1 id="問題-2"><a href="#問題-2" class="headerlink" title="問題 2"></a>問題 2</h1><p>請實作一函數，不得使用乘法、除法、for、while、if-else、switch、case、條件運算子，算出$gcd(a, b)$。</p><hr><h1 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h1><p>同樣利用上面的模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義函式指標為&quot;Func&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int64_t</span><span class="params">(*Func)</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">stop</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Func arr[<span class="number">2</span>] = &#123;stop, cal&#125;;</span><br><span class="line"><span class="keyword">return</span> arr[!!(a % b)]-&gt;<span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函式指標解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;</span><br><span class="line"></span><br><span class="line">Base* arr[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[!!(a % b)]-&gt;<span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> A;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>]-&gt;<span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多型解</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這在我高二就有做過了，不過舊的那篇只有放code，沒講實作細節跟原因，在這裡補上。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;問題-1&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="code" scheme="http://yoursite.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>SG定理與SG函數推導</title>
    <link href="http://yoursite.com/2021/03/09/SG%E5%AE%9A%E7%90%86%E8%88%87SG%E5%87%BD%E6%95%B8%E6%8E%A8%E5%B0%8E/"/>
    <id>http://yoursite.com/2021/03/09/SG%E5%AE%9A%E7%90%86%E8%88%87SG%E5%87%BD%E6%95%B8%E6%8E%A8%E5%B0%8E/</id>
    <published>2021-03-08T16:53:01.000Z</published>
    <updated>2023-01-30T18:05:18.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在學校被問到賽局理論的東西，想起自己以前有學過sg函數這種東西，那時候覺得挺玄的，也沒認真推導跟思考，直接拿來用在題目上，感覺就像在玩「魔法」一樣。<br>現在有能力也有時間可以好好推導這個東西了。</p><hr><h1 id="一切起源自石頭"><a href="#一切起源自石頭" class="headerlink" title="一切起源自石頭"></a>一切起源自石頭</h1><p>某一天，有兩個極度聰明的小孩在玩遊戲，有$n$堆石頭，每堆有$a_n$顆石頭，每回合可以從任意一堆拿走$k$顆石頭，若無法再拿走石頭即輸，問在兩方採最優策略下是先手勝(N)或是先手敗(P)?</p><hr><h1 id="sg函數推導"><a href="#sg函數推導" class="headerlink" title="sg函數推導"></a>sg函數推導</h1><p>每次遇到這種問題時，都是同樣的模式，先討論$n=1, k=1$的情況:<br>根據剩餘的石頭數量，可以畫出有向圖，每點代表石頭剩餘數量:<br><img src="https://imgur.com/ojhNdHp.png" alt=""></p><blockquote><p>左下數字代表剩餘石頭數量</p></blockquote><p>可以知道當$a_1$是奇數時先手勝，反之。</p><p>而當$k=2$:<br><img src="https://imgur.com/XJquJbn.png" alt=""></p><p>由上圖可知兩個規則:</p><ol><li>只要可以轉移到的狀態中有P，此點為N</li><li>若只能轉移到N，此點為P</li></ol><p>由上面的規則就可以從終點回推到起點，就知道起點是先手敗或是先手勝。</p><p>現在或許可以思考$n&gt;1$的情形了，為了方便討論先固定$a_i = 1, i \in [1,n]$, $k=1$<br>$n=2$時，是先手敗(P)<br>$n=3$時，是先手勝(N)<br>$n=4$時，是先手敗(P)<br>…以此類推。</p><p>大膽做個猜想，若每堆的狀態N有奇數個，就是先手勝，若是偶數個，就是先手敗。<br>很可惜，這個想法在$a_i=1$時是對的；但是當$a_i$可以為2時可以找到反例:<br><img src="https://imgur.com/cq7jn33.png" alt=""></p><blockquote><p>上圖代表兩堆石頭($a_1 = 2, a_2 = 1$)各自的狀態圖</p></blockquote><p>仔細觀察剛剛$a_i=1$的圖與$a_i=2$的差別，可以感覺的出來，他們有某種層級結構，不如就將$a_i=1$的圖命為: <strong>一階</strong> (1!)，而$a_i=2$則命為: <strong>二階</strong> (2!)。<br>特別的，若是P點則稱: <strong>零階</strong> (0!)<br><img src="https://imgur.com/Nwa4QUy.png" alt=""></p><p>既然有一跟二了，那就會有三吧?<br>觀察二階圖形，他可以轉移到一階與零階，三階應當也有這種特性，可以轉移到零階，也可以轉移到一階、二階。<br><img src="https://imgur.com/JPeNHzr.png" alt=""><br>這種型態應該在$k=3$時才能出現，以此類推， <strong>$a$階只能在$k=a$時才會出現</strong> 。<br>並且可以得知「階」的另一個特性， <strong>$a$階可以轉移到$0$~$a-1$階</strong> ，其中0階可以升階，只是後手可以把他再降回原階，等同於局面沒有變動。<br>注意這裡可以將「階」定義到一個點上，可以自行思考為什麼。</p><p>而現在又出現一個問題了:<br>當$k = 2$，<br>若$a_i=3$，他的階數為多少? 將$a_i=3$畫出來，是P點，應為零階<br>而$a_i=4$，是N點，但是他轉移的狀態不像剛剛定義的「階」，這代表剛剛的定義需要擴展，不如先停下來；討論剛剛階的性質。<br><img src="https://imgur.com/PtEkcG3.png" alt=""></p><hr><p>先轉回來研究「階」組合起來的性質，若有兩堆石頭，為$a_1 = a, a_2 = b$，<br>$a = 0, b = 0$，是先手敗。(0! + 0! = P)<br>$a = 0, b = 1$，是先手勝。(0! + 1! = N)<br>$a = 0, b = 2$，是先手勝。(0! + 2! = N)<br>$a = 1, b = 1$，是先手敗。(1! + 1! = P)<br>$a = 1, b = 2$，是先手勝。(1! + 2! = N)<br>$a = 2, b = 2$，是先手敗。(2! + 2! = P)</p><p>觀察勝負的規律，當$a = b$是先手敗，其餘都是先手勝。</p><p>利用一點邏輯思考，當$a = b$，每當先手將其中一堆降階，後手總是可以將另一堆降為同一階，無論先手怎麼操作，狀態都會收斂到兩方皆為先手敗的狀態，導致先手敗。<br>而當$a \ne b, a &gt; b$，先手總是可以將第一堆石頭降階，與第二堆同階，造成與剛剛相同的情況，但是是後手敗。</p><p>於是就驗證出了這個規則: <strong>兩同階為P，兩異階為N</strong></p><p>回過頭來思考$n=1, a_i=4, k=2$究竟該怎麼定義到階上。<br>記得泰勒展開式嗎? 雖然完全無關，但是其中有個思想似乎可以套用在這邊，若$f(x)=g(x)$，則$f^{(n)}(x)=g^{(n)}(x)$，只要兩者特性完全相同，就可以判定兩者相同。</p><p>稱 $a_i=4$ 為 $x$ 階，將其與0階組合看看，是N；與1階，是P；與2階，是N。<br>寫成數學式子:<br>$x! + 0! = N$<br>$x! + 1! = P$<br>$x! + 2! = N$<br>他與1階的特性完全相同，所以可以說它是1階。</p><p>這時「階」的定義已經被擴展了，我們可以用組合已知階，來判斷其為哪一階。</p><p>不過這樣的數學定義不太簡潔，似乎可以簡化? 再深入研究看看$a_i=4$；上面的數學式子其實可以展開:<br>$x! + 0! = N$<br>|-&gt;  $0! + 0! = P$(雖然看起來是先手敗，但其實是上一局的後手敗)<br>|-&gt;  $2! + 0! = N$</p><p>$x! + 1! = P$<br>|-&gt;  $0! + 1! = N$(雖然看起來是先手勝，但其實是上一局的後手勝)<br>|-&gt;  $2! + 1! = N$</p><p>$x! + 2! = N$<br>|-&gt;  $0! + 2! = N$<br>|-&gt;  $2! + 2! = P$(雖然看起來是先手勝，但其實是上一局的後手勝)</p><p>發現一個規則，只要展開後是全N，即為先手敗，同時此點也是這階，或許還沒有足夠的證據看出來規律，我們來討論$k=3$的$a_i=5$<br><img src="https://imgur.com/ibeKI5R.png" alt=""></p><p>$x! + 0! = N$<br>|-&gt;  $0! + 0! = P$<br>|-&gt;  $2! + 0! = N$<br>|-&gt;  $3! + 0! = N$</p><p>$x! + 1! = P$<br>|-&gt;  $0! + 1! = N$<br>|-&gt;  $2! + 1! = N$<br>|-&gt;  $3! + 1! = N$<br>…(下略)</p><p>若$x$與組合的階$y$為同階，結果為P，而結果為P就代表，$x$可以轉移的所有狀態必跟$y$不同階。<br>而因為可以轉移的狀態[0, 1, 2, 3]只會有一個缺失，可以確定這個缺失必與$y$同階，故寫出以下式子:<br>$sg(status) = mex(sg(nextStatus)|status \to nextStatus)$<br>其中$mex$為最小的未出現的非負整數。</p><p>這下我們有一個好用的數學式子，來幫助我們表達一個狀態的「階」。</p><p>此時可以輕易判斷當$n=1$、任意$a_1,k$是先手勝或是先手敗。<br>但$n&gt;1$的情況又要如何判斷?</p><hr><h1 id="Nim-sum"><a href="#Nim-sum" class="headerlink" title="Nim-sum"></a>Nim-sum</h1><p>剛剛的問題是，石頭可以從任意一堆拿$k$顆，現在改成可以從任意一堆拿任意顆，情況似乎變複雜了，但是實際上變簡單了。<br>設每堆石頭為$a_i$顆，而每堆其實就代表一局遊戲。<br>現在有$n$局: $a_1,a_2,a_3…,a_n$，而$a_i \oplus a_j$代表將第$i$局遊戲與第$j$局組合起來一起玩。<br>同時$a_i$也可以說是一種狀態，$\oplus$即是將兩種狀態組合成一種狀態。</p><p>直覺告訴我們，只要在每一局遊戲中都採取最佳策略，那就會贏下整場遊戲，因此$\oplus$滿足交換律，亦即先玩完第一場或先玩完第二場都沒差。<br>接著我們也知道$(a_i \oplus a_j) \oplus a_k = a_i \oplus (a_j \oplus a_k)$，因為把兩局遊戲組合後，就算是一局大遊戲，先玩完也不影響整體勝負。<br>以及其他直覺的結論 $a_i \oplus 0 = a_i$、若$a_i = a_j$, $a_i \oplus a_j = P = 0$</p><p>利用剛剛推導出來的sg函數，我們可以知道某個狀態的階，進而判斷是先手勝或是先手敗。<br>特別的，$n=1$時，$sg(a) = a$。</p><p>根據sg函數的定義寫出$sg(a_1 \oplus a_2 … \oplus a_n) = mex(sg(a_1 \oplus … \oplus a_i’ … \oplus a_n) | a_i \to a_i’)$，這樣子可以反推回去，決定是究竟是先手勝或是先手敗。<br>然而每局的狀態難以這樣一一列舉，為了簡化情況，我們先討論$n = 2$:<br>$sg(0 \oplus 0) = P = 0$<br>$sg(0 \oplus a) = sg(a) = a$<br>$sg(a \oplus b) = P = 0$, 如果$a = b$<br>$sg(a \oplus b) = N$, 如果$a \ne b$</p><p>看著這個運算規則，越看越像xor，做個猜想: 在$n$為任意正整數下，$\oplus$與xor是等價的。<br>為此我們必須證明兩者等價:</p><p>當$a_i = 0, i \in [1, n]$，是終盤，兩者定義符合。</p><p>當$a_1$ $xor$ $a_2$ $xor$ … $a_n=0$，無法將其中一個數字改變，且維持$xor$和為0；換句話說，當$xor$和為0，下一步只會讓$xor$和為非0。<br>這其實就是最上面提到的第二點規則: <strong>若只能轉移到N，此點為P</strong> 。<br>證明這點很簡單，若將其中一數改成$a_i’$，而$xor$和變為$X$，<br>則$a_1$ $xor$ … $a_i’$… $a_n$ $=X=0$ $xor$ $a_i$ $xor$ $a_i’$，但是$a_i’&lt;a_i$，故$X = 0$ $xor$ $a_i’$ $xor$ $a_i \ne 0$<br>得證。</p><p>當$a_1$ $xor$ $a_2$ $xor$ … $a_n = X \ne 0$，可以將其中一數改變，並使$xor$和為0。<br>這也對應到最上面第一點規則: <strong>只要可以轉移到的狀態中有P，此點為N</strong> 。<br>若將$a_i$改成$a_i$ $xor$ $X$，則$xor$和為0。此時$a_i$ $xor$ $X$就是$a_i’$。<br>但是還必須證明$a_i’ &lt; a_i$，假設$X$在二進位下最高位1是第$k$位，則必有某$a_i$滿足二進位下第$k$位為1，顯然，$a_i$ $xor$ $X$第$k$位為0，得證$a_i’ &lt; a_i$。</p><p>現在我們可以非常迅速的計算一整個大遊戲的狀態了，因為$\oplus$與xor是等價，所以只要將$sg(a_1 \oplus a_2 … a_n)$裡面的值全部做xor運算即可。</p><p>必勝策略也顯而易見，先手只需要每次都使下一個狀態為0，即可獲勝。</p><hr><h1 id="回到最初的問題"><a href="#回到最初的問題" class="headerlink" title="回到最初的問題"></a>回到最初的問題</h1><p>回到一開始的問題，看似可以依剛才的結論，全部xor後判斷，但是實際上因為「無法任意改變數字」而存在錯誤，上面的證明有一步是將$a_i$變為$a_i$ $xor$ $X$，這代表$a_i$可能變成$0$ ~ $a_i-1$中任意一數，但是因為這個問題有拿走數的限制$k$，所以無法對所有狀態成立。<br>而一開始推導出來的「階」正好滿足此性質。($n$階可以轉移至$0$ ~ $n-1$階)<br>只要將一開始的每個狀態取sg()，就可以得知階數，最後再將全部xor起來，非0即為先手勝，0則為先手敗。</p><p>可能你會注意到0階接下來的轉移似乎有點問題，但是因為可以由後手轉移回0階，最終都會收斂至先手敗，所以對整體局面還是一樣。</p><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>只要先依$k$構建一DAG，從終盤逆推回去找到sg值，再將所有局面的sg值xor起來，就可以判斷問題解答。<br>寫成數學式子: $sg(sg(a_1) \oplus sg(a_2) … \oplus sg(a_n)) = sg(a_1) \oplus sg(a_2) … \oplus sg(a_n)$。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次研究的題目真硬，雖然學過了但是還是試著從零開始推導，結果真的推導出同樣的結論，這種過程真的挺好玩的，就像是在創造新的結構一樣，可以發現許多以前不曾想過的東西。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在學校被問到賽局理論的東西，想起自己以前有學過sg函數這種東西，那時候覺得挺玄的，也沒認真推導跟思考，直接拿來用在題目上，感覺就像在玩「魔法</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>最佳化-梯度下降法(簡單版)</title>
    <link href="http://yoursite.com/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
    <id>http://yoursite.com/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</id>
    <published>2021-03-01T06:34:01.000Z</published>
    <updated>2021-03-05T17:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寫完了<a href="https://oemiliatano.github.io/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/">牛頓法</a> ，來寫梯度下降法。<br>擬牛頓法有點深奧，應該暫時不會寫。</p><hr><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><p>想法類似於牛頓法，但是少了Hessian矩陣的計算:</p><p>迭代公式:<br>$x_{k+1}=x_k - \alpha \nabla f(x_k)$<br>同樣，這邊$x$是一堆變量$a, b, c …$。</p><p>$\nabla f(x_k)$為梯度，可以利用對各變數偏微分得到，例如:<br>$\nabla f(x, y) = \frac{\partial f}{\partial x}(x, y)i + \frac{\partial f}{\partial y}(x, y)j$</p><p>而$\alpha$則是一個調整係數，一般都是在區間(0, 1]裡，具體什麼用途，必須配合等下的例子才能說明。</p><hr><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span> / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-6</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-6</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0, y0 + h) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grad</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array([dfdx(x, y), dfdy(x, y)])</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">10</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">5</span>, <span class="number">10</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整係數</span></span><br><span class="line">a = <span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始點</span></span><br><span class="line">preP = np.array([<span class="number">8.3</span>, <span class="number">7.6</span>])</span><br><span class="line">nowP = preP - grad(preP[<span class="number">0</span>], preP[<span class="number">1</span>]) * a</span><br><span class="line">plt.plot((preP[<span class="number">0</span>], nowP[<span class="number">0</span>]), (preP[<span class="number">1</span>], nowP[<span class="number">1</span>]), <span class="string">&#x27;bo-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">preP = nowP</span><br><span class="line">    nowP = preP - grad(preP[<span class="number">0</span>], preP[<span class="number">1</span>]) * a</span><br><span class="line">    plt.plot((preP[<span class="number">0</span>], nowP[<span class="number">0</span>]), (preP[<span class="number">1</span>], nowP[<span class="number">1</span>]), <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(nowP)</span><br><span class="line"><span class="built_in">print</span>(f(nowP[<span class="number">0</span>], nowP[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p><img src="https://imgur.com/O1w0iLp.gif" alt=""></p><blockquote><p>$\sqrt{x^2 + \frac{y^2}{3}}$, 起始值=(8.3, 7.6), $\alpha = 1$, 迭代次數 16<br>收斂值 $(x,y) = (-0.00243513, -0.10515567), f(x, y) = 0.06076047183997639$</p></blockquote><p><img src="https://imgur.com/3XIyWRX.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(0.3, 0.6), $\alpha = 0.7$, 迭代次數 4<br>收斂值 $(x,y) = (-0.7073123, 0.11798947), f(x, y) = -0.42295258860276885$</p></blockquote><p><img src="https://imgur.com/r7VMoej.png" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(-4, 0), $\alpha = 0.1$, 迭代次數 1<br>收斂值 <strong>無法收斂</strong><br>註解: 無法收斂的原因在下面會講</p></blockquote><p><img src="https://imgur.com/743JHoP.gif" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(-4, 0), $\alpha = 0.001$, 迭代次數 100<br>收斂值 $(x,y) = (0.65374851, 3.42158651), f(x, y) = -0.9962581603349078$</p></blockquote><p><img src="https://imgur.com/5q34ALw.gif" alt=""></p><blockquote><p>$(2x + 5)^2(213y - 0.65)^2 - 5$, 起始值=(0, 0), $\alpha = 0.1$, 迭代次數 4<br>收斂值 <strong>無法收斂</strong></p></blockquote><hr><h1 id="觀察結論"><a href="#觀察結論" class="headerlink" title="觀察結論"></a>觀察結論</h1><p>以上面的結果與其餘未放上來的資料來說，這個版本的梯度下降法不那麼實用。<br>當我們的函數值在 <strong>某點梯度極大</strong> ，我們的迭代點將會因為這個梯度”衝過頭”，更糟糕的是，衝過頭後的點梯度可能會更大(類似遊樂園的海盜船，但是停不下來)，導致 <strong>無法收斂</strong> 的情況，上面雖然只放了兩個例子，但是非常容易構造此種函數。</p><p>因為這樣子，所以才需要引入 <strong>調整係數</strong> ，但是又出現了另一個缺點，收斂太慢。<br>調整係數低確實可以提高收斂的機率，但是以此為代價，迭代次數亦會跟著成長。<br><img src="https://imgur.com/w4M2p3m.gif" alt=""></p><blockquote><p>衝過頭以致無法收斂的例子</p></blockquote><p><img src="https://imgur.com/JtNIGIb.gif" alt=""></p><blockquote><p>將調整係數調低後收斂</p></blockquote><p>當然這些問題其實可以透過一系列手段解決，而這些手段留在以後再說。</p><hr><h1 id="梯度下降法與牛頓法比較"><a href="#梯度下降法與牛頓法比較" class="headerlink" title="梯度下降法與牛頓法比較"></a>梯度下降法與牛頓法比較</h1><p>!藍色為牛頓法<br>!紅色為梯度下降法</p><p><img src="https://imgur.com/75zlqjD.gif" alt=""></p><blockquote><p>$(2x + 5)^2(213y - 0.65)^2 - 5$, 起始值=(0, 0), 迭代次數 6</p></blockquote><p><img src="https://imgur.com/WIR1zVT.gif" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(0, 0), 迭代次數 30<br>註解: 牛頓法在第5次就收斂了</p></blockquote><p><img src="https://imgur.com/ad9d7iA.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(0.3, 0.6), 迭代次數 10</p></blockquote><p><img src="https://imgur.com/2zusW8m.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(1, 0.2), 迭代次數 10</p></blockquote><p><img src="https://imgur.com/W0lxt00.gif" alt=""></p><blockquote><p>$\sqrt{x^2 + \frac{y^2}{3}}$, 起始值=(8.3, 7.6), 迭代次數 10</p></blockquote><p>可以知道牛頓法的收斂速度比梯度下降要快上許多，可以形象化理解為，梯度下降就是找周圍最陡峭、與等高線垂直的方向走，而牛頓法不只考慮最陡峭，同時考慮是否會變平緩或陡峭。</p><p>感覺梯度下降法如果調整係數低一點，穩定度會比牛頓法好上許多。但是收斂步驟增多又變成一大問題。<br>牛頓法收斂快，但是不穩定，尤其是Hessian逆矩陣對於運算效率是一種負擔。<br>兩者各有其問題、優點，或許可以在 <strong>擬牛頓法</strong> 、 <strong>變形梯度下降</strong> 找到更好的最佳化方法?</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization">https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization</a><br><a href="https://en.wikipedia.org/wiki/Gradient">https://en.wikipedia.org/wiki/Gradient</a><br><a href="https://en.wikipedia.org/wiki/Hessian_matrix">https://en.wikipedia.org/wiki/Hessian_matrix</a><br><a href="https://zhuanlan.zhihu.com/p/46536960">https://zhuanlan.zhihu.com/p/46536960</a><br><a href="https://zhuanlan.zhihu.com/p/37524275">https://zhuanlan.zhihu.com/p/37524275</a><br><a href="https://www.zhihu.com/question/19723347">https://www.zhihu.com/question/19723347</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;寫完了&lt;a href=&quot;https://oemiliatano.github.io/2021/03/01/%E6%9C%80%E4%BD%B</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>最佳化-牛頓法</title>
    <link href="http://yoursite.com/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/"/>
    <id>http://yoursite.com/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/</id>
    <published>2021-03-01T06:33:42.000Z</published>
    <updated>2021-03-05T17:29:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前幾天在翻舊書，看到國中以前做過的求根\極值方法: 牛頓法，以前都是做單變量函數的，現在發現其實有多變量的。研究後發現蠻有趣的，就寫了這篇。</p><hr><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><p>多變量牛頓法主要求函數極值，原理跟單變量差不多，只是換成更高維度的東西。</p><p>單變量的迭代公式: $x_{k+1}=x_k - \frac{f’(x)}{f’’(x)}$</p><p>多變量的迭代公式: $x_{k+1}=x_k - \nabla f(x_k)\mathbf H^{-1} f(x_k)$<br>這邊$x$是一堆變量$a, b, c …$。<br>$\nabla f(x_k)$是$f(x)$在$x_k$的梯度，$\mathbf H^{-1} f(x_k)$是$f(x)$在$x_k$的Hessian逆矩陣。<br>這兩個對應到單變量一階導跟二階導倒數。</p><p>梯度可以用不同的方向向量去定義，但是這裡將梯度定義為分別將$x$, $y$固定後的導數組成的向量，也就是偏導數組成的向量，例如:<br>$\nabla f(x, y) = \frac{\partial f}{\partial x}(x, y)i + \frac{\partial f}{\partial y}(x, y)j$</p><p>Hessian逆矩陣是從Hessian矩陣求逆得到的，Hessian矩陣是多變數函數的所有二階偏導數組成的方塊矩陣，例如:<br>$\mathbf H f(x, y) = \begin{bmatrix} \frac{\partial^2 f}{\partial x^2} &amp; \frac{\partial^2 f}{\partial x \partial y} \\\ \frac{\partial^2 f}{\partial y \partial x} &amp; \frac{\partial^2 f}{\partial y^2} \end{bmatrix}$</p><hr><h2 id="實作想法"><a href="#實作想法" class="headerlink" title="實作想法"></a>實作想法</h2><p>考慮到視覺化的需求，用python來寫最合適。</p><p>因為只討論雙變量函數，所以Hessian矩陣只需要$2\times2$的就好，可以手動設。</p><p>而numpy提供的np.linalg.solve()也恰好可以求Hessian逆矩陣與梯度矩陣的乘積。</p><p>接著是計算偏導數，<br>如果你有看過我寫的<a href="https://oemiliatano.github.io/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/">曲線插值-樣條函數</a> 這篇，或許會發現我的微分是用原始定義去做的 $lim_{h \to 0} \frac{1}{h}[f(x + h) - f(x)]$ ，將$h$設成一個很小的數字，就可以逼近我們要的微分數值。<br>同樣的道理，偏微分也可以照著做:</p><p>$f_x(x, y) = \frac{\partial f}{\partial x}(x, y) = lim_{h \to 0} \frac{1}{h}[f(x + h, y) - f(x, y)]$</p><p>換成程式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br></pre></td></tr></table></figure></p><p>二階偏導同樣:</p><p>$\frac{\partial}{\partial x}(\frac{\partial f}{\partial x}(x, y)) = \frac{\partial}{\partial x}f_x(x, y)$</p><p>$=lim_{g \to 0} \frac{1}{g}[f_x(x + h, y) - f_x(x, y)]$<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0 + g, y0) - dfdx(x0, y0)) / g</span><br></pre></td></tr></table></figure></p><p>其餘偏導類似。</p><hr><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: x * np.exp(-x * x - y * y)</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏導數</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0, y0 + h) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0 + g, y0) - dfdx(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0, y0 + g) - dfdx(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdydy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdy(x0, y0 + g) - dfdy(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hessian矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = [[dfdxdx(x0, y0), dfdxdy(x0, y0)], [dfdxdy(x0, y0), dfdydy(x0, y0)]]</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grd</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    <span class="keyword">return</span> [dfdx(x0, y0), dfdy(x0, y0)]</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等高線圖</span></span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求Hessian逆矩陣與梯度矩陣的乘積</span></span><br><span class="line">k = -np.linalg.solve(H(x0, y0), grd(x0, y0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先迭代一次</span></span><br><span class="line">x1 = x0 + k[<span class="number">0</span>]</span><br><span class="line">y1 = y0 + k[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 畫線</span></span><br><span class="line">plt.plot((x0, x1), (y0, y1), <span class="string">&#x27;bo-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    x0 = x1</span><br><span class="line">    y0 = y1</span><br><span class="line">    k = -np.linalg.solve(H(x0, y0), grd(x0, y0))</span><br><span class="line">    x1 = x0 + L * k[<span class="number">0</span>]</span><br><span class="line">    y1 = y0 + L * k[<span class="number">1</span>]</span><br><span class="line">    plt.plot((x0, x1), (y0, y1), <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最終值</span></span><br><span class="line"><span class="built_in">print</span>(x0, y0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;extreme:&quot;</span>, f(x0, y0))</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p><img src="https://imgur.com/jx0qYxp.gif" alt=""></p><blockquote><p>$(ln(|x - 1|))(5y - 1) - 1$, 起始值=(1.1, 9), 迭代次數 6<br>收斂值 $(x,y) = (1.9999999999995695, 0.20000000000075954), f(x, y) = -1.0$</p></blockquote><hr><p><img src="https://imgur.com/d3Fg3lo.gif" alt=""></p><blockquote><p>$cos(\sqrt{x^2 + y^2})$, 起始值=(0.5, 1), 迭代次數 6<br>收斂值 $(x,y) = (-4.999999323762127e-06, -5.000008901435384e-06), f(x, y) = 0.999999999975$</p></blockquote><hr><p><img src="https://imgur.com/71BP3S6.gif" alt=""></p><blockquote><p>$xe^{-x^2-y^2}$, 起始值=(1, 0.2), 迭代次數 7<br>收斂值 $(x,y) = (0.7071017811951483, -4.999999497366208e-06), f(x, y) = 0.4288819424481872$</p></blockquote><hr><p><img src="https://imgur.com/7GgWBQH.gif" alt=""></p><blockquote><p>$xe^{-x^2-y^2}$, 起始值=(1, 0.3), 迭代次數 21<br>收斂值 <strong>無法收斂</strong></p></blockquote><hr><p><img src="https://imgur.com/B6U7DqW.gif" alt=""></p><blockquote><p>$sin(x) \times y^{\frac{2}{3}}$, 起始值=(-2, 0.9), 迭代次數 15<br>收斂值 $(x,y) = (-7.683814908002442e-05, -0.0020110391746036667), f(x, y) = -1.2242137360945188e-06$</p></blockquote><hr><p><img src="https://imgur.com/Fc5308N.gif" alt=""></p><blockquote><p>$sin(x) \times y^{\frac{2}{3}}$, 起始值=(-1, 2), 迭代次數 21<br>收斂值 $(x,y) = (-20.42035724833452 -4848738.969554567), f(x, y) = -28647.443380356$<br>註解: 收斂到奇怪的地方了…</p></blockquote><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>看的出來，多變量牛頓法其實就跟單變量牛頓法有著一樣的缺點: <strong>不穩定</strong>、<strong>起始點敏感</strong><br>更糟糕的情況，Hessian矩陣可能沒有逆，例如:$f(x, y) = ln(x^2 + y^2)$。</p><p>但同時優點也很明顯: <strong>收斂速度快</strong> (上面的迭代次數有調高，以求比較精準的收斂值)，比較簡單的函數甚至可以兩步到位。</p><p>個人覺得實際應用不可能直接用純的牛頓法，弊大於利，畢竟起始點必須選的很好才有可能收斂，應該搭配其他演算法抓起始點的大略位置，再給牛頓法去迭代。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次的東西用到好多沒看過的數學方法，不過還好不太深，還可以理解，但是僅僅能寫出陽春版的牛頓法，貌似還可以通過Hessian矩陣是否正定來判斷狀態?<br>待研究…</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization">https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization</a><br><a href="https://en.wikipedia.org/wiki/Gradient">https://en.wikipedia.org/wiki/Gradient</a><br><a href="https://en.wikipedia.org/wiki/Hessian_matrix">https://en.wikipedia.org/wiki/Hessian_matrix</a><br><a href="https://zhuanlan.zhihu.com/p/46536960">https://zhuanlan.zhihu.com/p/46536960</a><br><a href="https://zhuanlan.zhihu.com/p/37524275">https://zhuanlan.zhihu.com/p/37524275</a><br><a href="https://www.zhihu.com/question/19723347">https://www.zhihu.com/question/19723347</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前幾天在翻舊書，看到國中以前做過的求根\極值方法: 牛頓法，以前都是做單變量函數的，現在發現其實有多變量的。研究後發現蠻有趣的，就寫了這篇。</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="algorithm" scheme="http://yoursite.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>python 可視化函數 2</title>
    <link href="http://yoursite.com/2021/02/27/python-%E5%8F%AF%E8%A6%96%E5%8C%96%E5%87%BD%E6%95%B8-2/"/>
    <id>http://yoursite.com/2021/02/27/python-%E5%8F%AF%E8%A6%96%E5%8C%96%E5%87%BD%E6%95%B8-2/</id>
    <published>2021-02-26T18:24:21.000Z</published>
    <updated>2021-02-27T07:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>延續<a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">上一篇</a><br>昨天在研究牛頓法、擬牛頓法、梯度下降法，在學著將它們的迭代過程畫出來的過程學到了可視化函數的新東西，留點紀錄。</p><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><h2 id="等高線圖"><a href="#等高線圖" class="headerlink" title="等高線圖"></a>等高線圖</h2><hr><p>需要用到contour這個函數，先來最簡單的</p><p>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/g1ndgh4.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目標函數</span></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: np.sin(x) * np.power(y ** <span class="number">2</span>, <span class="number">1.</span>/<span class="number">3.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生數據點</span></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x, y 標籤</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等高線圖</span></span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line"><span class="comment"># 寫出等高線的高度</span></span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="輪廓等高圖"><a href="#輪廓等高圖" class="headerlink" title="輪廓等高圖"></a>輪廓等高圖</h3><p>需要用到contourf。</p><p>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/tcksYG5.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有這裡不一樣</span></span><br><span class="line">C = plt.contourf(X, Y, Z)</span><br></pre></td></tr></table></figure></p><p>如果需要的函數不支援np.array這種操作(例如:math的函數)，就需要自己一個一個展開X, Y<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = X * <span class="number">0</span> <span class="comment"># 一定要*0，強迫複製出一個新的array</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> xx , yy <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):</span><br><span class="line">        Z[i][j] = f(xx, yy)</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.contour(X, Y, Z)</span><br></pre></td></tr></table></figure></p><hr><h3 id="三維平面等高線"><a href="#三維平面等高線" class="headerlink" title="三維平面等高線"></a>三維平面等高線</h3><p>結合上一次的3D函數，這次我們要在它下面畫出投影的等高線</p><p>$sin(\sqrt{x^2+y^2})$:<br><img src="https://imgur.com/3judVES.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y : np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line">ax.view_init(<span class="number">45</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line"></span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot_surface(X, Y, Z, rstride = <span class="number">1</span>, cstride = <span class="number">1</span>, cmap = <span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 與上篇相比多加了這行</span></span><br><span class="line"><span class="comment"># offset代表將圖投影到z軸某個座標，這裡選最小值，也就是地板</span></span><br><span class="line">ax.contour(X, Y, Z, offset = Z.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure></p><p>甚至可以畫出各面的投影<br><img src="https://imgur.com/YBTnBrG.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zdir代表投影到哪個座標</span></span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;z&#x27;</span>, offset = Z.<span class="built_in">min</span>())</span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;x&#x27;</span>, offset = X.<span class="built_in">min</span>())</span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;y&#x27;</span>, offset = Y.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure></p><hr><p>$f(x, y) = cos(\sqrt{x^2 + y^2})$:<br><img src="https://imgur.com/WVvfsPA.png" alt=""></p><p>$f(x, y) = e^{-x^2-y^2}$<br><img src="https://imgur.com/wnoK6gK.png" alt=""></p><p>$f(x, y) = ln(x^2 + y^2)$<br><img src="https://imgur.com/jMIqq2L.png" alt=""></p><p>$f(x, y) = xe^{-x^2-y^2}$<br><img src="https://imgur.com/jbEBAtM.png" alt=""></p><p>$f(x, y) = sin(x) * y^{\frac{2}{3}}$<br><img src="https://imgur.com/k2zeTES.png" alt=""></p><hr><h2 id="向量場圖"><a href="#向量場圖" class="headerlink" title="向量場圖"></a>向量場圖</h2><p>最簡單的，每個點$(x,y)$都有向量$\vec{v}(x, y)$<br><img src="https://imgur.com/mBFfaeI.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">u, v = X, Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 畫出向量，第一對(X, Y)代表位置(x, y), 第二對(u, v)代表指向</span></span><br><span class="line">plt.quiver(X, Y, u, v)</span><br></pre></td></tr></table></figure></p><p>而應用在函數上，可以利用梯度函數numpy.gradient來設定向量方向，這樣就知道函數的大致走向。<br>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/utYmC78.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x, y: np.sin(x) * np.power(y ** <span class="number">2</span>, <span class="number">1.</span>/<span class="number">3.</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度函數</span></span><br><span class="line"><span class="comment"># 不知道為甚麼向量方向要倒過來才能正確，可能跟gradient函數有關</span></span><br><span class="line">v, u = np.gradient(Z)</span><br><span class="line"></span><br><span class="line">plt.quiver(X, Y, u, v)</span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><hr><p>$f(x, y) = xe^{-x^2-y^2}$:<br><img src="https://imgur.com/qEQ8Lwl.png" alt=""></p><p>$f(x, y) = ln(x^2 + y^2)$<br><img src="https://imgur.com/2GmsvMu.png" alt=""></p><p>$f(x, y) = cos(\sqrt{x^2 + y^2})$:<br><img src="https://imgur.com/8yhOEGd.png" alt=""></p><hr><h3 id="三維向量場"><a href="#三維向量場" class="headerlink" title="三維向量場"></a>三維向量場</h3><p><img src="https://imgur.com/qlyxmAt.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line">ax.view_init(<span class="number">45</span>, <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">Z = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X, Y, Z = np.meshgrid(X, Y, Z)</span><br><span class="line"></span><br><span class="line">u = np.sin(X) * np.cos(Y) </span><br><span class="line">v = -np.cos(X) * np.cos(Z)</span><br><span class="line">w = np.cos(Y) * np.sin(Z)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.quiver(X, Y, Z, u, v, w, length = <span class="number">.1</span>, normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>目前都是看什麼、需要什麼，然後才學什麼。總感覺很不扎實，希望上了大學可以有一系列連貫的學習路程。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.contour.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.contour.html</a><br><a href="https://blog.csdn.net/lens___/article/details/83960810">https://blog.csdn.net/lens___/article/details/83960810</a><br><a href="https://www.itread01.com/content/1550129762.html">https://www.itread01.com/content/1550129762.html</a><br><a href="https://matplotlib.org/stable/gallery/mplot3d/contour3d_3.html">https://matplotlib.org/stable/gallery/mplot3d/contour3d_3.html</a><br><a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">https://oemiliatano.github.io/2020/04/22/3D-functions/</a><br><a href="https://www.mathworks.com/help/matlab/ref/gradient.html">https://www.mathworks.com/help/matlab/ref/gradient.html</a><br><a href="https://www.pluvet.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8-python-%E4%B8%AD%E7%BB%98%E5%88%B6%E5%90%91%E9%87%8F%E5%9C%BA%EF%BC%88%E4%BD%BF%E7%94%A8-matplotlib%EF%BC%89/">https://www.pluvet.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8-python-%E4%B8%AD%E7%BB%98%E5%88%B6%E5%90%91%E9%87%8F%E5%9C%BA%EF%BC%88%E4%BD%BF%E7%94%A8-matplotlib%EF%BC%89/</a><br><a href="https://www.cnpython.com/qa/112014">https://www.cnpython.com/qa/112014</a><br><a href="https://sq.163yun.com/blog/article/236582359586304000">https://sq.163yun.com/blog/article/236582359586304000</a><br><a href="https://blog.csdn.net/qq_41856733/article/details/102677984">https://blog.csdn.net/qq_41856733/article/details/102677984</a><br><a href="https://numpy.org/doc/stable/reference/generated/numpy.gradient.html">https://numpy.org/doc/stable/reference/generated/numpy.gradient.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;延續&lt;a href=&quot;https://oemiliatano.github.io/2020/04/22/3D-functions/&quot;&gt;上一篇</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="code" scheme="http://yoursite.com/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>零零碎碎的發現</title>
    <link href="http://yoursite.com/2021/02/20/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%99%BC%E7%8F%BE/"/>
    <id>http://yoursite.com/2021/02/20/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%99%BC%E7%8F%BE/</id>
    <published>2021-02-20T15:37:51.000Z</published>
    <updated>2021-02-27T08:04:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊會把很多個零碎的知識點集中，整體沒什麼連貫性，只是很有趣而已。</p><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><h2 id="指對數-三角函數擴展到複數域"><a href="#指對數-三角函數擴展到複數域" class="headerlink" title="指對數, 三角函數擴展到複數域"></a>指對數, 三角函數擴展到複數域</h2><h3 id="對數"><a href="#對數" class="headerlink" title="對數:"></a>對數:</h3><p>根據歐拉公式$e^{i\theta} = (cos\theta + isin\theta)$，所有複數都可以用$re^{i\theta}$表達。<br>這就讓對數可以突破正實數的限制(0還是不行)，例如:</p><ul><li>$ln(-1) = ln(e^{i\pi}) = i\pi$</li><li>$ln(i) = ln(e^{i\frac{\pi}{2}}) = i\frac{\pi}{2}$</li></ul><h3 id="指數"><a href="#指數" class="headerlink" title="指數:"></a>指數:</h3><p>同樣的，根據歐拉公式，複數代入指數也能計算，$x^{ai+b} = e^{(ln x)(ai + b)}$。<br>以前一些看似無解的方程式也有解了，例如:</p><ul><li>$1^x = 2$, $x = \frac{ln(2)}{2n\pi i}$</li></ul><h3 id="三角函數"><a href="#三角函數" class="headerlink" title="三角函數:"></a>三角函數:</h3><p>這次需要用到泰勒展開，眾所周知，</p><ul><li>$e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!}…$</li><li>$sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!}…$</li></ul><p>將$e^x$改成$e^{ix}$及$e^{-ix}$，</p><ul><li>$e^{ix} = 1 + \frac{ix}{1!} - \frac{x^2}{2!} - \frac{ix^3}{3!}…$</li><li>$e^{-ix} = 1 - \frac{ix}{1!} - \frac{x^2}{2!} + \frac{ix^3}{3!}…$</li></ul><p>$e^{ix} - e^{-ix}$後會發現只要多除$2i$即是$sin x$<br>亦即，</p><ul><li>$sin x = \frac{e^{ix} - e^{-ix}}{2i}$</li></ul><p>$cos x$也可以用同樣的方法寫出來</p><ul><li>$cos x = \frac{e^{ix} + e^{-ix}}{2}$。</li></ul><p>當然也可以用歐拉公式推得，<br>$e^{ix} = (cos x + isin x)$</p><p>$e^{i(-x)} = (cos x - isin x)$</p><p>$e^{ix} - e^{i(-x)} = 2i sin x$</p><p>$\frac{e^{ix} - e^{i(-x)}}{2i} = sin x$</p><h2 id="實數階導數-積分"><a href="#實數階導數-積分" class="headerlink" title="實數階導數, 積分"></a>實數階導數, 積分</h2><p>沒看錯，繼階乘後，導數也可以有$\frac{1}{2}$階，或是$\pi$階，連積分都可以。<br>設一函數$f(x) = x^n$，則</p><ul><li>$k(k&lt;n)$階導數為$f^{(k)}(x) = \frac{n!}{(n-k)!}x^{(n-k)}$</li></ul><p>還記得階乘其實可以解析出去嗎?<br>將上式改寫成</p><ul><li>$f^{(k)}(x) = \frac{\Gamma(n+1)}{\Gamma(n-k+1)}x^{(n-k)}$<br>這下子就可以寫出$\frac{1}{2}$階導數了。</li></ul><p>例子:</p><ul><li>$f(x) = x$, $\frac{1}{2}$階導數是$\frac{\Gamma(2)}{\Gamma(\frac{3}{2})}x^{\frac{1}{2}} = \frac{2}{\sqrt{\pi}}x^{\frac{1}{2}}$</li></ul><p>當然，複數階導數也可以。</p><hr><p>積分的話，需要用到引理，在此不證明:</p><ul><li>$\int^t_a \int^y_a f(x, y)dx dy = \int^t_a \int^t_x f(x, y)dy dx$</li></ul><p>假設$I_2 = \int^{\alpha_3}_0 \int^{\alpha_2}_0 f(\alpha_1) d\alpha_1 d\alpha_2$<br><img src="https://imgur.com/YOa7ume.png" alt=""><br>(這邊的mathjax壞了只好用圖片代替)</p><p>繼續寫出$I_3$, $I_4$…<br>$I_3 = \int^{\alpha_4}_0 I_2 = \frac{1}{2} \int^{\alpha_4}_0 f(\alpha_1)(\alpha_4 - \alpha_1)^2 d\alpha_1$<br>$I_4 = \int^{\alpha_5}_0 I_3 = \frac{1}{6} \int^{\alpha_5}_0 f(\alpha_1)(\alpha_5 - \alpha_1)^3 d\alpha_1$</p><p>可以發現一規律，且可以用數學歸納法證明無誤</p><ul><li>$I_n = \frac{1}{(n-1)!} \int^{\alpha}_0 f(x) (\alpha-x)^{n-1} dx$</li></ul><p>又看到階乘了，直接換成$\Gamma$函數</p><ul><li>$I_n = \frac{1}{\Gamma(n)} \int^{\alpha}_0 f(x) (\alpha-x)^{n-1} dx$</li></ul><p>這下子我們就可以代實數進去了(複數也可以)。</p><h2 id="多變數泰勒展開式"><a href="#多變數泰勒展開式" class="headerlink" title="多變數泰勒展開式"></a>多變數泰勒展開式</h2><p>某一天在別人的blog看到這個詞，但是沒有點進去，而是開始自己試圖將單變數泰勒展開推導至多變數，所以不確定推導的正確性。</p><p>我自己對泰勒展開的推導是如此(簡化一點，一律只討論$x=0$附近):<br>假設某函數$f(x)$可以寫成多項式$a_0 + a_1x + a_2x^2 + a_3x^3 … a_nx^n = g(x)$，</p><p>我們也很直覺的知道當兩函數相等，$f^{(n)}(x) = g^{(n)}(x), n \in \mathbb{N}$</p><p>利用這點可以知道$a_0 = f(0)$, $a_1 = f’(0)$, $a_2 = \frac{f’’(0)}{2!}$, …, $a_n = \frac{f^{(n)}(0)}{n!}$</p><p>故$f(x) = f(0) + f’(0)x + \frac{f’’(0)}{2!}x^2 + … \frac{f^{(n)}(0)}{n!}x^n$</p><hr><p>現在推廣至多變數，理應也是利用類似$f^{(n)}(x) = g^{(n)}(x), n \in \mathbb{N}$的方法去定義。</p><p>假設某函數$f(x, y)$可以寫成多項式$c + a_1x + b_1y + a_2x^2 + b_2y^2 + a_3x^3 +b_3y^3 … a_nx^n b_ny^n = g(x, y)$，</p><p>可以知道$\frac{\partial f}{\partial x}(x, y) = \frac{\partial g}{\partial x}(x, y)$, $\frac{\partial f}{\partial y}(x, y) = \frac{\partial g}{\partial y}(x, y)$</p><p>$\frac{\partial^2 f}{\partial x^2}(x, y) = \frac{\partial^2 g}{\partial x^2}(x, y)$, $\frac{\partial^2 f}{\partial y^2}(x, y) = \frac{\partial^2 g}{\partial y^2}(x, y)$</p><p>接著就可以用剛剛的方法求各項係數，但是當我想展開$f(x,y) = xy$時，卻無法正確展開，所以我認為還需要多加上各變數的乘積，</p><p>$f(x, y) = d + a_1x + b_1y + c_{1,1}xy + a_2x^2 + b_2y^2 + c_{1, 2}xy^2 + c_{2, 1}x^2y + c_{2, 2}x^2y^2 …$</p><p>利用偏微分可以知道<br>$d = f(0, 0)$, $a_1 = \frac{\partial f}{\partial x}(0, 0)$, $b_1 = \frac{\partial f}{\partial y}(0, 0)$, $c_{1, 1} = \frac{\partial^2 f}{\partial x \partial y}(0, 0)$</p><p>$a_2 = \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}(x, y)$, $b_2 = \frac{1}{2!}\frac{\partial^2 f}{\partial y^2}(x, y)$</p><p>得$f(x, y) = f(0, 0) + \frac{\partial f}{\partial x}(0, 0)x + \frac{\partial f}{\partial y}(0, 0)y + \frac{\partial^2 f}{\partial x \partial y}(0, 0)xy + \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}(x, y)x^2 + \frac{1}{2!}\frac{\partial^2 f}{\partial y^2}(x, y)y^2 …$</p><p>更多變數時也是一樣，但是我不知道要怎麼更簡潔的寫出來 (Q _ Q)</p><ul><li>2.27.21 更新<br>後來有想到可以用$\sum_{n=0}^{\infty} \sum_{a_1 + a_2 + … + a_k = n} \frac{1}{a_1! a_2! … a_k!} \frac{\partial^n f}{\partial x_{1}^{a_1} \partial x_{2}^{a_2} … \partial x_{k}^{a^k}}(0, …, 0)x_{1}^{a_1}x_{2}^{a_2}…x_{k}^{a^k}$</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://en.wikipedia.org/wiki/Fractional_calculus">https://en.wikipedia.org/wiki/Fractional_calculus</a><br><a href="https://zhuanlan.zhihu.com/p/124627581">https://zhuanlan.zhihu.com/p/124627581</a><br><a href="https://en.wikipedia.org/wiki/Taylor%27s_theorem">https://en.wikipedia.org/wiki/Taylor%27s_theorem</a><br><a href="https://mathinsight.org/taylors_theorem_multivariable_introduction">https://mathinsight.org/taylors_theorem_multivariable_introduction</a><br><a href="https://sites.math.washington.edu/~folland/Math425/taylor2.pdf">https://sites.math.washington.edu/~folland/Math425/taylor2.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;這邊會把很多個零碎的知識點集中，整體沒什麼連貫性，只是很有趣而已。&lt;/p&gt;
&lt;h1 id=&quot;主體&quot;&gt;&lt;a href=&quot;#主體&quot; class=</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>曲線插值-三次樣條函數</title>
    <link href="http://yoursite.com/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/"/>
    <id>http://yoursite.com/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/</id>
    <published>2021-02-14T16:18:22.000Z</published>
    <updated>2023-01-14T11:16:51.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>學測前被人推坑過曲線插值，現在就來寫寫看。<br>被推坑的是<a href="http://mirlab.org/jang/books/matlabprogramming4guru/10-1_regressionLin4curveFitting.asp?title=10-1%20%BDu%A9%CA%B0j%C2k%A1G%A6%B1%BDu%C0%C0%A6X">多項式插值</a><br>但是這篇不是多項式，而是樣條函數。</p><hr><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>跟多項式插值不一樣的點有</p><ul><li><p>用低次的樣條函數比較不會產生高次多項式函數的”亂流”，且效果不錯<br><img src="https://imgur.com/KIkT758.png" alt=""></p><blockquote><p>預測全球人口的多項式擬合，次數到8時會產生反常結果(source: <a href="http://mirlab.org/jang/books/matlabprogramming4guru/10-1_regressionLin4curveFitting.asp?title=10-1%20%BDu%A9%CA%B0j%C2k%A1G%A6%B1%BDu%C0%C0%A6X">10-1 線性迴歸：曲線擬合</a>)</p></blockquote></li><li><p>並非一個函數用到底，而是利用取樣點之間作分割，分成小區間，利用某些特性做連結，以達到光滑的目的<br><img src="https://imgur.com/n1fSqrR.png" alt=""></p><blockquote><p>上面是每個子區間都是次數=1的樣子，當然可以使用次數更高的函數</p></blockquote></li></ul><p>高中都學過「插值法」，用來算不在log表上的數字或是求多項式，而樣條插值是利用分段的函數，構成一個大函數，預測內插值。</p><p><img src="https://4.bp.blogspot.com/-Tw4BlGwhpQg/VSK_3PKjU8I/AAAAAAAAoEk/54rgZCaoxTk/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-04-07%2B%E4%B8%8A%E5%8D%8812.49.48.png" alt=""></p><blockquote><p>線性樣條插值，最簡單的插值法，高中常用(source: <a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">三次樣條插值</a>)</p></blockquote><p>線性插值雖然簡單，但無法滿足工程上「光滑」的需求，於是三次樣條就誕生了，最高次數為三能確保不過度扭曲，又可以確保光滑。</p><hr><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>假設有一複雜函數$f(x)$(難以評估)，需要用簡單函數$s(x)$去逼近，我們現在有$n+1$個取樣點$x_0, x_1$…$x_n$，由此分割出$n$個子區間，<br>$x_0$, $x_1$中間的樣條函數為$s_1(x)$，$x_{i-1}$, $x_i$中間的樣條函數為$s_i(x)$，$i \in [1,n]$<br>那該如何求出$s_i(x) = q_i x^3 + r_i x^2 + s_i x + t_i$ ?<br>我們有以下條件:</p><ul><li>$s_i(x_i) = s_{i+1}(x_i)$</li><li>$s_i’(x_i) = s_{i+1}’(x_i)$</li><li>$s_i’’(x_i) = s_{i+1}’’(x_i)$<br>因為m=3，可知所有$s_i’’(x)$為同一直線，可寫出直線</li></ul><blockquote><p>$\frac{y-s_i’’(x_i)}{x-x_i}=\frac{s_i’’(x_{i-1})-s_i’’(x_i)}{x_{i-1}-x_i}$</p></blockquote><p>整理一下</p><blockquote><p>$s_i’’(x)=y=(s_i’’(x_{i-1})-s_i’’(x_i))\frac{x-x_i}{x_{i-1}-x_i}+s_i’’(x_i)$</p></blockquote><p>積分，這邊將$s_i’’(x_i)$寫成$m_i$($m_i$是對應到$x_i$的$i$，因為所有的$s_i’’(x)$都是同一條直線，如果是對應到$s_i$，$m_i$就不會有變化)</p><blockquote><p>$s_i’’(x) = (m_{i-1}-m_i)\frac{x-x_i}{x_{i-1}-x_i}+m_i$<br>$s_i’’(x) = \frac{x-x_i}{x_{i-1}-x_i}m_{i-1} + \frac{x_{i-1}-x}{x_{i-1}-x_i}m_i$<br>$s_i’(x) = \frac{(x-x_i)^2}{2(x_{i-1}-x_i)}m_{i-1}-\frac{(x_{i-1}-x)^2}{2(x_{i-1}-x_i)}m_i+C_1$<br>$s_i(x) = \frac{(x-x_i)^3}{6(x_{i-1}-x_i)}m_{i-1}+\frac{(x_{i-1}-x)^3}{6(x_{i-1}-x_i)}m_i+C_1x+C_2$</p></blockquote><p>現在要求$C_1$, $C_2$，將$s_i(x_i)$寫成$y_i$(同樣，是對應$x_i$)，過程略…</p><blockquote><p>$C_1 = \frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{x_i-x_{i-1}}{6}(m_i - m_{i-1})$<br>$C_2 = y_i-\frac{y_i-y_{i-1}}{x_i-x_{i-1}}x_i-\frac{x_{i-1}-x_i}{6}(m_ix_{i-1}-m_{i-1}x_i)$</p></blockquote><p>利用算好的$C_1$, $C_2$將$s_i(x)$寫完整</p><blockquote><p>$s_i(x)=\frac{(x-x_i)^3}{6(x_{i-1}-x_i)}m_{i-1}+\frac{(x_{i-1}-x)^3}{6(x_{i-1}-x_i)}m_i+ [\frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{x_i-x_{i-1}}{6}(m_i - m_{i-1})]x$<br>$+y_i-\frac{y_i-y_{i-1}}{x_i-x_{i-1}}x_i-\frac{x_{i-1}-x_i}{6}(m_ix_{i-1}-m_{i-1}x_i)$</p></blockquote><p>現在只有$m_i$需要求解，這時需要用$s_i’(x_i) = s_{i+1}’(x_i)$，注意這時是要先把$s_i(x)$跟$s_{i+1}(x)$寫出來再代$x_i$，不然容易搞混。<br>整理等式極為繁瑣，在此直接給出最後整理好的結果</p><blockquote><p>$\frac{6}{x_{i-1}-x_{i+1}}(\frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{y_{i+1}-y_i}{x_{i+1}-x_i}) = \frac{x_{i-1}-x_i}{x_{i-1}-x_{i+1}}m_{i-1} + 2m_i + \frac{x_i-x_{i+1}}{x_{i-1}-x{i+1}}m_{i+1}$</p></blockquote><p>代換一下，等下比較好寫</p><blockquote><p>$k_i = a_im_{i-1} + 2m_i + c_im_{i+1}$, $i \in [1, n-1]$ —(1)</p></blockquote><p>我們有$m_i$, $i \in [0,n]$共$n+1$個未知數要求解，但是上面只有$n-1$個方程式，剩下兩個需要從邊界條件中得到<br>邊界條件分三種:</p><ul><li>$s_1’(x_0)=f’(x_0)$, $s_n’(x_n)=f’(x_n)$</li><li>$s_1’’(x_0)=f’’(x_0)$, $s_n’’(x_n)=f’’(x_n)$</li><li>$s_1’(x_0)=s_n(x_n)$, $s_1’’(x_0)=s_n’’(x_n)$</li></ul><h2 id="邊界條件"><a href="#邊界條件" class="headerlink" title="邊界條件"></a>邊界條件</h2><p>邊界條件有許多種，每種都會對樣條函式產生不盡相同的影響。<br><img src="https://1.bp.blogspot.com/-OzV3YgFSP2Q/VSLTPL_3uKI/AAAAAAAAoFg/kyL15pyxTXY/s1600/26193013-20d427db372c4913b3337945008177a7.png" alt=""></p><blockquote><p>source: <a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">三次樣條插值</a></p></blockquote><ul><li>第一種:<br>先將$s_1’(x_0)$, $s_n’(x_n)$寫出來</li></ul><blockquote><p>$y_0’=f’(x_0)=s_1’(x_0)=\frac{x_0-x_1}{2}m_0-\frac{y_1-y_0}{x_1-x_0}-\frac{1}{6}(x_1-x_0)(m_1-m_0)$<br>$y_n’=f’(x_n)=s_n’(x_n)=-\frac{x_{n-1}-x_n}{2}m_n+\frac{y_n-y_{n-1}}{x_n-x_{n-1}}-\frac{1}{6}(x_n-x_{n-1})(m_n-m_{n-1})$</p><p>$y_0’+\frac{y_1-y_0}{x_1-x_0}=\frac{x_0-x_1}{2}m_0-\frac{1}{6}(x_1-x_0)(m_1-m_0)$<br>$y_n’-\frac{y_n-y_{n-1}}{x_n-x_{n-1}}=-\frac{x_{n-1}-x_n}{2}m_n-\frac{1}{6}(x_n-x_{n-1})(m_n-m_{n-1})$</p><p>$k_0=\frac{6}{x_0-x_1}(y_0’+\frac{y_1-y_0}{x_1-x_0})=2m_0+m_1$<br>$k_n=\frac{6}{x_{n-1}-x_n}(\frac{y_n-y_{n-1}}{x_n-x_{n-1}}-y_n’)=m_{n-1}+2m_n$</p></blockquote><p>利用那$n-1$個條件與算好的邊界條件寫出矩陣<br>$\begin{bmatrix} 2 &amp; 1 \\\ a_1 &amp; 2 &amp; c_1 &amp; \\\ &amp; a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; &amp; &amp; … \\\ &amp;  &amp;  &amp;  &amp;  &amp; 1 &amp; 2\end{bmatrix}\vec{m}=\vec{k}$<br>解矩陣的步驟就等下再寫。</p><ul><li>第二種:</li></ul><blockquote><p>$s_1’’(x_0)=f’’(x_0)=m_0$<br>$s_n’’(x_n)=f’’(x_n)=m_n$</p></blockquote><p>由上面的等式知</p><blockquote><p>$k_1-a_1m_0=+2m_1+c_1m_2$<br>$k_{n-1}-c_{n-1}m_n=a_{n-1}m_{n-2}+2m_{n-1}$</p></blockquote><p>寫出矩陣<br>$\begin{bmatrix} 2 &amp; c_1 \\\ a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; a_3 &amp; 2 &amp; c_3 &amp; \\\ &amp; &amp; &amp; … \\\ &amp;  &amp;  &amp;  &amp;  &amp; a_{n-1} &amp; 2\end{bmatrix}\vec{m}= \begin{bmatrix}k_1-a_1f’’(x_0) \\\ k2 \\\ … \\\ k_{n-1}-c_{n-1}f’’(x_n) \end{bmatrix}$<br>注意這裡的$\vec{m}$是$m_1$到$m_{n-1}$。</p><ul><li>第三種:</li></ul><blockquote><p>$s_1’(x_0)=s_n’(x_n)$<br>$s_1’’(x_0)=s_n’’(x_n)$</p></blockquote><p>由第二個等式可知</p><blockquote><p>$m_0 = m_n$</p></blockquote><p>現在我們只有$n$個未知數需要求解<br>由第一個等式，知</p><blockquote><p>$2(x_0-x_1+x_{n-1}-x_n)m_0+(x_0-x_1)m_1+(x_{n-1}-x_n)m_{n-1}=6(\frac{y_1-y_0}{x_1-x_0}+\frac{y_n-y_{n-1}}{x_n-x_{n-1}})$</p></blockquote><p>代換</p><blockquote><p>$a_0m_0+b_0m_1+c_0m_{n-1}=k_0$</p></blockquote><p>再由(1)得</p><blockquote><p>$k_{n-1}=a_{n-1}m_{n-2}+2m_{n-1}+c_{n-1}m_n$</p></blockquote><p>寫出矩陣<br>$\begin{bmatrix} a_0 &amp; b_0 &amp; &amp; … &amp; &amp; &amp; c_0 \\\ a_1 &amp; 2 &amp; c_1 &amp; \\\  &amp; a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; &amp; &amp; … \\\ c_{n-1} &amp;  &amp;  &amp; …  &amp;  &amp; a_{n-1} &amp; 2\end{bmatrix}\vec{m}=\vec{k}$<br>$\vec{m}$是從$0~n-1$，$\vec{k}$同理。</p><hr><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><p>算出來的矩陣為$A$，寫出等式$A\vec{m}=\vec{k}$<br>將$A$拆解成$LU$矩陣，<br>$L = \begin{bmatrix} d_0 &amp; &amp; &amp; &amp; &amp; \\\ l_1 &amp; d_1 &amp; &amp; \\\  &amp; l_2 &amp; d_2 &amp; &amp; \\\ &amp; &amp; &amp; … \\\ &amp; &amp; &amp; &amp; l_n &amp; d_n\end{bmatrix}$<br>$U = \begin{bmatrix} 1 &amp; u_0 &amp; &amp; &amp;  \\\ &amp; 1 &amp; u_1 &amp; \\\ &amp; &amp; 1 &amp; u_2 &amp; \\\ &amp; &amp; &amp; … &amp; &amp; \\\ &amp; &amp; &amp; &amp; &amp; u_{n-1} \\\ &amp; &amp; &amp; &amp; &amp; 1 \end{bmatrix}$</p><p>根據使用的邊界條件不同而有所不同，而第一,二種步驟是相同的<br>先推出$d,l,u$的遞推關係，解出$\vec{w}$ ($U\vec{m}$)<br>在利用$U\vec{m}=\vec{w}$解出$\vec{m}$</p><ul><li>第一種:</li></ul><p>由$A=LU$可以觀察到</p><blockquote><p>$d_0=2,u_0=\frac{1}{2}$<br>$l_i=a_i$<br>$d_i=2-u_{i-1}l_i$<br>$u_i=\frac{c_i}{d_i}$</p></blockquote><p>由$L\vec{w}=\vec{k}$知</p><blockquote><p>$w_0=\frac{k_0}{d_0}$<br>$w_i=\frac{k_i-l_iw_{i-1}}{d_i}$</p></blockquote><p>再由$U\vec{m}=\vec{w}$得</p><blockquote><p>$m_n=w_n$<br>$m_i=w_i-u_im_{i+1}$</p></blockquote><ul><li>第二種:</li></ul><p>由$A=LU$可以觀察到</p><blockquote><p>$d_1=2$<br>$l_i=a_i$<br>$d_i=2-l_iu_{i-1}$<br>$u_i=\frac{c_i}{d_i}$</p></blockquote><p>由$L\vec{w}=\vec{k}$知</p><blockquote><p>$w_1=\frac{k_1}{d_1}$<br>$w_i=\frac{k_i-l_iw_{i-1}}{d_i}$</p></blockquote><p>再由$U\vec{m}=\vec{w}$得</p><blockquote><p>$m_n=w_n$<br>$m_i=w_i-u_im_{i+1}$</p></blockquote><ul><li>第三種:</li></ul><p>這個無法用上面的方法拆，只能用高斯$O(n^3)$求逆矩陣</p><p>現在有了具體的步驟就可以寫出程式了。<br>解第一二種矩陣的方法有個具體的名字: 追趕法，不多介紹，畢竟不是主角。</p><hr><h1 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h1><p>(目前只有第一,二種邊界條件)</p><ul><li><p>目標函數:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">df</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">10e-8</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(<span class="built_in">f</span>(x + dx)) || <span class="built_in">isinf</span>(<span class="built_in">f</span>(x + dx)))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">f</span>(x) - <span class="built_in">f</span>(x - dx)) / dx;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">f</span>(x + dx) - <span class="built_in">f</span>(x)) / dx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ddf</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">10e-8</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(<span class="built_in">df</span>(x + dx)) || <span class="built_in">isinf</span>(<span class="built_in">df</span>(x + dx)))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">df</span>(x) - <span class="built_in">df</span>(x - dx)) / dx;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">df</span>(x + dx) - <span class="built_in">df</span>(x)) / dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>採樣點, 邊界類型設定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> datSeed = <span class="number">1</span>, datStep = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dataCnt = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> st = datSeed, ed = datSeed + ((<span class="type">double</span>)dataCnt - <span class="number">1.0</span>) * datStep, step = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSample</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; v, vector&lt;<span class="type">double</span>&gt;&amp; u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>(); u.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x = datSeed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataCnt; x += datStep, ++i)</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(x), u.<span class="built_in">emplace_back</span>(<span class="built_in">f</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩陣A, 向量k的設定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType1_SetMat</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">6</span> * (SampleY[<span class="number">1</span>] - SampleY[<span class="number">0</span>] - <span class="built_in">df</span>(SampleX[<span class="number">0</span>])) / (g[<span class="number">1</span>] * g[<span class="number">1</span>]);</span><br><span class="line">    k[SampleN] = <span class="number">6</span> * ((SampleY[SampleN - <span class="number">1</span>] - SampleY[SampleN]) / g[SampleN] - <span class="built_in">df</span>(SampleX[SampleN])) / g[SampleN];</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SampleN + <span class="number">1</span>; ++i)</span><br><span class="line">        A[i].<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][i - <span class="number">1</span>] = g[i] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">        A[i][i] = <span class="number">2</span>;</span><br><span class="line">        A[i][i + <span class="number">1</span>] = g[i + <span class="number">1</span>] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>, A[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, A[SampleN][SampleN] = <span class="number">2</span>, A[SampleN][SampleN - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType2_SetMat</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[<span class="number">1</span>] -= (SampleX[<span class="number">0</span>] - SampleX[<span class="number">1</span>]) * <span class="built_in">ddf</span>(SampleX[<span class="number">0</span>]) / (SampleX[<span class="number">0</span>] - SampleX[<span class="number">2</span>]);</span><br><span class="line">    k[SampleN - <span class="number">1</span>] -= (SampleX[SampleN - <span class="number">1</span>] - SampleX[SampleN]) * <span class="built_in">ddf</span>(SampleX[SampleN]) / (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN]);</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SampleN + <span class="number">1</span>; ++i)</span><br><span class="line">        A[i].<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; SampleN - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][i - <span class="number">1</span>] = g[i] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">        A[i][i] = <span class="number">2</span>;</span><br><span class="line">        A[i][i + <span class="number">1</span>] = g[i + <span class="number">1</span>] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, A[<span class="number">1</span>][<span class="number">2</span>] = (SampleX[<span class="number">1</span>] - SampleX[<span class="number">2</span>]) / (SampleX[<span class="number">0</span>] - SampleX[<span class="number">2</span>]);</span><br><span class="line">    A[SampleN - <span class="number">1</span>][SampleN - <span class="number">1</span>] = <span class="number">2</span>, A[SampleN - <span class="number">1</span>][SampleN - <span class="number">2</span>] = (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN - <span class="number">1</span>]) / (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解矩陣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType1</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; m, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; l, d, u, w;</span><br><span class="line">    l.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); d.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); u.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>), w.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">0</span>], u[<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">1</span>] / d[<span class="number">0</span>], w[<span class="number">0</span>] = k[<span class="number">0</span>] / d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = A[i][i - <span class="number">1</span>];</span><br><span class="line">        d[i] = A[i][i] - l[i] * u[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; SampleN)</span><br><span class="line">            u[i] = A[i][i + <span class="number">1</span>] / d[i];</span><br><span class="line">        w[i] = (k[i] - l[i] * w[i - <span class="number">1</span>]) / d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[SampleN] = w[SampleN];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = SampleN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i] = w[i] - m[i + <span class="number">1</span>] * u[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType2</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; m, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; l, d, u, w;</span><br><span class="line">    l.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); d.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); u.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>), w.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">2</span>, u[<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">2</span>] / d[<span class="number">1</span>], w[<span class="number">1</span>] = k[<span class="number">1</span>] / d[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = A[i][i - <span class="number">1</span>];</span><br><span class="line">        d[i] = <span class="number">2</span> - l[i] * u[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; SampleN - <span class="number">1</span>)</span><br><span class="line">            u[i] = A[i][i + <span class="number">1</span>] / d[i];</span><br><span class="line">        w[i] = (k[i] - l[i] * w[i - <span class="number">1</span>]) / d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[SampleN - <span class="number">1</span>] = w[SampleN - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = SampleN - <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i] = w[i] - m[i + <span class="number">1</span>] * u[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="built_in">ddf</span>(SampleX[<span class="number">0</span>]);</span><br><span class="line">    m[SampleN] = <span class="built_in">ddf</span>(SampleX[SampleN]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>樣條函數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">s</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &lt; SampleX[<span class="number">0</span>]) || (x &gt; *SampleX.<span class="built_in">rbegin</span>()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; SampleX[i]) ++i;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    res = (x - SampleX[i]) * (x - SampleX[i]) * (x - SampleX[i]) * m[i - <span class="number">1</span>] + (SampleX[i - <span class="number">1</span>] - x) * (SampleX[i - <span class="number">1</span>] - x) * (SampleX[i - <span class="number">1</span>] - x) * m[i];</span><br><span class="line">    res /= (<span class="number">6</span> * g[i]);</span><br><span class="line">    res += ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + g[i] * (m[i] - m[i - <span class="number">1</span>]) / <span class="number">6</span>) * x;</span><br><span class="line">    res += SampleY[i] - (g[i] * g[i] * m[i]) / <span class="number">6</span> - ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + (m[i] - m[i - <span class="number">1</span>]) * g[i] / <span class="number">6</span>) * SampleX[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setSample</span>(SampleX, SampleY);</span><br><span class="line"></span><br><span class="line">    SampleN = SampleX.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= SampleN; ++i)</span><br><span class="line">        g[i] = SampleX[i - <span class="number">1</span>] - SampleX[i];</span><br><span class="line"></span><br><span class="line">    k.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; SampleN; ++i)</span><br><span class="line">        k[i] = ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + (SampleY[i + <span class="number">1</span>] - SampleY[i]) / g[i + <span class="number">1</span>]) * <span class="number">6</span> / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bondType1_SetMat</span>(A, k);</span><br><span class="line">        <span class="built_in">bondType1</span>(A, m, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Type == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bondType2_SetMat</span>(A, k);</span><br><span class="line">        <span class="built_in">bondType2</span>(A, m, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fstream fs;</span><br><span class="line">    fs.<span class="built_in">open</span>(<span class="string">&quot;function.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> x = st; x &lt;= ed; x += step)</span><br><span class="line">    &#123;</span><br><span class="line">        fs &lt;&lt; <span class="built_in">f</span>(x) &lt;&lt; endl;</span><br><span class="line">        fs &lt;&lt; <span class="built_in">s</span>(x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ed &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函式可視化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;function.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">10.9</span>, <span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> x:</span><br><span class="line">    s = f.readline()</span><br><span class="line">    a.append(<span class="built_in">float</span>(s.strip()))</span><br><span class="line">    s = f.readline()</span><br><span class="line">    b.append(<span class="built_in">float</span>(s.strip()))</span><br><span class="line"></span><br><span class="line">y1 = np.array(a) <span class="comment"># real blue</span></span><br><span class="line"><span class="comment">#print(y1)</span></span><br><span class="line">y2 = np.array(b) <span class="comment"># predict orange</span></span><br><span class="line"><span class="comment">#print(y2)</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2)</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="source-code"><a href="#source-code" class="headerlink" title="source code"></a>source code</h1><p><a href="https://github.com/OEmiliatanO/cubic_spline_interpolation">https://github.com/OEmiliatanO/cubic_spline_interpolation</a></p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>花了兩天的時間終於結束整個推導過程跟code debug，原本以為會很簡單，沒想到過程的推導繁瑣至極…這大概是有史以來寫過最長的一篇文了。</p><p>樣條函數的擬合效果挺不錯的，只要約6, 7個採樣點就可以很好的擬合出原本的函數，只是在某些一些點無法微分的函數擬合效果不是很好，只能增加採樣點。<br>(紅色是目標函數, 綠色是第一種邊界條件, 藍色是第二種)</p><p><img src="https://imgur.com/hytXkXP.png" alt=""></p><blockquote><p>$e^x$, <code>datSeed = 1, datStep = 1, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/WlSwGnm.png" alt=""></p><blockquote><p>$\frac{3}{x^2}$, <code>datSeed = 1, datStep = 1, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/UoE0L3D.png" alt=""></p><blockquote><p>$\frac{3}{x^2}$, <code>datSeed = 1, datStep = 0.1, dataCnt = 50</code></p></blockquote><p><img src="https://imgur.com/fPh6bwY.png" alt=""></p><blockquote><p>$sin(cos(x))$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/Ky3TnK4.png" alt=""></p><blockquote><p>$sin(\sqrt{x})$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/F9CBySG.png" alt=""></p><blockquote><p>$|x - 1.5| \times e^{sin(|-0.1x|)}$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/80opHHs.png" alt=""></p><blockquote><p>$\frac{1}{1 + 25x^2}$, <code>datSeed = -1, datStep = 0.4, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/LZp794H.png" alt=""></p><blockquote><p>$\frac{1}{1 + 25x^2}$, <code>datSeed = -1, datStep = 0.1, dataCnt = 21</code></p></blockquote><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/62860859">https://zhuanlan.zhihu.com/p/62860859</a><br><a href="https://zh.wikipedia.org/zh-tw/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/zh-tw/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0</a><br><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC">https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1">https://zh.wikipedia.org/wiki/%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1</a><br><a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html</a><br><a href="http://math.ecnu.edu.cn/~jypan/Teaching/NA/ch02e.pdf">http://math.ecnu.edu.cn/~jypan/Teaching/NA/ch02e.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;學測前被人推坑過曲線插值，現在就來寫寫看。&lt;br&gt;被推坑的是&lt;a href=&quot;http://mirlab.org/jang/books/ma</summary>
      
    
    
    
    <category term="Project" scheme="http://yoursite.com/categories/Project/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>階乘推導至Gamma函數</title>
    <link href="http://yoursite.com/2020/12/31/%E8%A7%A3%E6%9E%90%E7%A0%94%E6%8B%93-%E9%9A%8E%E4%B9%98/"/>
    <id>http://yoursite.com/2020/12/31/%E8%A7%A3%E6%9E%90%E7%A0%94%E6%8B%93-%E9%9A%8E%E4%B9%98/</id>
    <published>2020-12-31T03:59:59.000Z</published>
    <updated>2021-03-22T13:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在2020的最後一天完成這件事，剩下的留待明年吧…</p><p>在知道有解析研拓這種東西後，我試著把一些高中的函數展開，比如log, sin, cos, exponential，但是階乘這個常見的東西卻困擾著我，到底要怎麼展開。</p><hr><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>首先考慮這個函數: $f(k,m)=\int_0^1 x^k (1-x)^m dx$，為甚麼需要這個函數呢? 當我們對它分部積分後會得到</p><blockquote><p>$f(k,m) = \frac{m}{k+1}f(k+1,m-1)$</p></blockquote><p>這樣一個遞迴式。<br>把它展開後會得到$f(k,m)=\frac{m!}{\prod_{i=1}^{m+1}(k+i)}$，移項得到$f(k,m)\prod_{i=1}^{m+1}(k+i)=m!$<br>這算是階乘展開的第一步，雖然這個形式還只能代正整數。<br>我們繼續把它展開，無法代除了正整數以外是因為這部分$\prod_{i=1}^{m+1}(k+i)$，如果可以把它消掉或許可以成功拓展。<br>令$k=\frac{a}{b}$，整理上面的公式得，</p><blockquote><p>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \frac{m!}{\prod_{i=1}^{m+1}(\frac{a}{b}+i)}$<br>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \frac{m!b^{m+1}}{\prod_{i=1}^{m+1}(a+ib)}$</p></blockquote><p>如果取極限$a \to 1$, $b \to 0$，右邊式子的分數就會消掉，但是上面的$b^{m+1}$很礙事，既然解決不了問題，就解決造成問題的東西，<br>先把$b^{m+1}$弄去左邊，再取極限</p><blockquote><p>$\lim_{a \to 1} lim_{b \to 0} b^{-(m+1)}\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = m!$</p></blockquote><p>現在我們focus在積分上，我們期望把積分裡面的$x^{\frac{a}{b}}$去掉，令$x=k^c$, $dx = ck^{c-1}dk$</p><blockquote><p>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \int_0^1 k^{\frac{ac}{b}} (1-k^c)^m ck^{c-1} dk$</p></blockquote><p>要把$x^{\frac{a}{b}}$(也就是$k^{\frac{ac}{b}}$)，必須使$\frac{ac}{b}+c-1=0$，解出$c=\frac{b}{a+b}$。<br>將上面的極限式換掉</p><blockquote><p>$\lim_{a \to 1} lim_{b \to 0} b^{-(m+1)}\int_0^1 \frac{b}{a+b}{(1-k^{\frac{b}{a+b}})}^m dk = m!$<br>$\lim_{a \to 1} lim_{b \to 0} (a+b)^{-(m+1)}\int_0^1 ({\frac{1-k^{\frac{b}{a+b}}}{\frac{b}{a+b}}})^m dk = m!$<br>$lim_{b \to 0} (1+b)^{-(m+1)}\int_0^1 ({\frac{1-k^{\frac{b}{1+b}}}{\frac{b}{1+b}}})^m dk = m!$<br>$\int_0^1 lim_{b \to 0} ({\frac{1-k^{\frac{b}{1+b}}}{\frac{b}{1+b}}})^m dk = m!$</p></blockquote><p>考慮一極限$lim_{x \to 0} \frac{1-k^x}{x}$，根據那個好用到不行的法則，得到$lim_{x \to 0} \frac{1-k^x}{x} = -ln k$。</p><blockquote><p>$\int_0^1 (-ln k)^m dk = m!$</p></blockquote><p>令$k=e^{-t}$, $dk = -e^{-t}dt$</p><blockquote><p>$\int_{\infty}^0 -t^m e^{-t} dt = m!$<br>$\int_0^{\infty} t^m e^{-t} dt = m!$</p></blockquote><p>至此，我們可以代入奇怪的數進階乘了d(`･∀･)b<br>甚至可以對$e^{-t}$泰勒展開，拓展到複數域。</p><p>小常識: 階乘其實有很多種解析方式，每種都會產生不同的函數，這只是其中一種，也是實務上使用最多的一種，因為可以連結到Gamma function: $\Gamma(x) = (x-1)!$</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/graph/gamma-prop.htm">http://www.cust.edu.tw/mathmet/graph/gamma-prop.htm</a><br><a href="https://cosx.org/2013/01/lda-math-gamma-function/">https://cosx.org/2013/01/lda-math-gamma-function/</a><br><a href="https://zhuanlan.zhihu.com/p/114041258">https://zhuanlan.zhihu.com/p/114041258</a><br><a href="https://www.csie.ntu.edu.tw/~b89089/link/gammaFunction.pdf">https://www.csie.ntu.edu.tw/~b89089/link/gammaFunction.pdf</a><br><a href="https://kknews.cc/zh-tw/education/vlkv53a.html">https://kknews.cc/zh-tw/education/vlkv53a.html</a><br><a href="http://sgpwe.izt.uam.mx/files/users/uami/jdf/proyectos/Euler_integral.pdf">http://sgpwe.izt.uam.mx/files/users/uami/jdf/proyectos/Euler_integral.pdf</a></p><hr><p>新年新希望: 數學15級, 英文15級, 自然15級, 研究Gamma function, 補完vpython, 共形映射的文章, 學好abstract algebra, linear algebra, real/complex analysis</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在2020的最後一天完成這件事，剩下的留待明年吧…&lt;/p&gt;
&lt;p&gt;在知道有解析研拓這種東西後，我試著把一些高中的函數展開，比如log, si</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>隱藏在碰撞的$\pi$</title>
    <link href="http://yoursite.com/2020/11/05/%E9%9A%B1%E8%97%8F%E5%9C%A8%E7%A2%B0%E6%92%9E%E7%9A%84%E7%9A%84pi/"/>
    <id>http://yoursite.com/2020/11/05/%E9%9A%B1%E8%97%8F%E5%9C%A8%E7%A2%B0%E6%92%9E%E7%9A%84%E7%9A%84pi/</id>
    <published>2020-11-05T10:03:13.000Z</published>
    <updated>2021-02-21T09:30:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在3blue1brown的頻道看了<a href="https://www.youtube.com/watch?v=HEfHFsfGXjs">https://www.youtube.com/watch?v=HEfHFsfGXjs</a> ，覺得這個超有趣的，分享一下。</p><p>在無摩擦力的環境中，有一面質量無限大，並且不會吸收任何能量的牆，以及兩個方塊。</p><p><img src="https://i.imgur.com/3VLfZSR.png" alt=""></p><p>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的1倍，整個系統的碰撞數為3。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的100倍，整個系統的碰撞數為31。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的10000倍，整個系統的碰撞數為314。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的1000000倍，整個系統的碰撞數為3141。</p><p>當最右邊的方塊($m_2$)以速度$V$往左移動，且左邊方塊質量為$m_1$，求這個系統的總碰撞次數?</p><hr><p>可以寫出動能守恆與動量守恆兩個式子:</p><blockquote><p>$\frac{1}{2}m_1v_1^2 + \frac{1}{2}m_2v_2^2 = k$<br>$m_1v_1 + m_2v_2 = p$</p></blockquote><p>有上面的提示，我們可以對號入座一下，把動能守恆的式子改寫成圓方程式:<br>$(\sqrt{m_1}v_1)^2 + (\sqrt{m_2}v_2)^2 = 2k$<br>這就是在兩軸分別代表$\sqrt{m_1}v_1$, $\sqrt{m_2}v_2$時的圓方程式。<br><img src="https://i.imgur.com/k6P7aMd.png" alt=""></p><p>初始點很顯然在最下方(定義向左的速度為負)，<br><img src="https://i.imgur.com/bJlookq.png" alt=""><br>經過一次碰撞後，點會往上升一點，且往左一點，並因為遵守動能守恆而會在圓上。<br><img src="https://i.imgur.com/8uUl1Sb.png" alt=""><br>經過許多碰撞後，最終$v1$會與$v2$同方向(&gt;0)，且小於$v2$。<br><img src="https://i.imgur.com/O47tW36.png" alt=""></p><p>進入下一步前，我們得先了解那條紅色的線是怎麼來的。<br>還記得動量守恆嗎? 我們可以將其改寫:<br>$\sqrt{m_1}(\sqrt{m_1}v_1) + \sqrt{m_2}(\sqrt{m_2}v_2) = p$<br>這樣在軸上實際代表一條斜率為$-\sqrt{\frac{m_1}{m_2}}$的直線，而每次左方塊與右方塊碰撞時，必遵守這個式子，也就是說點必在此直線上。($p$會因為左方塊與牆壁的碰撞而改變)<br>那麼圓與直線的交點即為碰撞後的位置。<br>至於中間幾條與$x$軸平行的是左方塊與牆壁的碰撞。</p><p>因為斜率一樣，且中間的線平行$x$軸，可以很清楚的確定這些角度$\theta$一樣。<br><img src="https://i.imgur.com/KHe8xfU.png" alt=""></p><p>而這樣問題就變成了</p><blockquote><p>$n\theta &lt; \pi$，問最大的$n$為何，$n \in N$。</p></blockquote><p>對於$\theta$我們可以從斜率著手，$tan \theta = \sqrt{\frac{m_1}{m_2}}$<br><img src="https://i.imgur.com/EKO11c5.png" alt=""><br>取$tan^{-1}$後，$\theta = tan^{-1} \sqrt{\frac{m_1}{m_2}}$<br>設$Tm_1 = m_2$，$\theta = tan^{-1} \sqrt{\frac{1}{T}}$<br>問題變成:<br>$n &lt; \frac{\pi}{tan^{-1} \sqrt{\frac{1}{T}}}$</p><p>對於$tan^{-1}$有個性質，$tan^{-1} 10^{-x}$約等於$10^{-x}$，$x$越大，這個性質越明顯。<br>故如果$T$為$10^x$則可以換成<br>$n &lt; \frac{\pi}{tan^{-1} 10^{-\frac{x}{2}}}$<br>$n &lt; \frac{\pi}{10^{-\frac{x}{2}}}$<br>$n &lt; 10^{\frac{x}{2}}\pi$<br>答案為:</p><blockquote><p>$n = \lfloor 10^{\frac{x}{2}}\pi \rfloor$</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在3blue1brown的頻道看了&lt;a href=&quot;https://www.youtube.com/watch?v=HEfHFsfGXjs&quot;&gt;https://www.youtube.com/watch?v=HEfHFsfGXjs&lt;/a&gt; ，覺得這個超有趣的，分享一下。&lt;/p</summary>
      
    
    
    
    <category term="隨筆" scheme="http://yoursite.com/categories/%E9%9A%A8%E7%AD%86/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>高維球體體積推導</title>
    <link href="http://yoursite.com/2020/11/04/%E9%AB%98%E7%B6%AD%E7%90%83%E9%AB%94%E9%AB%94%E7%A9%8D%E6%8E%A8%E5%B0%8E/"/>
    <id>http://yoursite.com/2020/11/04/%E9%AB%98%E7%B6%AD%E7%90%83%E9%AB%94%E9%AB%94%E7%A9%8D%E6%8E%A8%E5%B0%8E/</id>
    <published>2020-11-04T11:37:19.000Z</published>
    <updated>2021-02-27T07:45:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>來完結<a href="https://oemiliatano.github.io/2020/05/08/%E5%9B%9B%E7%B6%AD%E6%94%B6%E7%B4%8D%E7%AE%B1/">以前</a> 的心願。(((o(ﾟ▽ﾟ)o)))</p><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>首先可以先從2維到3維推導，根據常識，可以知道3維體積就是無限多個2維面積的總和。<br>也就是說將無限多個2維球面積加起來，就是3維體積，這同時也是切片法的概念。<br>同樣的道理，將3維球體體積加起來，即是4維球體體積。</p><ul><li>3維球體體積推導:</li></ul><p>$x^2+y^2+z^2=r^2$，因為我們需要知道2維切面的半徑，所以先將$z^2$(或任意軸)搬過去，<br>$x^2+y^2=r^2-z^2=R^2$，現在只要在z軸上走動，就可以知道這個2維切面的半徑為何。<br>現在我們來積分，$V_3 = 2\int_{0}^{r} \pi R^2 dz = 2\pi \int_{0}^{r} r^2-z^2 dz$。<br>反導函數即為$r^2 z - \frac{1}{3} z^3$，則$V_3 = \frac{4}{3}r^3\pi$</p><ul><li>4維球體體積推導:</li></ul><p>$x^2+y^2+z^2+k^2=r^2$，同樣的把戲，$x^2+y^2+z^2=r^2-k^2=R^2$<br>$V_4 = 2\int_{0}{r} \pi \frac{4}{3}R^3 dk$，因為$(r^2-k^2)^{\frac{1}{2}} = R$,<br>$\frac{8}{3}\pi \int_{0}^{r} (r^2 - k^2)^{\frac{3}{2}} dk$，這裡需要用到變數代換了，不然根本沒辦法做。<br>$k = r (sinu)$,$dk = r (cosu) du$，換完變成<br>$\frac{8}{3}\pi \int_{0}^{\frac{\pi}{2}} (r^2 - r^2sin^2u)^{\frac{3}{2}} r(cosu) du$<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} cos^4u du$<br>這邊需要用到$cos2u = 2cos^2u - 1$?<br>兩邊平方，$cos^2 2u = 4cos^4u - 4cos^2u + 1$,$cos^4u = \frac{1}{4}cos^2 2u + cos^2u - \frac{1}{4}$。<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} \frac{1}{4}cos^2 2u + cos^2u - \frac{1}{4} du$，同樣利用上面的公式再換一下，<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} \frac{1}{8}cos 4u + \frac{1}{2}cos 2u + \frac{3}{8} du$，反導函數為$\frac{1}{32}sin4u+\frac{1}{4}sin2u+\frac{3}{8}u$<br>最終得到$V_4 = \frac{1}{2} \pi^2 r^4$</p><ul><li>5維球體體積推導:</li></ul><p>$x^2+y^2+z^2+k^2+l^2=r^2$,$x^2+y^2+z^2+k^2=r^2-l^2=R^2$<br>依樣畫葫蘆，$2\int_{0}^{r} \frac{1}{2} \pi^2 r^4$，得到$\frac{8}{15} \pi^2 r^5$</p><ul><li>n維球體體積推導:</li></ul><p>利用以上的方法將2~10維的體積全列出來</p><p>2: $r^2 \pi$<br>3: $\frac{4}{3} r^3 \pi$<br>4: $\frac{1}{2} r^4 \pi^2$<br>5: $\frac{8}{15} r^5 \pi^2$<br>6: $\frac{1}{6} r^6 \pi^3$<br>7: $\frac{16}{105} r^7 \pi^3$<br>8: $\frac{1}{24} r^8 \pi^4$<br>9: $\frac{32}{945} r^9 \pi^4$<br>10:$\frac{1}{120} r^{10} \pi^5$</p><p>可以發現$\pi$的次方一直都是$\lfloor \frac{n}{2} \rfloor$，以及$r$的次方為$n$</p><p>進一步分成偶數與奇數的話，前面的分數就會有某種規律可循，偶數為$\frac{1}{\frac{n}{2}!}$，而奇數為$\frac{2^{\lceil \frac{n}{2} \rceil}}{\prod_{i=1}^{\frac{n-1}{2}} (2i+1)}$<br>故可以整理出通式:</p><p>when n is odd,<br>$V_n = \frac{2^{\lceil \frac{n}{2} \rceil}}{\prod_{i=1}^{\frac{n-1}{2}} (2i+1)} r^n \pi^{\lfloor \frac{n}{2} \rfloor}$<br>else<br>$V_n = \frac{1}{\frac{n}{2}!} r^n \pi^{\lfloor \frac{n}{2} \rfloor}$</p><p>補充: 在上面的推導中寫道 $V_3 = 2\int_{0}^{r} \pi R^2 dz$，可以想像為一個圓形乘上z軸上一個小小的高，同樣的想法也可以適用於高維度空間。</p><p>補充: 球面積是體積的微分(對r)，可以自己想想看為什麼。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個問題算是我想了很久才想出來的，一般高中教材是用旋轉法來計算球體積，但是這個方法拓展到高維，我就不知道怎麼做了，要繞哪一軸旋轉? 轉什麼?<br>既然常用的推不出去，只好從最基礎的定義去推導，才能推廣到高維。<br>思考的過程很有趣，故留筆此篇。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;來完結&lt;a href=&quot;https://oemiliatano.github.io/2020/05/08/%E5%9B%9B%E7%B6%A</summary>
      
    
    
    
    <category term="隨筆" scheme="http://yoursite.com/categories/%E9%9A%A8%E7%AD%86/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>指數與對數函數交點個數</title>
    <link href="http://yoursite.com/2020/11/04/%E6%8C%87%E6%95%B8%E8%88%87%E5%B0%8D%E6%95%B8%E5%87%BD%E6%95%B8%E4%BA%A4%E9%BB%9E%E5%80%8B%E6%95%B8/"/>
    <id>http://yoursite.com/2020/11/04/%E6%8C%87%E6%95%B8%E8%88%87%E5%B0%8D%E6%95%B8%E5%87%BD%E6%95%B8%E4%BA%A4%E9%BB%9E%E5%80%8B%E6%95%B8/</id>
    <published>2020-11-03T17:55:41.000Z</published>
    <updated>2021-02-26T18:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>$log_a x$與$a^x$只有一個交點，請問$a$為多少?</p><ol><li>先考慮$a&gt;1$</li></ol><p><img src="https://i.imgur.com/iyOXXc3.png" alt=""></p><blockquote><p>$a=e，無交點$</p></blockquote><p><img src="https://i.imgur.com/JXpQjxK.png" alt=""></p><blockquote><p>$a=1.44，兩交點$</p></blockquote><p>首先，我們知道$log_a x$與$a^x$對稱於$x=y$直線，那麼如果只有一交點，則交點必在其($x=y$)上。<br>假設交點為$(k, k)$，而因為$x=y$是$log_a x$的切線，故$log_a x$在$x=k$的斜率為1，而$a^x$也是。<br>將$log_a x$微分後得到$\frac{1}{xlna}$，當$x=\frac{1}{lna}$時，斜率才為1。<br>將$a^x$微分後得$a^x ln a$，將$x=\frac{1}{ln a}$代進去，整理一下會寫出$eln a = 1$，套進上面的$\frac{1}{ln a}$後得到$x = e$<br>則$a^e = e$，$a = \sqrt[e]{e}$，大約是1.44。</p><p>也就是說當$1 &lt; a \leq \sqrt[e]{e}$時，才會有一個或一個以上交點存在。</p><ol><li>考慮$a&lt;1$</li></ol><p><img src="https://i.imgur.com/rUquHBE.png" alt=""></p><blockquote><p>$a=0.066$，恰一交點</p></blockquote><p><img src="https://i.imgur.com/HX6w2Ig.png" alt=""></p><blockquote><p>$a=0.022$，恰三交點</p></blockquote><p>可知道恰一交點時，$log_a x$與$a^x$的交點之切線斜率為-1。<br>利用微分故技重施，$\frac{1}{xln a}$，當$x=-\frac{1}{ln a}$時，斜率才為-1。<br>$a^x ln a$，將上面的$x$帶進去，得到$e^{-1}ln a = -1$，套進上面的$\frac{1}{ln a}$得到$x=\frac{1}{e}$，因為必交於$x=y$上，故$y = \frac{1}{e}$。<br>則$a=e^{-e}$，約為0.0659。</p><p>也就是說當$e^{-e} \leq a &lt; 1$，只會有一交點。 而當$0 &lt; a &lt; e^{-e}$，則會有三個交點。</p><p>綜上所述，可以整理出規則:<br>$a \in (0,e^{-e})$時，有三個交點。<br>$a \in [e^{-e}, 1)$時，有一個交點。<br>$a \in (1, \sqrt[e]{e})$，有兩個交點。<br>$a = \sqrt[e]{e}$，有一個交點。<br>$a \in (\sqrt[e]{e}, \infty)$，有零個交點。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$log_a x$與$a^x$只有一個交點，請問$a$為多少?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先考慮$a&amp;gt;1$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/iyOXXc3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的微積分 Integral 1</title>
    <link href="http://yoursite.com/2020/08/13/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Integral-1/"/>
    <id>http://yoursite.com/2020/08/13/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Integral-1/</id>
    <published>2020-08-13T14:29:25.000Z</published>
    <updated>2021-02-15T17:16:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>一個簡單的問題: 求$f(x)$於$x\in[a,b]$與$x$軸圍成的面積。</p><p>可以很直覺的想到將切片法，$\sum f(x)\times \Delta x$，只要$\Delta x$夠小，面積就會夠接近。<br>我們可以將上面的式子改成一個比較簡潔的寫法: $\int_{a}^{b} f(x) dx$。<br>現在可以寫出一個函數$A(a,b) = \int_{a}^{b} f(x) dx$，為了方便討論，假定$a=0$，$A(b) = \int_{0}^{b} f(x) dx$。</p><p>請先裝作不知道微積分基本定理，可以發現他們似乎有某種關係，$A(b)$會將$f(x), x\in[0,b]$的面積變成一條線<br><img src="https://i.imgur.com/kwTRBok.png" alt=""><br><img src="https://i.imgur.com/GMYzoZJ.png" alt=""></p><p>什麼東西乘上$\Delta x$後會等於$\Delta y$，你寫出了$\frac{\Delta y}{\Delta x}$，你意外的發現$f(x)$其實就只是$A(b)$在某一點的斜率，<br>而求瞬間斜率已經有一個好用的微分了，你可以大膽寫下$A(b) = \int_{0}^{b} A’(x) dx = \int_{0}^{b} \frac{dA(x)}{dx} dx$，<br>因此現在要求$f(x)$於$x\in[0,b]$與$x$軸圍成的面積，只需要找到一個$A(x)$微分後等於$f(x)$的函數，再將$b$代入就是答案，<br>而$x\in [a,b]$可以用求兩次面積扣掉後得到，$A(b)-A(a) = \int_{a}^{b} f(x) dx$。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一個簡單的問題: 求$f(x)$於$x\in[a,b]$與$x$軸圍成的面積。&lt;/p&gt;
&lt;p&gt;可以很直覺的想到將切片法，$\sum f(x)\times \Delta x$，只要$\Delta x$夠小，面積就會夠接近。&lt;br&gt;我們可以將上面的式子改成一個比較簡潔的寫法: </summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的微積分 Differential</title>
    <link href="http://yoursite.com/2020/07/24/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Differential/"/>
    <id>http://yoursite.com/2020/07/24/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Differential/</id>
    <published>2020-07-24T15:29:51.000Z</published>
    <updated>2021-02-17T16:35:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>有了極限的概念，微分就比較好理解了(或許吧lul</p><h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><blockquote><p>定義一函數的平均變化率為$\frac{f(x+h)-f(x)}{h}$，則$\lim\limits_{h\to 0} \frac{f(x+h)-f(x)}{h}$為該函數在點$x$的瞬間變化率。又可以寫成$\frac{df(x)}{dx}$</p></blockquote><p>有些人會把$\frac{df(x)}{dx}$當作一種表示方法:$f(x)$對$x$微分，但是我認為以另一種方式去理解的話會有更加深刻的看法。</p><p>對於一個曲線，我們可以取兩點$a, b$，並且得知兩點之間的平均變化率。<br><img src="https://i.imgur.com/6SHD6c1.png" alt=""><br>而現在我們把$|b-a|$慢慢縮小<br><img src="https://i.imgur.com/3LotS8m.png" alt=""><br>越來越小…<br><img src="https://i.imgur.com/l2gYfeP.png" alt=""><br>我們可以寫成$dx = b - a$，表示一個微小的$x$變化，同樣的這個曲線的輸出值$f(x)$，也會有個微小的輸出變化$dy = f(b) - f(a) = f(a + dx) - f(a)$，而這段的平均變化率寫成$\frac{dy}{dx}$。<br>所以$dx, dy$是可以有意義的，不只是表示而已，至少我這樣理解一直都是對的，知道這點會讓以後的微積分運算變得直覺許多。</p><h1 id="具象化微分公式"><a href="#具象化微分公式" class="headerlink" title="具象化微分公式"></a>具象化微分公式</h1><p><strong>加法:</strong> $\frac{d(f(x) + g(x))}{dx}=\frac{df(x)}{dx} + \frac{dg(x)}{dx}$<br>$f(x)+g(x)$可以看成兩條線相連，而$df(x)$、$dg(x)$則是微小的變化量，寫成$d(f(x) + g(x))=df(x) + dg(x)$，同除$dx$，取極限，噹噹(｡A｡)</p><p><strong>乘法:</strong> $\frac{d(f(x)g(x))}{dx}=\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx}$<br>$f(x)\times g(x)$可以看成一個矩形的面積，<br><img src="https://i.imgur.com/niLqoBt.png" alt=""><br>求面積變化量相當於微小的變化量$df(x)g(x)$、$dg(x)f(x)$與$dg(x)df(x)$的和。<br>寫成$d(f(x)g(x)) = df(x)g(x) + dg(x)f(x) + df(x)dg(x)$，兩邊同除$dx$，取極限$\lim\limits_{dx\to 0}$，得到$\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx} + \frac{dg(x)df(x)}{dx}$<br>最後一項會因為$dg(x)$取了極限而為0(或是$df(x)$都可以，看你的$dx$要跟誰除)。<br>最後就成為了$\frac{f(x)\times g(x)}{dx}=\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx}$</p><p><strong>減法:</strong> $\frac{d(f(x) - g(x))}{dx}=\frac{df(x)}{dx} - \frac{dg(x)}{dx}$<br>就跟加法一樣的想法，不多贅述。</p><p><strong>除法:</strong> $\frac{d\frac{f(x)}{g(x)}}{dx} = \frac{\frac{df(x)g(x)}{dx}-\frac{dg(x)f(x)}{dx}}{g^2(x)}$<br>這個我不知道怎麼具象化出來…只能用代數去解了(´・ω・`)<br>$h(x) = \frac{f(x)}{g(x)}$<br>$h(x)g(x) = f(x)$<br>$\frac{dh(x)g(x)}{dx} + \frac{dg(x)h(x)}{dx} = \frac{df(x)}{dx}$</p><p>$\frac{dh(x)g(x)}{dx} = \frac{df(x)}{dx} - \frac{dg(x)h(x)}{dx}$</p><p>$\frac{dh(x)}{dx} = \frac{\frac{df(x)}{dx} - \frac{dg(x)h(x)}{dx}}{g(x)}$</p><p>$\frac{dh(x)}{dx} = \frac{\frac{df(x)}{dx} - \frac{dg(x)\frac{f(x)}{g(x)}}{dx}}{g(x)}$</p><p>$\frac{dh(x)}{dx} = \frac{df(x)g(x)}{dx g^2(x)} - \frac{dg(x)f(x)}{dx g^2(x)}$</p><p>$\frac{d\frac{f(x)}{g(x)}}{dx} = \frac{\frac{df(x)g(x)}{dx}-\frac{dg(x)f(x)}{dx}}{g^2(x)}$</p><p><strong>冪次:</strong> $\frac{dx^n}{dx} = nx^{n-1}$</p><ul><li>從$n=2$開始，可以想像一個$x\times x$的正方形，其變化量是$d(x^2)=2dx \times x + dx^2$，同除$dx$，取$dx\to 0$的極限下，會讓$dx$接近0而被消去</li><li>$n=3$，想像一個$x\times x\times x$的立方體，變化量是$d(x^3) = 3dx\times x^2 + 3dx^2\times x + dx^3$，同上面的操作。</li><li>$n=4$，無法想像但是可以找到一些規律，變化量是$d(x^4) = 4dx\times x^3 …$之類的，因為之後的項全都有$dx$，所以都會被忽略掉。</li><li>$n=n$，可以想到$d(x^n) = ndx\times x^{n-1}…$，得到$\frac{dx^n}{dx} = nx^{n-1}$</li></ul><p><strong>鏈式:</strong> $\frac{dg(f(x))}{dx} = \frac{dg(f(x))}{df(x)}\frac{df(x)}{dx}$<br><img src="https://i.imgur.com/GHv9s4W.png" alt=""><br>把$f(x)$看做一個數$k$<br><img src="https://i.imgur.com/AgxsFsW.png" alt=""><br>可以寫出$\frac{dg(k)}{dk} \times dk = dg(k)$，其中$dg(k)$為這個函數$g(x)$的變化量。<br>將$k$寫回去後，$\frac{dg(f(x))}{df(x)} \times df(x) = dg(f(x))$，同除$dx$，$\frac{dg(f(x))}{df(x)} \times \frac{df(x)}{dx} = \frac{dg(f(x))}{dx}$</p><h1 id="隱微分"><a href="#隱微分" class="headerlink" title="隱微分"></a>隱微分</h1><p>相信一開始學到圓方程式如何微分時，大部分人都會感到困惑。<br>書上都直接寫$x^2+y^2=r^2$，微分$2xdx+2ydy=0$，做一下對調$-\frac{x}{y}=\frac{dy}{dx}$，就好了。<br>看起來很對，但是很奇怪，我們到底在對甚麼微分?</p><p>其實本質上仍然是對$x$微分，只是書本常常省略(可能只是我看的書沒寫)。<br>假設$y=f(x)$，$x^2+f(x)^2=r^2$對$x$微分，$2x+2f(x)\frac{df(x)}{dx}=0$，排列一下$\frac{df(x)}{dx}=-\frac{x}{f(x)}$，把$f(x)$換成$y$，這跟上面那個微分方式是等價的。</p><p>隱微分對於複雜的方程式非常有用。</p><h1 id="泰勒展開式"><a href="#泰勒展開式" class="headerlink" title="泰勒展開式"></a>泰勒展開式</h1><p>有些函數很難求出某些特定值，例如$cos 9.02323$這種，如果可以把它寫成多項式的話，就可以得到近似值。<br>我們說某個多項式等於某個函數，只要他們的各階導數相同。</p><p>推導(以$cos x$當例子):<br>我們假設有一個多項式$ax^2+bx+c$，我們要讓他盡量等於$cos x$，首先注意到的是$cos 0=1$，所以$c=1$。<br>接著$\frac{dcos x}{dx}=-sinx$，而$-sin 0 = 0$；$ax^2+bx+c$微分後$2ax+b$，$x=0$時應該要是0所以$b=0$。<br>再微一次就可以知道$a=-\frac{1}{2}$，這樣我們就得到了一個接近$cos x$的二次函數。</p><p>顯然我們可以對cos無限求導，也就是說，我們需要一個無限多項的函數來表達，<br>$a0+a_1x^1+a_2x^2+a_3x^3…$<br>通過上述的規則可知，$a_0=1$, $a_1=0$, $a_2=-\frac{1}{2}$, $a_3=0$, $a_4=\frac{1}{24}$…</p><p>一般化形式:<br>$a0+a_1x^1+a_2x^2+a_3x^3…$=$f(x)$</p><p>$a_0=f(0)$, $a_1=\frac{df}{dx}(0)$, $a_2=\frac{\frac{d^2f}{dx^2}(0)}{2}$, $a_3=\frac{\frac{d^3f}{dx^3}(0)}{6}$…，通過這步驟可以發現$a_k=\frac{f^{(k)}(0)}{k!}$，<br>所以$f(x)=\sum_{k=0}^\infty{\frac{f^{(k)}(0)}{k!}x^k}$，寫出泰勒展開式了!<br>如果已知$f^{(k)}(a)$可以寫成$f(x)=\sum_{k=0}^\infty{\frac{f^{(k)}(a)}{k!}(x-a)^k}$ (偏移)</p><h2 id="精選題目區"><a href="#精選題目區" class="headerlink" title="精選題目區"></a>精選題目區</h2><ol><li><p>$h(x)=\sqrt[3]{x^2+\sqrt{x^3+1}}$, 求$\frac{dh(x)}{dx}$</p></li><li><p>求過圓$x^2+y^2=25$上一點$(3,-4)$的切線方程式?</p></li><li><p>$x^{\frac{2}{3}}+y^{\frac{2}{3}}=a^{\frac{2}{3}}, a&gt;0$，證明過其上任一點的切線，被坐標軸截出線段長度為一常數。<br>$x^{\frac{2}{3}}+y^{\frac{2}{3}}=r$被稱為星狀圖<br><img src="https://i.imgur.com/5lwwqFZ.png" alt=""></p></li><li><p>求$\frac{dsin^{-1}(x)}{dx}$</p></li><li><p>求$\frac{dsin^2(x)}{dx}$</p></li><li><p>$sin(x+y)=y^2cos(x)$, 求$\frac{dy}{dx}$</p></li><li><p>求$\frac{da^x}{dx}$, $a$是一常數且$a\in \Bbb{R}$</p></li><li><p>求$\frac{e^{sec3x}}{dx}$</p></li><li><p>求$\frac{dln(x)}{dx}, x&gt;0$</p></li><li><p>$f(x)=\pi^{e^{x^{\sqrt{10}}}}$, 求$\frac{df(x)}{dx}$</p></li><li><p>求$\frac{d\log_a x}{dx}$</p></li><li><p>$y=\frac{x^{\frac{3}{4}}\sqrt{x^2+1}}{(3x+2)^5}$, 求$\frac{dy}{dx}$</p></li><li><p>求$\frac{dx^{x^{x}}}{dx}, x&gt;0$</p></li><li><p>求$\frac{d(sinx)^{lnx}}{dx}, x&gt;0$</p></li><li><p>一倒立的圓錐形容器，高$4m$，底半徑$2m$，現以$2m^3/min$的速率倒入水，則當水面高$3m$時，水面升高的速率? 加速度? (hint: $V=\frac{1}{3}\pi r^2h$)</p></li><li><p>一時鐘時針長$8mm$，分針長$4mm$，則在1點時，兩針針尖距離的變化率(mm/hr)?</p></li><li><p>一粒子P在平面上運動，時間$t, t&gt;0$，位置為曲線$xy+2x=2t$與$y=x^2t$的交點，則$t=2$時P與原點的距離變化率?</p></li><li><p>一雪球體積融化的速度與表面積成正比。假設經過3小時體積融化一半，則在何時完全融化?</p></li></ol><p>題目來源: <a href="http://www.math.ntu.edu.tw/~hchu/Calculus/">http://www.math.ntu.edu.tw/~hchu/Calculus/</a> (感謝講義製作人!)</p><h2 id="題目講解區"><a href="#題目講解區" class="headerlink" title="題目講解區:"></a>題目講解區:</h2><ol><li><p>連鎖律<br><strong>Answer:</strong> $\frac{1}{3}(x^2+\sqrt{x^3+1})^{-\frac{2}{3}}(2x+\frac{3x^2}{2\sqrt{x^3+1}})$</p></li><li><p>隱微分<br><strong>Answer:</strong> $\frac{3}{4}(x-3)=y+4$</p></li><li><p>隱微分後找到在$(x_0, y_0)$的x-軸截距及y-軸截距。</p></li><li><p>需要用到定理: $(f^{-1})’ (b) = \frac{1}{(f)’ (f^{-1}(b))}$，請自行證明<br><strong>Answer:</strong> $\frac{1}{\sqrt{1-x^2}}$</p></li><li><p>連鎖律<br><strong>Answer:</strong> $sin 2x$</p></li><li><p>隱微分+連鎖律<br><strong>Answer:</strong> $\frac{cos(x+y)+y^2sin x}{2ycosx -cos(x+y)}$</p></li><li><p>利用自然對數的性質<br><strong>Answer:</strong> $2^xln 2$</p></li><li><p>自然對數、三角函數微分<br><strong>Answer:</strong> $e^{sec3x}3tan(3x)sec(3x)$</p></li><li><p>反函數定理(參p4)<br><strong>Answer:</strong> $\frac{1}{x}$</p></li><li><p>連鎖律<br><strong>Answer:</strong> $ln(\pi)\pi ^{e^{x^{\sqrt{10}}}}e^{x^{\sqrt{10}}}\sqrt{10}x^{\sqrt{10}-1}$</p></li><li><p>一般對數轉換成自然對數<br><strong>Answer:</strong> $\frac{1}{xln a}$</p></li><li><p>對數微分法:<br>設$y=f(x)$，兩邊取$ln$，$ln|y|=ln|f(x)|$，微分$\frac{dln|y|}{dx}=\frac{ln|f(x)|}{dx}$<br>$\frac{dy}{|y|dx}=\frac{df(x)}{|f(x)|dx}$，得$\frac{dy}{dx}=\frac{df(x)}{dx}$</p><p>套用到這題，$ln y = ln(x^{\frac{3}{4}}\sqrt{x^2+1}) - ln(3x+2)^5$，微分後你就知道怎麼做了 :)<br><strong>Answer:</strong> $\frac{x^{\frac{3}{4}}\sqrt{x^2+1}}{(3x+2)^5}(\frac{3}{4x}+\frac{x}{x^2+1}-\frac{15}{3x+2})$</p></li><li><p>同樣是對數微分法<br><strong>Answer:</strong> $[x^x(1 + ln x)lnx + x^{x-1}]x^{x^x}$</p></li><li><p>又是對數微分法<br><strong>Answer:</strong> $(\frac{ln(sinx)}{x}+ln(x)cot(x))(sinx)^{lnx}$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{8}{9\pi}$, $\frac{128}{243\pi ^2}$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $-\frac{22}{3\sqrt{5-2\sqrt{3}}}\pi$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{sqrt{5}}{2}^3$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{3\sqrt[3]{2}}{\sqrt[3]{2}-1}$</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有了極限的概念，微分就比較好理解了(或許吧lul&lt;/p&gt;
&lt;h2 id=&quot;微分&quot;&gt;&lt;a href=&quot;#微分&quot; class=&quot;headerlink&quot; title=&quot;微分&quot;&gt;&lt;/a&gt;微分&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定義一函數的平均變化率為$\frac{f(x+h)</summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>從零開始的微積分 Limitation</title>
    <link href="http://yoursite.com/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-limitation/"/>
    <id>http://yoursite.com/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-limitation/</id>
    <published>2020-07-15T17:43:52.000Z</published>
    <updated>2021-02-17T16:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>極限應該是大部分人學習微積分第一個學的吧。<br>很多人都會把極限當成純粹把數字帶進去，尤其是初學者，然而如果是以這種方式去了解，之後面對不連續的函數時，將會感到困惑、不直覺，只有了解極限的定義後才可以有好的觀念去處理之後的問題。</p><h1 id="序列極限"><a href="#序列極限" class="headerlink" title="序列極限:"></a>序列極限:</h1><blockquote><p>設$ \{ x_n \} , x_n \in R, L \in R, n=1,2…$，存在任意實數$\epsilon$與$N$使得當$n&gt;N$，存在$|x_n - L| &lt; \epsilon$，則稱序列${x_n}$存在極限值$L$。</p></blockquote><p>這是柯西在19世紀給出的極限的定義，而正是這種定義使現代微積分(極限微積分)與古典微積分(無窮小微積分)畫上了界線。</p><p>舉個例子，$\{0.1, 0.001, 0.0001, 0.00001, …, 10^{-k}\}$，我們可以找到任意實數，存在$|x_n - 0|&lt; \epsilon$，所以這個序列存在極限值0。<br>理解了序列極限，函數極限就不難理解了。</p><h1 id="函數極限"><a href="#函數極限" class="headerlink" title="函數極限:"></a>函數極限:</h1><p><img src="https://i.imgur.com/rRIjuNg.jpg" alt=""></p><blockquote><p>假設有一個實函數$f(x)$，而對於點$x$可以找到任意實數$\delta$使得$|x - c|&lt; \delta$，如果我們可以找到任意實數$\epsilon$，以及一個實數$L$，使得$|f(x)- L|&lt; \epsilon$，則我們說$\lim\limits_{x\to c} f(x) = L$</p></blockquote><p>利用剛剛的序列極限思想，可以很輕鬆的理解，一個序列$\{x_k\}$不斷趨近於$c$，同時定義序列$\{f(x_1), f(x_2), f(x_3), …, f(x_k)\}$，可以找到任意實數使$|f(x_n)-L|&lt; \epsilon$，則此函數在$c$上的極限值為$L$</p><p>我以前常常思考 “趨近”是否就是”等於”?<br>後來我認為，這兩種觀念不該混為一談，別再問”趨近”是不是”等於”了，這兩個根本無法比較。<br>趨近是指一個序列的極限值為某數，所以一般寫 某個極限=某個數字，是指說 這個序列的極限值=某個數字。</p><p>再補充一點，當時柯西寫出極限定義時，實數還是不完備的，可能中間還有奇怪的數字(A理數, B理數…)，之後由許多數學家寫出實數基本定理後才使上面的定義變嚴謹。<br>實數基本定理證明了實數是連續的，且只要兩實數中間無任何實數則兩實數相等。</p><h1 id="極限性質"><a href="#極限性質" class="headerlink" title="極限性質"></a>極限性質</h1><p>_只有當右側極限存在才成立。_<br>$\lim\limits_{n\to c} k\times f(n) = k \times \lim\limits_{n\to c} f(n)$<br>$\lim\limits_{n\to c} [f(n) + g(n)] = \lim\limits_{n\to c} f(n) + \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} [f(n) - g(n)] = \lim\limits_{n\to c} f(n) - \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} [f(n) \times g(n)] = \lim\limits_{n\to c} f(n) \times \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} \frac{f(n)}{g(n)} = \frac{\lim\limits_{n\to c} f(n)}{\lim\limits_{n\to c} g(n)}$</p><h1 id="精選題目區"><a href="#精選題目區" class="headerlink" title="精選題目區:"></a>精選題目區:</h1><ol><li>$\lim\limits_{x\to 0} \frac{|x|}{x}$</li><li>$\lim\limits_{x\to 3^+} \lfloor x \rfloor$, $\lim\limits_{x\to 3^-} \lfloor x \rfloor$</li><li>$\lim\limits_{x\to 2^+} \frac{x-3}{x^2-4}, \lim\limits_{x\to 2^-} \frac{x-3}{x^2-4}$</li><li>$\lim\limits_{x\to 2} \frac{(x-2)^2}{x^2-4}$</li><li>$\lim\limits_{x\to 2^+} tan^{-1} \frac{1}{x-2}$</li><li>$\lim\limits_{\theta \to 0} \frac{\sin \theta}{\theta}$</li><li>$\lim\limits_{\theta \to 0} \frac{\sin (\theta - 1)}{\theta - 1}, \lim\limits_{\theta \to 1} \frac{\sin (\theta - 1)}{\theta - 1}$</li><li>$\lim\limits_{\theta \to 0} \frac{\cos \theta -1}{\theta}, \lim\limits_{\theta \to 0} \frac{\cos \theta -1}{\theta ^2}$</li><li>$\lim\limits_{x\to 0} tan x \sin \frac{1}{x}$</li></ol><h1 id="題目講解區"><a href="#題目講解區" class="headerlink" title="題目講解區:"></a>題目講解區:</h1><ol><li><p>左極限、右極限不同，所以不存在極限。<br><strong>Answer:不存在極限</strong></p></li><li><p>如果你把它的函數圖形畫出來，你就會知道了。<br><img src="https://i.imgur.com/reuzeIU.png" alt=""><br><strong>Answer:3,2</strong></p></li><li><p>(a)上方極限為-1，下方為0，則極限值為$- \infty$<br>(b)上方極限為-1，下方為-0，則極限值為$\infty$<br><strong>Answer:</strong> $- \infty$,$\infty$</p></li><li><p>先把x-2這個因式消掉就可以了。<br><strong>Answer:0</strong></p></li><li><p>實際上這個等同於$\lim\limits_{x\to 0^+} tan^{-1} \frac{1}{x}$，而又等同於$\lim\limits_{x\to \infty ^+} tan^{-1} x$，這下你就知道了。<br><strong>Answer:</strong> $\frac{\pi}{2}$</p></li><li><p>需要用到夾擠定理(三明治定理)，依下圖可以寫出不等式$\frac{\sin \theta}{2} \leq \frac{\pi \theta}{2 \pi} \leq \frac{tan \theta}{2}$(三角形與扇形面積)，解出來就得到答案。<br><img src="https://i.imgur.com/69xvwLs.png" alt=""><br><strong>Answer:1</strong></p></li><li><p>同樣的，兩個都可以將$\theta -1$替換掉，跟第五題一樣。<br><strong>Answer:</strong> $\sin 1$, <strong>1</strong></p></li><li><p>$\frac{\cos \theta -1}{2}= \sin^2 \frac{\theta}{2}$，使用這個公式就好(ゝ∀･)<br><strong>Answer:0</strong>, $- \frac{1}{2}$</p></li><li><p>$-1 \leq \sin \frac{1}{x} \leq 1$，$-tan x \leq \sin \frac{1}{x} \leq tan x$，當x趨近於0，$0 \leq \sin \frac{1}{x} \leq 0$(夾擠定理)。<br><strong>Answer:0</strong></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;極限應該是大部分人學習微積分第一個學的吧。&lt;br&gt;很多人都會把極限當成純粹把數字帶進去，尤其是初學者，然而如果是以這種方式去了解，之後面對不連續的函數時，將會感到困惑、不直覺，只有了解極限的定義後才可以有好的觀念去處理之後的問題。&lt;/p&gt;
&lt;h1 id=&quot;序列極限&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="筆記" scheme="http://yoursite.com/categories/%E7%AD%86%E8%A8%98/"/>
    
    
    <category term="math" scheme="http://yoursite.com/tags/math/"/>
    
  </entry>
  
</feed>
