<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Test</title>
      <link href="/2023/01/14/test/"/>
      <url>/2023/01/14/test/</url>
      
        <content type="html"><![CDATA[<p>012</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熱傳導與傅立葉</title>
      <link href="/2022/05/06/%E7%86%B1%E5%82%B3%E5%B0%8E%E8%88%87%E5%82%85%E7%AB%8B%E8%91%89/"/>
      <url>/2022/05/06/%E7%86%B1%E5%82%B3%E5%B0%8E%E8%88%87%E5%82%85%E7%AB%8B%E8%91%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微積分(其實是教basic fourier analysis)期末專題。<br>我研究的主題是<a href="https://en.wikipedia.org/wiki/Heat_equation">熱傳導方程式</a> ，並使用python模擬熱傳導的模型。</p><hr><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>傅立葉冷卻定律描述熱在介質中傳播的規律，可以用兩種形式表達:</p><ol><li><p>微分形式，關注局部的熱傳導率</p><script type="math/tex; mode=display">\frac{\partial u}{\partial t}=\alpha \nabla^2 u</script></li><li><p>積分形式，關注流出/入部分介質表面的熱</p><script type="math/tex; mode=display">P=-k\oint_S\vec{\nabla}T\cdot\vec{dA}</script></li></ol><p>我使用的熱傳導方程就是<a href="https://en.wikipedia.org/wiki/Thermal_conduction#Fourier&#39;s_law">傅立葉冷卻定律</a> 的微分形式，來描述區域內溫度的演化。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="有限一維模型-數學推導"><a href="#有限一維模型-數學推導" class="headerlink" title="有限一維模型-數學推導"></a>有限一維模型-數學推導</h2><p><img src="https://imgur.com/1fse45u.png" alt=""></p><p>考慮一個理想的長棍，若$t=0$時，長棍上各點的溫度可用$f(x)$表達。<br>若可用一函數$u(x,t)$表達長棍一點的溫度於特定時間，求$u(x,t)$。</p><p>可知熱傳導方程式為: $\frac{\partial u}{\partial t}=\alpha \nabla^2 u$<br>因此處模型只有一維，故式中laplacian可改為: $\frac{\partial u}{\partial t}=\alpha \frac{\partial^2 u}{\partial x^2}$<br>在物理意義上為溫度隨時間改變的速度正比於相鄰溫差之差。</p><p>使用Neumann boundary condition: $\frac{\partial u}{\partial x}(0,t)=\frac{\partial u}{\partial x}(l,t)=0$<br>當然也可以使用Dirichlet boundary condition: $u(0,t)=u(l,t)=0$，但這裡只展示Neumann條件下的推導而已。</p><p>用分離變數法，假設$u(x,t)=X(x)T(t)$。<br>從$\frac{\partial u}{\partial t}=\alpha \nabla^2u$可知，$X(x)T’(t)=\alpha X’’(x)T(t)$。<br>令$\lambda=\alpha T(t)/T’(t)= X(x)/X’’(x)$。</p><p>先解出$X(x)$的部分，$\lambda X’’(x)-X(x)=0$。<br>利用特稱方程解此ODE，$\lambda m^2-1=0\iff m=\pm\sqrt\frac1\lambda$，所以$X(x)$的通解為$X(x)=c_1e^{\frac x{\sqrt\lambda}}+c_2e^{-\frac x{\sqrt\lambda}}$</p><p>檢查邊界條件。<br>$X’(x)=\frac{c_1}{\sqrt\lambda}e^{\frac x{\sqrt\lambda}}-\frac{c_2}{\sqrt\lambda}e^{-\frac x{\sqrt\lambda}}$.<br>$X’(0)=\frac{c_1}{\sqrt\lambda}-\frac{c_2}{\sqrt\lambda}=0\Rightarrow c_1=c_2$<br>$X’(l)=\frac{c_1}{\sqrt\lambda}e^{\frac l{\sqrt\lambda}}-\frac{c_2}{\sqrt\lambda}e^{-\frac l{\sqrt\lambda}}=0=\frac{c_1}{\sqrt\lambda}(e^{\frac{l}{\sqrt\lambda}}-e^{-\frac{l}{\sqrt\lambda}})\Rightarrow e^{\frac{l}{\sqrt\lambda}}=e^{-\frac{l}{\sqrt\lambda}}$</p><p>分別討論$\lambda$的正負:<br>若$\lambda&gt;0$，無解。<br>若$\lambda=0$，$X(x)=0, u(x,t)=0$，此為平凡解。<br>若$\lambda&lt;0$, $e^{i\frac{l}{\sqrt{|\lambda|}}}=e^{-i\frac{l}{\sqrt{|\lambda|}}}$。<br>利用歐拉公式，上式化簡為$2isin(\frac l{\sqrt{|\lambda|}})=0\iff|\lambda|=\frac{l^2}{n^2\pi^2}$。<br>由此可知，$|\lambda|$必滿足$|\lambda|=\frac{l^2}{n^2\pi^2}$。</p><p>回頭解$T(t)$，$\alpha T(t)/T’(t)=\lambda\Rightarrow\alpha T(t)=\lambda T’(t)\Rightarrow\alpha dt=\frac{\lambda}{T}dT\Rightarrow\int\frac \alpha\lambda dt=\int\frac1{T}dT=\frac\alpha\lambda t=ln(T)\Rightarrow ce^{t\frac \alpha\lambda}=T(t)$</p><p>最後，利用上述的解得到$u(x,t)=X(x)T(t)=K_ne^{-\alpha t\frac{n^2\pi^2}{l^2}}cos(x\frac{n\pi}{l})$</p><p>但注意此處有自由變數$n$，而根據此PDE的線性性質(若有$n$個解$f_i$，則$\sum_{i=1}^n f_i$構成解空間)，所以通解要寫成</p><p>$u(x,t)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_ncos(x\frac{n\pi}{l})e^{-\alpha t\frac{n^2\pi^2}{l^2}}$</p><p>當$t=0$時，$u(x,0)=f(x)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_ncos(x\frac{n\pi}{l})$</p><p>若改成用Dirichlet boundary condition，解則變為$u(x,t)=\sum^{\infty}_{n=0} X_n(x)T_n(t)=\sum^\infty_{n=0}K_nsin(x\frac{n\pi}{l})e^{-\alpha t\frac{n^2\pi^2}{l^2}}$</p><p>正是因為這兩種解都牽涉到將函數轉成用三角函數表達，而促使傅立葉發展出傅立葉級數。</p><hr><h2 id="有限一維模型-程式模擬"><a href="#有限一維模型-程式模擬" class="headerlink" title="有限一維模型-程式模擬"></a>有限一維模型-程式模擬</h2><p>我是用python的matplotlib的套件來畫圖，想看這套件的用法請參考我<a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">以前的文章</a>。<br>定積分用黎曼和計算。</p><p>2D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line">l = np.pi</span><br><span class="line">maxn = <span class="number">1000</span></span><br><span class="line">K = [<span class="number">0</span>] * maxn</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)), np.logical_not(np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.cos(x)</span><br><span class="line"><span class="comment">#return np.cos(np.sin(x * np.pi / l))</span></span><br><span class="line"><span class="comment">#return 1/3 * (x**3) - l/2 * (x**2)</span></span><br><span class="line"><span class="comment">#return (1/5) * (x**5) - ((7 + l) / 4) * (x**4) + ((10 + 7 * l) / 3) * (x**3) - 5*l *(x**2)</span></span><br><span class="line"><span class="comment">#return np.sin(np.pi * x**2 / (2 * l**2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient cos series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_cos</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.cos(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line">K[<span class="number">0</span>] /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient sin series</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_sin</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.sin(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate coefficient</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn</span>(<span class="params">mode = <span class="string">&quot;cos&quot;</span></span>):</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;cos&quot;</span>:</span><br><span class="line">calKn_cos()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">calKn_sin()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;error argument&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># solution function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">1000</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">s += K[n] * np.cos(x * n * np.pi / l) * np.exp(-alpha * t * (n * np.pi / l) ** <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0.5</span>, l - <span class="number">0.5</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">calKn()</span><br><span class="line"></span><br><span class="line">plt.plot(X, u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=0&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=1&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=2&#x27;</span>)</span><br><span class="line">plt.plot(X, u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>3D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line">l = np.pi</span><br><span class="line">maxn = <span class="number">1000</span></span><br><span class="line">K = [<span class="number">0</span>] * maxn</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)), np.logical_not(np.logical_and(np.less_equal(x, 3), np.greater_equal(x,2)))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.cos(x)</span><br><span class="line"><span class="comment">#return np.cos(np.sin(x * np.pi / l))</span></span><br><span class="line"><span class="comment">#return 1/3 * (x**3) - l/2 * (x**2)</span></span><br><span class="line"><span class="comment">#return (1/5) * (x**5) - ((7 + l) / 4) * (x**4) + ((10 + 7 * l) / 3) * (x**3) - 5*l *(x**2)</span></span><br><span class="line"><span class="comment">#return np.sin(np.pi * x**2 / (2 * l**2))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_cos</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.cos(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line">K[<span class="number">0</span>] /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn_sin</span>():</span><br><span class="line">dl = l / maxn</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">K[n] += f(dl * i) * np.sin(np.pi * n * dl * i / l)</span><br><span class="line">K[n] *= (<span class="number">2</span> * dl / l)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calKn</span>(<span class="params">mode = <span class="string">&quot;cos&quot;</span></span>):</span><br><span class="line"><span class="keyword">if</span> mode == <span class="string">&quot;cos&quot;</span>:</span><br><span class="line">calKn_cos()</span><br><span class="line"><span class="keyword">elif</span> mode == <span class="string">&quot;sin&quot;</span>:</span><br><span class="line">calKn_sin()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;error argument&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">1000</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(maxn):</span><br><span class="line">s += K[n] * np.cos(x * n * np.pi / l) * np.exp(-alpha * t * (n * np.pi / l) ** <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection = <span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(<span class="number">0.5</span>, l - <span class="number">0.5</span>, <span class="number">1024</span>)</span><br><span class="line">T = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">calKn()</span><br><span class="line"></span><br><span class="line">X, T = np.meshgrid(X, T)</span><br><span class="line">U = u(X, T, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;temperature&#x27;</span>)</span><br><span class="line">ax.plot_surface(X, T, U, cmap = <span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>圖片:</p><p>$f(x) = cos(x), l = 2\pi, \alpha = 0.5$<br><img src="https://i.imgur.com/0yMl4b5.png" alt=""></p><p><img src="https://i.imgur.com/dpwXK3M.png" alt=""></p><p>$f(x) = cos(x), l = \pi, \alpha = 0.5$<br><img src="https://i.imgur.com/wLDnDYE.png" alt=""></p><p><img src="https://i.imgur.com/786ARJu.png" alt=""></p><p>$f(x) = cos(sin(x * \pi/l)), l = 5, \alpha = 0.5$<br><img src="https://i.imgur.com/0LrMCvt.png" alt=""></p><p><img src="https://i.imgur.com/YAOzHtZ.png" alt=""></p><p>$f(x) = \frac15x^5 - \frac{7+l}4x^4+\frac{10+7l}3x^3 - 5lx^2, l=5, \alpha = 0.5$<br><img src="https://i.imgur.com/8kR9wrk.png" alt=""></p><p><img src="https://i.imgur.com/MEFUehg.png" alt=""></p><p>$f(x) = \begin{cases}1&amp;,|x-2.5|&lt;0.5\\\\0&amp;,\text{else}\end{cases}, l=5, \alpha = 0.5$<br>原函數為方波。可以很清楚的看見吉布斯現象。<br><img src="https://i.imgur.com/YjjszDZ.png" alt=""></p><p><img src="https://i.imgur.com/IR1N5WI.png" alt=""></p><hr><h2 id="無限長一維模型-數學推導"><a href="#無限長一維模型-數學推導" class="headerlink" title="無限長一維模型-數學推導"></a>無限長一維模型-數學推導</h2><p>具邊界條件的模型，距離邊界越近的地方，誤差值越大，若改成使用”無限長”的長棍，則在有限區間內幾乎無誤差值。</p><p>因現在模型為無限長，故沒有邊界條件，但熱方程與初始條件仍一樣。</p><p>同樣，假設$u(x,t)=X(x)T(t)$，同樣也會得到$\lambda=\frac{X(x)}{X’’(x)}=\frac{\alpha T(t)}{T’(t)}$，也同樣要解$\lambda X’’(x)-X(x)=0$。<br>但與有限長的長棍不同處即在此。</p><p>由前一例可知$\lambda &lt; 0$，$X(x)=c_1e^{i\frac{x}{\sqrt{|\lambda|}}}+c_2e^{-i\frac{x}{\sqrt{|\lambda|}}}$<br>因無邊界條件，所以需要用其他方法化簡$X(x)$。<br>把$X(x)$寫成$\frac{c_1+c_2}2e^{i\frac{x}{\sqrt{|\lambda|}}}+\frac{c_1+c_2}2e^{-i\frac{x}{\sqrt{|\lambda|}}}+\frac{c_1-c_2}2e^{i\frac{x}{\sqrt{|\lambda|}}}-\frac{c_1-c_2}2e^{-i\frac{x}{\sqrt{|\lambda|}}}$<br>得到$X(x)=(c_1+c_2)cos(\frac{x}{\sqrt{|\lambda|}})+i(c_1-c_2)sin(\frac{x}{\sqrt{|\lambda|}})=Acos(\frac{x}{\sqrt{|\lambda|}})+Bsin(\frac{x}{\sqrt{|\lambda|}})$</p><p>$T(t)$則與前例一樣，$T(t)=ce^{t\frac \alpha\lambda}$</p><p>得到特解$u_{\lambda}(x,t)=(A_{\lambda}cos(\frac{x}{\sqrt{|\lambda|}})+B_{\lambda}sin(\frac{x}{\sqrt{|\lambda|}}))e^{-\frac{t\alpha}{|\lambda|}}$。<br>為了讓他好看點，令$p=\frac1{\sqrt{|\lambda|}}$。<br>則特解變為: $u_p(x,t)=(A_{p}cos(px)+B_{p}sin(px))e^{-p^2t\alpha}$<br>依據這個PDE的線性性質，即乘上一常數($\Delta p$)後仍為解答，$\sum^\infty_{n=0}\Delta p u_{n\Delta p}(x,t)$為通解。</p><p>$\lim_{\Delta p\to 0}\sum^\infty_{n=0}\Delta p u_{n\Delta p}(x,t)=\int^\infty_0u_p(x,t)dp=\int^\infty_0(A_{p}cos(px)+B_{p}sin(px))e^{-p^2t\alpha}dp=u(x,t)$</p><p>當$t=0$時，$u(x,0)=f(x)=\int^\infty_0(A_{p}cos(px)+B_{p}sin(px))dp$，其中，$A_p=\frac1\pi\int^\infty_{-\infty}f(x)cos(px)dx$ and $B_p=\frac1\pi\int^\infty_{-\infty}f(x)sin(px)dx$</p><p>可以自己驗證看看，這個解仍符合原先的PDE。</p><p>上式可進一步變換成複數型傅立葉轉換，過程與一般的傅立葉積分變成複數型傅立葉轉換一樣，故在此省略，直接寫出公式:<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}F(p)e^{ipx}e^{-t\alpha p^2}dp$ ，其中， $F(p)=\int^{\infty}_{-\infty}f(v)e^{-ipv}dv$</p><p>一般會認為到此結束，但實際上因為$e^{-t\alpha p^2}$這項的存在，導致可以”交換積分順序”。<br>為何如此?<br>根據Fubini’s theorem，只要 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}|dv)dp$ 與 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}|dp)dv$ 兩者都收斂，則<br>$\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}dv)dp$ 與 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}(e^{ipx}e^{-t\alpha p^2})f(v)e^{-ipv}dp)dv$同樣收斂，且結果相同。</p><p>檢查 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dv)dp$ 是否收斂:<br>$\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|e^{ip(x-v)}f(v)|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|f(v)cos(p(x-v))+if(v)sin(p(x-v))|dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}\sqrt{f^2(v)cos^2(p(x-v))+f^2(v)sin^2(p(x-v))}dv)dp=\\\\\int^{\infty}_{-\infty}e^{-t\alpha p^2}(\int^{\infty}_{-\infty}|f(v)|dv)dp$</p><p>檢查 $\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|e^{ipx}e^{-t\alpha p^2}f(v)e^{-ipv}|dp)dv$ 是否收斂的步驟與上面相似，故省略。</p><p>兩者收斂的條件相同，都是需要$f(x)$在$\Bbb R$上絕對收斂，而這也正是傅立葉轉換存在的條件之一。</p><p>注意一般使用傅立葉轉換不能交換積分順序，原因是因為 $\frac{1}{2\pi}\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}|f(v)e^{-i\omega v} e^{i\omega x}| dv) d\omega$ 並不收斂(實際上兩種皆不收斂)。</p><p>利用交換積分順序<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}f(v)(\int^{\infty}_{-\infty}e^{ip(x-v)}e^{-t\alpha p^2}dp)dv$。</p><p>注意中間的積分項<br>$\int^{\infty}_{-\infty}e^{ip(x-v)}e^{-t\alpha p^2}dp=\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))+ie^{-t\alpha p^2}sin(p(x-v))\,dp$<br>其中虛部為奇函數，故可消去，變為$\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))dp$</p><p>這個不定積分無法用初等函數寫出，但其定積分有很多做法: 曲線積分、積分內取微分、級數展開。<br>這裡用”積分內取微分”來解:<br>簡化上面的積分為 $\int^\infty_0e^{-s^2}cos(bs)ds$，<br>$I(b)=\int^\infty_0e^{-s^2}cos(bs)ds$<br>$I’(b)=\int^\infty_0\frac{\partial}{\partial b}(e^{-s^2}cos(bs))ds=\int^\infty_0-se^{-s^2}sin(bs)ds=-\frac12 bI(b)$<br>解此ODE:<br>$I’(b)=-\frac12 bI(b)\Rightarrow I(b)=\frac{\sqrt\pi}2e^{-\frac{b^2}4}$</p><p>令上述積分的$t\alpha p^2=s^2$ and $b=\frac{x-v}{\sqrt{t\alpha}}$，所以，$\int^\infty_{-\infty}e^{-t\alpha p^2}cos(p(x-v))dp=\sqrt\frac{\pi}{t\alpha}e^{-\frac{(x-v)^2}{4t\alpha}}$</p><p>答案變為<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}f(v)(\sqrt\frac{\pi}{t\alpha}e^{-\frac{(x-v)^2}{4t\alpha}})dv=\frac1{2\sqrt{\pi t \alpha}}\int^{\infty}_{-\infty}f(v)e^{-\frac{(x-v)^2}{4t\alpha}}dv$</p><p>因為$t$在分母，會令$t=0$時程式實作不方便，可以令$z=\frac{v-x}{2\sqrt{t\alpha}}$，則最終答案:</p><script type="math/tex; mode=display">\frac1{\sqrt{\pi}}\int\_{\Bbb R}f(x+2z\sqrt{t\alpha})e^{-z^2}dz</script><hr><h2 id="無限長一維模型-程式模擬"><a href="#無限長一維模型-程式模擬" class="headerlink" title="無限長一維模型-程式模擬"></a>無限長一維模型-程式模擬</h2><p>這裡牽涉到上下界無限的瑕積分，我寫了兩種方法:<br>第一是直接截斷，將上下界當作一個很大的值，再直接當定積分做；<br>第二是利用變數變換，考慮$\int_{\Bbb R}f(x)dx$，令$x=tan k$，則剛剛的積分可寫為$\int^{\pi/2}_{-\pi/2}f(tan k)\cdot sec^2(k)dk$，如此，上下界無限的積分就可變為一般的定積分，<br>(若要更精確，還可以將$[\pi/2-\Delta k, \pi/2]$以及$[-\pi/2,-\pi/2+\Delta k]$這兩個被捨去的區間一律當作$f(tan(\pm\pi/2\mp\Delta k))\cdot sec^2(\pm\pi/2\mp\Delta k)$計算)<br>(不過在我實際測試中，肉眼看不太出來兩種方法的差別，我猜測是因為收斂速度很快導致的。)</p><p>2D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.exp(-x**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tan(k)-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = np.pi / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn):</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk * n) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>)</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(np.pi / <span class="number">2</span> - dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>) * (sec(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># non-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonsub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, L = -<span class="number">100</span>, R = <span class="number">100</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = (R - L) / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn - <span class="number">1</span>):</span><br><span class="line">s += f(x + <span class="number">2</span> * (L + dk * n) * np.sqrt(t * alpha)) * np.exp(-(L + dk * n)**<span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=0&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=1&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=2&#x27;</span>)</span><br><span class="line">plt.plot(X, sub_u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>), label = <span class="string">&#x27;t=4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>3D version:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="keyword">return</span> np.sinc(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tan(k)-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = np.pi / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn):</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk * n) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk * n) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(-np.pi / <span class="number">2</span> + dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>) * (sec(-np.pi / <span class="number">2</span> + dk) ** <span class="number">2</span>)</span><br><span class="line">s += f(x + <span class="number">2</span> * np.tan(np.pi / <span class="number">2</span> - dk) * np.sqrt(t * alpha)) * np.exp(-np.tan(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>) * (sec(np.pi / <span class="number">2</span> - dk) ** <span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># non-subtitute version</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nonsub_u</span>(<span class="params">x, t, alpha = <span class="number">1</span>, L = -<span class="number">100</span>, R = <span class="number">100</span>, maxn = <span class="number">10000</span></span>):</span><br><span class="line">dk = (R - L) / maxn</span><br><span class="line">coe = dk / np.sqrt(np.pi)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, maxn - <span class="number">1</span>):</span><br><span class="line">s += f(x + <span class="number">2</span> * (L + dk * n) * np.sqrt(t * alpha)) * np.exp(-(L + dk * n)**<span class="number">2</span>)</span><br><span class="line">s *= coe</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection = <span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line">T = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">512</span>)</span><br><span class="line"></span><br><span class="line">X, T = np.meshgrid(X, T)</span><br><span class="line">U = sub_u(X, T, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;temperature&#x27;</span>)</span><br><span class="line">ax.plot_surface(X, T, U, cmap = <span class="string">&quot;rainbow&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>圖片:</p><p>$f(x)=e^{-x^2}, \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://i.imgur.com/33X8liB.png" alt=""></p><p><img src="https://i.imgur.com/JWtbA2G.png" alt=""></p><p>變數替換:<br><img src="https://i.imgur.com/o7MIhvA.png" alt=""></p><p><img src="https://imgur.com/x39ndEL.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://imgur.com/OmyMtZZ.png" alt=""></p><p><img src="https://imgur.com/xikIRne.png" alt=""></p><p>變數替換:<br><img src="https://imgur.com/BBRTe9s.png" alt=""></p><p><img src="https://imgur.com/JVYhixq.png" alt=""></p><p>$f(x)=sinc(x), \alpha = 0.5$</p><p>直接截斷計算積分:<br><img src="https://imgur.com/sKGN7F4.png" alt=""></p><p><img src="https://imgur.com/AZEXi9h.png" alt=""></p><p>變數替換:<br><img src="https://imgur.com/uPk9Umj.png" alt=""></p><p><img src="https://imgur.com/aKPUXjc.png" alt=""></p><hr><h2 id="無限長一維模型-離散化-1"><a href="#無限長一維模型-離散化-1" class="headerlink" title="無限長一維模型-離散化 1"></a>無限長一維模型-離散化 1</h2><p>既然都有CFT了，那試試看DFT能不能也產生同樣的效果。<br>將原函數取樣成一個個數據點，接著就可以利用DFT以及非正常(?)IDFT來處理:</p><p>直接寫出答案: $u(n,t)=\frac1{L}\sum^{L-1}_{k=0}(\sum^{L-1}_{m=0}f[m]e^{-i\frac{2\pi}{L}km})e^{i\frac{2\pi}{L}nk}e^{-t\alpha k^2}$<br>其中$\hat{f}[k] = \sum^{L-1}_{m=0}f[m]e^{-i\frac{2\pi}{L}km}$就是DFT。</p><hr><h2 id="無限長一維模型-離散化-1-程式模擬"><a href="#無限長一維模型-離散化-1-程式模擬" class="headerlink" title="無限長一維模型-離散化 1-程式模擬:"></a>無限長一維模型-離散化 1-程式模擬:</h2><p>離散型就沒畫成3D圖了，只有2D疊層圖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="comment">#return np.piecewise(x, [np.less_equal(abs(x), 1), np.logical_not(np.less_equal(abs(x), 1))], [1, 0])</span></span><br><span class="line"><span class="keyword">return</span> np.exp(-x**<span class="number">2</span>)</span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line">L = <span class="number">100</span></span><br><span class="line">W_L = np.exp(-<span class="number">2j</span> * np.pi / L)</span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sample of original function</span></span><br><span class="line"><span class="comment"># n shall be in [0, maxn - 1]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>(<span class="params">n</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">return</span> f(l + dk * n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># naive DFT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hatf</span>(<span class="params">k</span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">s += samplef(m) * (W_L**(k*m))</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># naive IDFT</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">s += hatf(k) * (W_L**(-k*n)) * np.exp(-t * alpha * (k**<span class="number">2</span>))</span><br><span class="line">s /= L</span><br><span class="line"><span class="keyword">return</span> s.real</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">X = np.array([*<span class="built_in">range</span>(L)])</span><br><span class="line">t0 = u(X, <span class="number">0</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">2</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map the [1, L) to (l, r)</span></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l</span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=2&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2},\alpha = 0.5$<br><img src="https://imgur.com/rJMNtSC.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, \alpha = 0.5$<br><img src="https://imgur.com/sWiby2j.png" alt=""></p><p>$f(x)=sinc(x), \alpha = 0.5$<br><img src="https://imgur.com/KMF1DH4.png" alt=""></p><p>雖然看起來蠻正確的，但對比連續的模型誤差蠻大的，看下圖:</p><p>$f(x)=e^{-x^2},\alpha = 0.5$</p><p>離散模擬:<br><img src="https://imgur.com/cnGY4dc.png" alt=""></p><p>連續模擬:<br><img src="https://imgur.com/urTBuA3.png" alt=""></p><p>我猜測是因為隨隨便便就把$e^{-t\alpha k^2}$離散化導致的。</p><hr><h2 id="無限長一維模型-離散化-2"><a href="#無限長一維模型-離散化-2" class="headerlink" title="無限長一維模型-離散化 2"></a>無限長一維模型-離散化 2</h2><p>仔細想想剛剛那樣不嚴謹的轉換有點糟糕，認真分析一下:<br>最開始的解為:<br>$u(x,t)=\frac1{2\pi}\int^{\infty}_{-\infty}(\int^{\infty}_{-\infty}f(v)e^{-ipv}dv)e^{ipx}e^{-t\alpha p^2}dp$</p><p>左思右想，這不就是$u(x, t)=\mathscr F^{-1}[\mathscr F[f(x)]\cdot e^{-t\alpha p^2}]$。<br>改寫一下，$u(x,t)=(f <em> \mathscr F^{-1}[e^{-t\alpha p^2}])(x)$<br>先計算出$\mathscr F^{-1}[e^{-t\alpha p^2}]=\frac1{\sqrt{\pi t\alpha}}e^{-\frac{x^2}{4t\alpha}}=G_t(x)$<br>所以答案又可以寫成$u(x,t) = (f </em> G_t)(x)$</p><p>先寫個連續的摺積試試看效果:<br><img src="https://imgur.com/NKQ1LOX.png" alt=""></p><p><img src="https://imgur.com/WGEMj0X.png" alt=""></p><p><img src="https://imgur.com/ES6pZWq.png" alt=""></p><p>可以看見都沒有剛剛隨便離散導致的誤差問題。</p><p>那既然，連續的摺積可以了，那離散的呢?</p><p>先切樣本出來，假設我們是在$[l,r]$上切出$L$個樣本。<br>$f[n]:=f(l + \Delta k <em> n),n\in[0,L)$，其中$\Delta k = (r-l)/L$<br>$G_t[n]:=G_t(1 + \Delta k </em> n),n\in[0,L)$</p><p>將摺積離散化後: $u(n,t)=\Delta k \sum_{m=0}^{2L-1}f[n-m]G_t[m]$</p><p>裡面的$\Delta k$是歸一化係數，一定要乘，否則數據會失準。</p><hr><h2 id="無限長一維模型-離散化-2-程式模擬"><a href="#無限長一維模型-離散化-2-程式模擬" class="headerlink" title="無限長一維模型-離散化 2-程式模擬"></a>無限長一維模型-離散化 2-程式模擬</h2><p>實作上有個小缺陷，當$t=0$時，會產生divided by zero exception所以我用$t=0.01$去逼近。<br>那如果從數學的角度看，當$\lim_{t\to0}$時，$\mathscr F^{-1}[e^{-t\alpha p^2}]=\delta(x)$<br>$(f * \delta)(x)=f(x)$，所以數學上是沒問題的。</p><p>很巧合地(應該是必然的結果)，$\lim_{t\to0}\frac1{\sqrt{\pi t\alpha}}e^{-\frac{x^2}{4t\alpha}}$，可以寫成另一種形式(令$a=2\sqrt{t\alpha}$): $\lim_{a\to0}\frac1{a\sqrt{\pi}}e^{-\frac{x^2}{a^2}}$，而這正是$\delta(x)$在分佈意義上的定義。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> np.piecewise(x, [np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>), np.logical_not(np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>))], [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heat transfer characteristic function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">x, t, alpha</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * np.sqrt(<span class="number">1</span> / (t * alpha * np.pi)) * np.exp(-(x**<span class="number">2</span>) / (<span class="number">4</span> * t * alpha))</span><br><span class="line"></span><br><span class="line">L = <span class="number">100</span></span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sf = np.array([<span class="number">0.0</span>] * (<span class="number">3</span>*L))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>():</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sf[i] = f(l + dk * i)</span><br><span class="line"></span><br><span class="line">sG = np.array([<span class="number">0.0</span>] * (<span class="number">3</span>*L))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sampleG</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sG[i] = G(l + dk * i, t, alpha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>: <span class="keyword">return</span> sf[n];</span><br><span class="line">sampleG(t, alpha)</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> * L):</span><br><span class="line">s += sf[n - m] * sG[m]</span><br><span class="line">s *= dk</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># sample the original function first</span></span><br><span class="line">samplef()</span><br><span class="line">X = np.array([*<span class="built_in">range</span>(<span class="number">2</span> * L)])</span><br><span class="line"></span><br><span class="line">t0 = u(X, <span class="number">0.01</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t4 = u(X, <span class="number">50</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># map the [1, 2L-1] to [2l, 2r)</span></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0.01&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=4&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t4, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=50&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2}, l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/C6GTC9W.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/l83G7J0.png" alt=""></p><p>$f(x)=sinc(x), l = -3, r = 3, L = 100, \alpha = 0.5$<br><img src="https://imgur.com/1QVyy7D.png" alt=""></p><p>顯然結果比隨便離散化好多了。</p><hr><h2 id="無限長一維模型-離散化-FFT-ver"><a href="#無限長一維模型-離散化-FFT-ver" class="headerlink" title="無限長一維模型-離散化-FFT ver."></a>無限長一維模型-離散化-FFT ver.</h2><p>那既然有摺積了，何不來點FFT加速?</p><p>\$f[n]:=f(l + \Delta k <em> n),n\in[0,L)\$ ，其中 $\Delta k = (r-l)/L\$<br>\$G_t[n]:=G_t(1 + \Delta k </em> n),n\in[0,L)\$</p><p>$u(n,t)=(f*G_t)[n]=\mathscr F^{-1}[\mathscr F[f]\cdot\mathscr F[G_t]][n]$</p><p>將FFT套用進DFT，就可以加速整體運算。</p><hr><h2 id="無限長一維模型-離散化-FFT-ver-程式模擬"><a href="#無限長一維模型-離散化-FFT-ver-程式模擬" class="headerlink" title="無限長一維模型-離散化-FFT ver.-程式模擬"></a>無限長一維模型-離散化-FFT ver.-程式模擬</h2><p>這裡我參考正向的蝶形網路，先將數據點重新排列，再不斷的計算小部分的傅立葉轉換。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sec</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> / np.cos(x);</span><br><span class="line"></span><br><span class="line"><span class="comment"># original function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="keyword">return</span> np.piecewise(x, [np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>), np.logical_not(np.less_equal(<span class="built_in">abs</span>(x), <span class="number">1</span>))], [<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment">#return np.exp(-x**2)</span></span><br><span class="line"><span class="comment">#return np.sinc(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># heat transfer characteristic function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">x, t, alpha</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> * np.sqrt(<span class="number">1</span> / (t * alpha * np.pi)) * np.exp(-(x**<span class="number">2</span>) / (<span class="number">4</span> * t * alpha))</span><br><span class="line"></span><br><span class="line">L = <span class="number">256</span></span><br><span class="line">l, r = -<span class="number">3</span>, <span class="number">3</span></span><br><span class="line"></span><br><span class="line">sf = np.zeros((L), dtype = <span class="built_in">complex</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">samplef</span>():</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sf[i] = f(l + dk * i)</span><br><span class="line"></span><br><span class="line">sG = np.zeros((L), dtype = <span class="built_in">complex</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sampleG</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">sG[i] = G(l + dk * i, t, alpha)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fft</span>(<span class="params">X, mode = <span class="string">&#x27;fft&#x27;</span></span>):</span><br><span class="line">tmp = np.zeros((<span class="number">2</span>, (Len:=<span class="built_in">len</span>(X))), dtype = <span class="built_in">complex</span>)</span><br><span class="line">tmp[<span class="number">0</span>] = np.copy(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># reorder</span></span><br><span class="line">N = <span class="built_in">len</span>(tmp[<span class="number">0</span>])</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N):</span><br><span class="line">k = N &gt;&gt; <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> ((j := j ^ k) &amp; k):</span><br><span class="line">k &gt;&gt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; j):</span><br><span class="line">tmp[<span class="number">0</span>][i], tmp[<span class="number">0</span>][j] = tmp[<span class="number">0</span>][j], tmp[<span class="number">0</span>][i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># fft</span></span><br><span class="line">N = <span class="number">2</span></span><br><span class="line">W = np.exp((-<span class="number">1</span> <span class="keyword">if</span> mode == <span class="string">&#x27;fft&#x27;</span> <span class="keyword">else</span> <span class="number">1</span>) * <span class="number">2j</span> * np.pi / N)</span><br><span class="line">lev = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> N &lt;= Len:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(Len):</span><br><span class="line"><span class="keyword">if</span> i % N &lt; (N &gt;&gt; <span class="number">1</span>):</span><br><span class="line">base = (i // N) * N</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][(i + (<span class="number">1</span> &lt;&lt; lev)) % N + base] += tmp[lev &amp; <span class="number">1</span>][i]</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][i % N + base] += tmp[lev &amp; <span class="number">1</span>][i]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">base = (i // N) * N</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][(i + (<span class="number">1</span> &lt;&lt; lev)) % N + base] += tmp[lev &amp; <span class="number">1</span>][i] * ( W ** ((i + (<span class="number">1</span> &lt;&lt; lev)) % N) )</span><br><span class="line">tmp[(lev &amp; <span class="number">1</span>) ^ <span class="number">1</span>][i % N + base] += tmp[lev &amp; <span class="number">1</span>][i] * ( W ** (i % N) )</span><br><span class="line">tmp[lev &amp; <span class="number">1</span>] = np.zeros((Len))</span><br><span class="line">W **= <span class="number">0.5</span></span><br><span class="line">lev += <span class="number">1</span></span><br><span class="line">N &lt;&lt;= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp[(lev) &amp; <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ifft</span>(<span class="params">X</span>):</span><br><span class="line"><span class="keyword">return</span> fft(X, mode = <span class="string">&#x27;ifft&#x27;</span>) / <span class="built_in">len</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calu</span>(<span class="params">t, alpha</span>):</span><br><span class="line">dk = (r - l) / L</span><br><span class="line"><span class="keyword">if</span> t == <span class="number">0</span>: <span class="keyword">return</span> sf[n];</span><br><span class="line">sampleG(t, alpha)</span><br><span class="line"></span><br><span class="line">cpsf = np.append(sf, np.zeros((L)))</span><br><span class="line">cpsG = np.append(sG, np.zeros((L)))</span><br><span class="line">s = ifft(fft(cpsf) * fft(cpsG))</span><br><span class="line">s *= dk</span><br><span class="line"><span class="keyword">return</span> s.real</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u</span>(<span class="params">n, t, alpha = <span class="number">1</span></span>):</span><br><span class="line">s = calu(t, alpha)</span><br><span class="line"><span class="keyword">return</span> s[n]</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line">samplef()</span><br><span class="line">X = np.array([*<span class="built_in">range</span>(<span class="number">2</span> * L)])</span><br><span class="line"></span><br><span class="line">t0 = u(X, <span class="number">0.01</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t1 = u(X, <span class="number">1</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t2 = u(X, <span class="number">4</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t3 = u(X, <span class="number">10</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">t4 = u(X, <span class="number">50</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">X = X * ((r - l) / L)</span><br><span class="line">X = X + l*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.bar(X, t0, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=0.01&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t1, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=1&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t2, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=4&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t3, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=10&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">plt.bar(X, t4, width = <span class="number">0.1</span>, label = <span class="string">&#x27;t=50&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.legend(loc = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>圖片:</p><p>$f(x)=e^{-x^2}, l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/us07TMl.png" alt=""></p><p>$f(x)=\begin{cases}1&amp;,|x|&lt;1\\\\0&amp;,\text{else}\end{cases}, l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/566gh5Q.png" alt=""></p><p>$f(x)=sinc(x), l = -3, r = 3, L = 256, \alpha = 0.5$<br><img src="https://imgur.com/D9eJqx8.png" alt=""></p><hr><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>這次的專題做的特別久，大概花了我3、4天的時間，但也收穫頗豐。<br>複習了以前做過的ODE解法，也學到了一點PDE解法、Leibniz integral rule、還有數值方法的技巧。<br>雖然推導過程不算太嚴謹，有一些步驟我沒有辦法判斷是否合法，例如從有限變成無限時，要乘上一常數，然後取極限，且這個常數是解的參數，從直覺上來講，這感覺就非法的，但結果是對的。<br>不確定其他類似的PDE也可以這樣做，希望有人可以指點迷津。</p><p>最後的離散化應該是我苦惱最久的，前面的連續版本只花一個晚上就推導出來了，之後就開始寫code、debug，寫完之後才處理離散化的問題，接著想了一整天才想到怎麼好好離散化。</p><p>blog的上一篇跟這篇隔了整整一年呢。</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最速降線問題-變分法</title>
      <link href="/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E8%AE%8A%E5%88%86%E6%B3%95/"/>
      <url>/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E8%AE%8A%E5%88%86%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。<br>總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是歐拉、拉格朗日提出的解法(當初雅各布·伯努利的解法也用到了變分的思想所以就統一寫一起了)、第三個比較特別，不是最速降線，但結果同樣是擺線。<br>這是第二篇。</p><hr><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>在無摩擦力、只有重力的情況下，一質點從一點A為起點，由速率0開始沿著某曲線滑，至B點(高度不超過A)，且 <strong>耗時最短</strong> ，求此曲線。</p><hr><h1 id="變分法推導"><a href="#變分法推導" class="headerlink" title="變分法推導"></a>變分法推導</h1><p>最速降線問題是在找$\int^{x_1}_{x_0} \sqrt{\frac{1+y’^2}{2gy}} dx$這個式子的極值。(不知道這個式子怎麼來的可以看<a href="https://oemiliatano.github.io/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/">上一篇</a>)<br>將這類型問題一般化後可以寫出</p><p>$\int^{x_1}_{x_0} F(x, y, y’) dx$</p><p>其中，$y, y’$是$x$的函數。</p><p>我們想要通過選擇最好的y來得到極值，類似於以前一般函數選取好的x值求極值，但是現在是 <strong>選取好的函數再求目標函數極值</strong><br>相仿於一般函數，可以寫出<br>$I(y) = \int^{x_1}_{x_0} F(x, y, y’) dx$，而這個$I$則被稱為泛函數。<br>也相仿於一般函數求極值，若對泛函求導後使其=0，就可以得到極值，但是該怎麼定義$\frac{dI}{dy}$ ?</p><p>假定有一函數$y$可以使得$I$到達極值，可以構造出這樣一個東西: $g(\epsilon) = I(y + \epsilon \eta) = I(\hat{y})$，$\hat{y’} = y’ + \epsilon \eta’$<br>$\eta$是任意函數(但兩端點都必須為0)，$\epsilon$是任意實數，由此將這個問題轉為一般的函數求極值問題。<br><img src="https://imgur.com/x78iM1p.png" alt=""></p><p>通過$g(\epsilon)$對$\epsilon$求導數:</p><p>$\frac{dg}{d\epsilon} = \frac{d}{d\epsilon} \int^{x_1}_{x_0} F(x, \hat{y}, \hat{y’}) dx$</p><p>求導跟積分互換<br>$\frac{dg}{d\epsilon} = \int^{x_1}_{x_0} \frac{d}{d\epsilon} F(x, \hat{y}, \hat{y’}) dx$</p><p>現在要求$dF(x, \hat{y}, \hat{y’})$，利用全微分:<br>$dF = F_x dx + F_{\hat{y}} d\hat{y} + F_{\hat{y’}} d\hat{y’}$<br>兩邊同除$d\epsilon$得</p><p>$\frac{dF}{d\epsilon} = F_x \frac{dx}{d\epsilon} + F_{\hat{y}} \frac{d\hat{y}}{d\epsilon} + F_{\hat{y’}}\frac{d\hat{y’}}{d\epsilon}$<br>(底標代表對那個變數的偏微分)</p><p>明顯$\frac{dx}{d\epsilon}=0$, $\frac{d\hat{y}}{d\epsilon} = \eta$, $\frac{d\hat(y’)}{d\epsilon} = \eta’$</p><p>$\frac{dF}{d\epsilon} = F_{\hat{y}}\eta + F_{\hat{y’}}\eta’$</p><p>將上述結果代回去</p><p>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} F_{\hat{y}}\eta dx + \int_{x_0}^{x_1} F_{\hat{y’}}\eta’ dx$</p><p>將後項分部積分:<br><img src="https://imgur.com/IyiNQDd.png" alt=""></p><p>顯然，$F_{\hat{y’}}\eta|^{x_1}_{x_0} = 0$</p><p>$\int_{x_0}^{x_1} F_{\hat{y}}\eta dx - \int_{x_0}^{x_1} \frac{dF_{\hat{y’}}}{dx}\eta dx$</p><p>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} (F_{\hat{y}} - \frac{dF_{\hat{y’}}}{dx})\eta dx$</p><p>由定義可以知道，當$\epsilon = 0$就可以得到極值，$\frac{dg}{d\epsilon} |^{\epsilon = 0} = 0$，而$\epsilon = 0$時，$\hat{y} = y$, $\hat{y’} = y’$<br>$\frac{dg}{d\epsilon} = \int_{x_0}^{x_1} (F_{y} - \frac{dF_{y’}}{dx})\eta dx$</p><p>最後一步要證明$\int_{a}^{b} f(x)\eta dx = 0$，且$\eta$為任意函數(同樣兩端為0)，則$f(x) = 0$</p><p>定 $r(a) = r(b) = 0$，且$r(x) &gt; 0, x\in[a, b]$</p><p>令 $f(x) = r(x)\eta(x)$</p><p>$\int^{b}_{a} r(x)\eta^2(x) dx = 0$</p><p>因為$r(x)$在$(a,b)$大於0，所以$f(x)$在$(a, b)$中必為0</p><hr><p>利用上面的證明可以知道</p><p>$(F_{y} - \frac{dF_{y’}}{dx}) = 0$</p><p>這就是 <strong>歐拉-拉格朗日方程式</strong></p><p>而這個方程式有兩個特殊形式:</p><ol><li><p>若f(x, y, y’) = f(x, y’)，可寫成 $F_{y’} = C$</p></li><li><p>若f(x, y, y’) = f(y, y’)，可寫成 $F - y’F_{y’} = C$</p></li></ol><hr><h1 id="利用變分法解決最速降線"><a href="#利用變分法解決最速降線" class="headerlink" title="利用變分法解決最速降線"></a>利用變分法解決最速降線</h1><p>回到一開始的式子</p><p>$\int_{x_0}^{x_1} \sqrt{\frac{1+y’^2}{2gy}} dx$</p><p>$\sqrt{\frac{1+y’^2}{2gy}}$就是$F(x, y, y’)$，只需要求解$(F_{y} - \frac{dF_{y’}}{dx}) = 0$就可以得到答案。</p><p>注意到$F$符合第二個特殊形式，故寫成<br>$\sqrt{\frac{1+y’^2}{2gy}} - y’\sqrt{\frac{y’^2}{2(1+y’^2)gy}} = C$<br>整理:<br>$\frac{1+y’^2}{\sqrt{2(1+y’^2)gy}} - \frac{y’^2}{\sqrt{2(1+y’^2)gy}} = C$</p><p>$\frac{1}{\sqrt{2(1+y’^2)gy}}= C$</p><p>$\frac{1}{(1+y’^2)y}= 2gC^2$</p><p>$\frac{1}{(1+y’^2)}= yK$, $K = 2gC^2$</p><p>$y’^2 = (yK)^{-1} - 1$</p><p>$y’ = \sqrt{(yK)^{-1} - 1}$</p><p>$((yK)^{-1} - 1)^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{1 - yK}{yK})^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{yK}{1 - yK})^{\frac{1}{2}} dy = dx$<br>兩邊積分<br>$\int (\frac{yK}{1 - yK})^{\frac{1}{2}} dy = \int dx$</p><p>令$y = \frac{sin^2\theta}{K}$, $dy = \frac{2sin\theta cos\theta}{K} d\theta$</p><p>$\int \frac{2sin^2\theta}{K} d\theta = x$</p><p>$\frac{1}{K}\int 2sin^2\theta d\theta = x$</p><p>$\frac{1}{K}(\theta - \frac{1}{2}sin2\theta) + C = x$</p><p>$\frac{1}{2K}(2\theta - sin2\theta) + C = x$</p><p>整理好，令$\alpha = 2\theta$<br>$x = \frac{1}{4gC^2}(\alpha - sin\alpha) + C$<br>$y = \frac{sin^2\theta}{K} = \frac{1}{4gC^2}(1-cos\alpha)$</p><p>這個即是 <strong>擺線的參數方程式</strong>。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個方法比起光解法更難，也更具一般性，通過這個方法也可以解決懸鏈線、最小曲面問題。<br>總的來說，這是一個比光解法更加精采的解法。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/brachistochrone.pdf">http://www.cust.edu.tw/mathmet/brachistochrone.pdf</a><br><a href="https://zhuanlan.zhihu.com/p/20718489">https://zhuanlan.zhihu.com/p/20718489</a><br><a href="http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html">http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations">https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations</a><br><a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B">https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B</a><br><a href="https://www.zhihu.com/question/39494645">https://www.zhihu.com/question/39494645</a><br><a href="https://www.jianshu.com/p/961e890e88b2">https://www.jianshu.com/p/961e890e88b2</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最速降線問題-光解法</title>
      <link href="/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/"/>
      <url>/2021/04/13/%E6%9C%80%E9%80%9F%E9%99%8D%E7%B7%9A%E5%95%8F%E9%A1%8C-%E5%85%89%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這個問題我最早是高三上從youtube看到的，但是直到最近才開始研究解法。<br>總共三篇不同解法，第一個是約翰·伯努利提出的解法、第二個是歐拉、拉格朗日提出的解法(當初雅各布·伯努利的解法也用到了變分的思想所以就統一寫一起了)、第三個比較特別，不是最速降線，但結果同樣是擺線。<br>這是第一篇。</p><hr><h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><p>在無摩擦力、只有重力的情況下，一質點從一點A為起點，由速率0開始沿著某曲線滑，至B點(高度不超過A)，且 <strong>耗時最短</strong> ，求此曲線。</p><hr><h1 id="光解法"><a href="#光解法" class="headerlink" title="光解法"></a>光解法</h1><p>約翰·伯努利(歐拉的老師)提出這個解法。</p><p>由費馬原理可以知道光總是走耗時最少的路徑，可以利用光來類比質點，求得最速路徑。</p><p>首先，可以知道一質點垂直方向下降$y$時的速度，$v = \sqrt{2gy}$。<br>可以構造出無限多層、但總厚度固定的不同介質，使得光速也滿足上面的速度條件。<br>又由於折射定律$\frac{sin\theta_k}{v_k} = C$<br><img src="https://imgur.com/3NYHjHZ.png" alt=""><br>得$\frac{sin\theta}{\sqrt{y}} = C\sqrt{2g}$</p><p>這個式子代表，這個曲線的任一點都滿足此條件，由此可以計算出此曲線。</p><p>將$sin\theta$換成$dx,dy,ds$的形式:<br>$\frac{\frac{dx}{ds}}{\sqrt{y}} = C’$</p><p>$\frac{\frac{dx}{\sqrt{dx^2 + dy^2}}}{\sqrt{y}} = C’$</p><p>$\frac{\frac{dx^2}{dx^2 + dy^2}}{y} = C’^2$</p><p>$\frac{dx^2}{dx^2 + dy^2} = yK$, $K = 2gC^2$</p><p>左式上下同除$dx^2$<br>$\frac{1}{1 + y’^2} = yK$</p><p>$y’^2 = (yK)^{-1} - 1$</p><p>$y’ = \sqrt{(yK)^{-1} - 1}$</p><p>$((yK)^{-1} - 1)^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{1 - yK}{yK})^{-\frac{1}{2}} dy = dx$</p><p>$(\frac{yK}{1 - yK})^{\frac{1}{2}} dy = dx$<br>兩邊積分<br>$\int (\frac{yK}{1 - yK})^{\frac{1}{2}} dy = \int dx$</p><p>令$y = \frac{sin^2\theta}{K}$, $dy = \frac{2sin\theta cos\theta}{K} d\theta$</p><p>$\int \frac{2sin^2\theta}{K} d\theta = x$</p><p>$\frac{1}{K}\int 2sin^2\theta d\theta = x$</p><p>$\frac{1}{K}(\theta - \frac{1}{2}sin2\theta) + C = x$</p><p>$\frac{1}{2K}(2\theta - sin2\theta) + C = x$</p><p>整理好，令$\alpha = 2\theta$<br>$x = \frac{1}{4gC^2}(\alpha - sin\alpha) + C$<br>$y = \frac{sin^2\theta}{K} = \frac{1}{4gC^2}(1-cos\alpha)$</p><p>這個即是 <strong>擺線的參數方程式</strong>。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個方法跟變分法比起來缺乏一般性，但這不影響這個解法非常精采。<br>表面上看起來缺乏變分的想法，但實際上，「光的路徑」這一概念可以連結到最小作用量，也就是說，這個解法將變分包裝了起來，本質上還是變分的想法。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/brachistochrone.pdf">http://www.cust.edu.tw/mathmet/brachistochrone.pdf</a><br><a href="https://zhuanlan.zhihu.com/p/20718489">https://zhuanlan.zhihu.com/p/20718489</a><br><a href="http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html">http://boson4.phys.tku.edu.tw/fundamentals_of_math_phys/unit-33_Variation__calculus%20_of_variation.html</a><br><a href="https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E5%8F%98%E5%88%86%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations">https://en.wikipedia.org/wiki/Fundamental_lemma_of_calculus_of_variations</a><br><a href="https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B">https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89-%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%96%B9%E7%A8%8B</a><br><a href="https://www.zhihu.com/question/39494645">https://www.zhihu.com/question/39494645</a><br><a href="https://www.jianshu.com/p/961e890e88b2">https://www.jianshu.com/p/961e890e88b2</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>語法樹</title>
      <link href="/2021/03/22/%E8%AA%9E%E6%B3%95%E6%A8%B9/"/>
      <url>/2021/03/22/%E8%AA%9E%E6%B3%95%E6%A8%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在玩編譯器的實作，裡面有提到語法樹，正好是我國中時看到但是無法實作的東西，就來填自己以前的坑囉。</p><hr><h1 id="開頭問題"><a href="#開頭問題" class="headerlink" title="開頭問題"></a>開頭問題</h1><p>實作出可以四則運算的計算機。</p><hr><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>四則運算必須考慮到$+$, $-$, $\times$, $\div$的運算優先度，還有()的使用。<br>乍看之下很複雜，但是可以感覺的某種遞迴的關係，例如:$5+9 \times 7$，可以看成$(5)+(9 \times 7)$，而右邊的括號又可以看成一個獨立的算式。<br>根據上面的規則可以將算式寫成樹，每個節點都是不同的運算子或數字。<br><img src="https://imgur.com/SQz2ogg.png" alt="Imgur"><br>將左子樹跟右子樹算好後，再根據此節點的符號運算，就可以得到答案。</p><hr><h1 id="實作"><a href="#實作" class="headerlink" title="實作"></a>實作</h1><p>實作上可以先將運算式拆成一個個token後，利用list串起來。<br>例如: $5 + 9 \times 7$，”5”是數字類型的token、”+”是符號類型，token的好處是可以以避免不必要的麻煩，例如空白、非法字元等。</p><h2 id="token"><a href="#token" class="headerlink" title="token"></a>token</h2><p>首先定義token的種類:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    TK_sign, <span class="comment">// 符號</span></span><br><span class="line">    TK_num,  <span class="comment">// 數字</span></span><br><span class="line">    TK_EOL,  <span class="comment">// end of line</span></span><br><span class="line">&#125; TokenKind;</span><br></pre></td></tr></table></figure></p><p>token本體:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Token</span> Token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Token</span></span><br><span class="line">&#123;</span><br><span class="line">    TokenKind kind;</span><br><span class="line">    Token* nex;</span><br><span class="line">    <span class="type">int64_t</span> num;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>new一個token，並設定種類<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Token* <span class="title">new_Token</span><span class="params">(TokenKind TKK, <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Token* tmp = (Token *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(Token));</span><br><span class="line">    tmp-&gt;kind = TKK;</span><br><span class="line">    tmp-&gt;str = str;</span><br><span class="line">    tmp-&gt;nex = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>將算式處理成token。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Token* <span class="title">tokenize</span><span class="params">(<span class="type">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Token head; <span class="comment">// head is a EMPTY token, and shouldn&#x27;t be returned</span></span><br><span class="line">    head.nex = <span class="literal">nullptr</span>;</span><br><span class="line">    Token* tail = &amp;head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 跳過空白</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isspace</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            ++s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判斷是否是合法的符號，是自定義的函式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isSign</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;nex = <span class="built_in">new_Token</span>(TK_sign, s++);</span><br><span class="line">            tail = tail-&gt;nex;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判斷是否是數字</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(*s))</span><br><span class="line">        &#123;</span><br><span class="line">            tail-&gt;nex = <span class="built_in">new_Token</span>(TK_num, s);</span><br><span class="line">            tail = tail-&gt;nex;</span><br><span class="line">            tail-&gt;num = <span class="built_in">strtol</span>(s, &amp;s, <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;tokenize ERROR&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;nex = <span class="built_in">new_Token</span>(TK_EOL, s);</span><br><span class="line">    tail = tail-&gt;nex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head.nex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="語法樹"><a href="#語法樹" class="headerlink" title="語法樹"></a>語法樹</h2><p>接著必須剖析一個「算式」的組成。<br>假設目前的算式已經處理好比$+$,$-$優先度高的運算，只剩下$+$,$-$，可以利用正規表達式定義:<br>expr = mul(+mul | -mul)*</p><p>而$\times$,$\div$的運算式，可以定義為:<br>mul = term(*term | \/term)*</p><p>最後()裡的算式定義為:<br>term = (num | (expr))</p><p>將上述的定義套用至語法樹的「生成」上(看code可能比較好理解)。</p><p>節點種類:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    NK_add, <span class="comment">// 加法</span></span><br><span class="line">    NK_sub, <span class="comment">// 減法</span></span><br><span class="line">    NK_mul, <span class="comment">// 乘法</span></span><br><span class="line">    NK_div, <span class="comment">// 除法</span></span><br><span class="line">    NK_num  <span class="comment">// 數字</span></span><br><span class="line">&#125;NodeKind;</span><br></pre></td></tr></table></figure></p><p>節點本體:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    NodeKind kind;</span><br><span class="line">    node *l, *r;</span><br><span class="line">    <span class="type">int64_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>new Node，分成符號與數字類型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(NodeKind NKK, node* l, node* r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = (node *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(node));</span><br><span class="line">    p-&gt;kind = NKK;</span><br><span class="line">    p-&gt;l = l;</span><br><span class="line">    p-&gt;r = r;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 數字類型沒有左右子樹</span></span><br><span class="line"><span class="function">node* <span class="title">new_node</span><span class="params">(NodeKind NKK, <span class="type">int64_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* p = (node*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(node));</span><br><span class="line">    p-&gt;kind = NKK;</span><br><span class="line">    p-&gt;val = n;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>expr()生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">expr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="built_in">mul</span>(); <span class="comment">// 遞迴判斷是否有乘除法運算</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;+&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;+&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_add, Node, <span class="built_in">mul</span>()); <span class="comment">// 生成節點，將目前的node變為父節點，一路建構上去</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;-&#x27;</span>)) <span class="comment">// // 判斷目前的token是否是&#x27;-&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_sub, Node, <span class="built_in">mul</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> Node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>mul()生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">mul</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="built_in">term</span>(); <span class="comment">// 遞迴判斷是否是另一個expr或num</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;*&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;*&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_mul, Node, <span class="built_in">term</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;/&#x27;</span>)) <span class="comment">// 判斷目前的token是否是&#x27;/&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            now_token = now_token-&gt;nex;</span><br><span class="line">            Node = <span class="built_in">new_node</span>(NK_div, Node, <span class="built_in">term</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>term生成函式<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node* <span class="title">term</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TK_isSign</span>(<span class="string">&#x27;(&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        now_token = now_token-&gt;nex;</span><br><span class="line">        Node = <span class="built_in">expr</span>();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">TK_isSign</span>(<span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;term ERROR&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        now_token = now_token-&gt;nex;</span><br><span class="line">        <span class="keyword">return</span> Node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node = <span class="built_in">new_node</span>(NK_num, <span class="built_in">TK_takeInt</span>()); <span class="comment">// 不是另一個expr，直接生成數字節點</span></span><br><span class="line">    now_token = now_token-&gt;nex;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>計算語法樹的最終答案，每個運算結果都會放在stack裡，回傳後再進行運算，最終答案就是stack的頂端數字:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int64_t</span>&gt; st;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(node* p)</span> <span class="comment">// 呼叫時，應代語法樹的根</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;kind == NK_num)</span><br><span class="line">    &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cal</span>(p-&gt;l); <span class="built_in">cal</span>(p-&gt;r); <span class="comment">// 計算左右子樹</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> b = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>(); <span class="comment">// 因為stack的性質，後面的運算元應該先pop出來</span></span><br><span class="line">    <span class="type">long</span> a = st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (p-&gt;kind)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> NK_add:</span><br><span class="line">        st.<span class="built_in">push</span>(a + b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_sub:</span><br><span class="line">        st.<span class="built_in">push</span>(a - b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_mul:</span><br><span class="line">        st.<span class="built_in">push</span>(a * b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NK_div:</span><br><span class="line">        st.<span class="built_in">push</span>(a / b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(完整程式碼: <a href="https://github.com/OEmiliatanO/Project/tree/main/Syntax%20tree">https://github.com/OEmiliatanO/Project/tree/main/Syntax%20tree</a>)</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>語法樹比起中序轉後序還要複雜一點，但是寫起來很有規則；且如果要增加其他的運算子，例如開根號等，只需要多加幾行code就可以實現。<br>不只是四則運算，語法樹對於許多語法分析來說都很有用，例如編譯器。</p><p>我的這顆語法樹也是參考編譯器實作裡學來的。</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://koshizuow.gitbook.io/compilerbook/">https://koshizuow.gitbook.io/compilerbook/</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.19 仲春夜</title>
      <link href="/2021/03/20/%E4%BB%B2%E6%98%A5%E5%A4%9C/"/>
      <url>/2021/03/20/%E4%BB%B2%E6%98%A5%E5%A4%9C/</url>
      
        <content type="html"><![CDATA[<p>3月中旬已經可以感受的到夏天穿越時間的熱浪，隨之而來的還有如棘刺一般的學測分數篩選跟備審，揮之不去的縈繞在心頭。<br>觀仰以前的模範備審，我只能感受到無力感，我真的很獨特嗎? 盡力做出了努力，但總感覺有種東西哽在喉嚨，既無法呼吸也無法倒出自己的聲音。<br>在別人眼中閃亮的戰績，是否只是一種假象? 畢竟這些戰績似乎不過一般人做些努力就可以得到，自己卻是盡力至無力才可能沾得一點。<br>這些知識就算理解，也不過是走前人走過的路途，小時幻想著自己是獨一無二，實際上我早已走入兩條路之中，大多數人走的那條路。</p><p>或許我在高一時就該選擇生奧，興趣跟專長是兩種分開的性質，興趣會驅使我走下去，但不能使我越過「天分」，直到我被天分的門檻絆倒；狠狠重跌至地面時才察覺到這件事。<br>木已刻，而水已落，有關時間的選擇是依賴時間的變數，對於我只能讀而不能寫。</p><p>但這就是小時的我曾夢想的，現在的我也不過是依賴著自己曾有夢想走著罷了，如同大多數人般追逐夢想，追得到就成功，追不到就說一句:「追不到的才叫夢想」。<br>我無法這樣妥協，但也沒有辦法，只能死命掙扎著。<br>依照自己心的代價就是如此龐大，這就是電影跟現實的差別。</p><p>夜已深，而我卻被燥熱刺醒，只不知熱是來自夏天，亦或來自已醒的夢中。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不同方式求sum, gcd</title>
      <link href="/2021/03/11/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%A9%A6%E9%A1%8C/"/>
      <url>/2021/03/11/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%9D%A2%E8%A9%A6%E9%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這在我高二就有做過了，不過舊的那篇只有放code，沒講實作細節跟原因，在這裡補上。</p><hr><h1 id="問題-1"><a href="#問題-1" class="headerlink" title="問題 1"></a>問題 1</h1><p>請實作一函數，不得使用乘法、除法、for、while、goto、if-else、switch、case、條件運算子等，算出$\sum^n_{i = 1} i$。</p><hr><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>如果不能使用迴圈，就只能往遞迴的方向思考。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sum</span>(n - <span class="number">1</span>) + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>標準遞迴</p></blockquote><p>但是遞迴受限於條件判斷來中止，若是有辦法替換條件判斷的語句才可以實現。<br>這個解答大概要看過才知道。<br>陣列可以存指標，而C++存在函式指標，利用這個就可以判斷終止條件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義函式指標為&quot;Func&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int64_t</span><span class="params">(*Func)</span><span class="params">(<span class="type">int64_t</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">stop</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Func arr[<span class="number">2</span>] = &#123;stop, cal&#125;;</span><br><span class="line"><span class="keyword">return</span> x + arr[!!x](x - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函式指標解</p></blockquote><hr><p>如果懂一點物件導向，應該知道”多型”的概念。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// to be defined</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> : <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// cat eat</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span> : <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// dog eat</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">animal house[] = &#123;dog, cat&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>標準多型概念</p></blockquote><p>同樣利用陣列也可以達成跟函式指標一樣的效果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;</span><br><span class="line"></span><br><span class="line">Base* arr[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">sum</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">sum</span><span class="params">(<span class="type">int64_t</span> x)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + arr[!!x](x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> Base;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> Cal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>]-&gt;<span class="built_in">sum</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多型解</p></blockquote><hr><h1 id="問題-2"><a href="#問題-2" class="headerlink" title="問題 2"></a>問題 2</h1><p>請實作一函數，不得使用乘法、除法、for、while、if-else、switch、case、條件運算子，算出$gcd(a, b)$。</p><hr><h1 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h1><p>同樣利用上面的模式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義函式指標為&quot;Func&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int64_t</span><span class="params">(*Func)</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">stop</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Func arr[<span class="number">2</span>] = &#123;stop, cal&#125;;</span><br><span class="line"><span class="keyword">return</span> arr[!!(a % b)]-&gt;<span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>函式指標解</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定義父類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>;</span><br><span class="line"></span><br><span class="line">Base* arr[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 中止函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子類</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cal</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 遞迴函式</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int64_t</span> <span class="title">gcd</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[!!(a % b)]-&gt;<span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int64_t</span> <span class="title">cal</span><span class="params">(<span class="type">int64_t</span> a, <span class="type">int64_t</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> A;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr[<span class="number">1</span>]-&gt;<span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多型解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SG定理與SG函數推導</title>
      <link href="/2021/03/09/SG%E5%AE%9A%E7%90%86%E8%88%87SG%E5%87%BD%E6%95%B8%E6%8E%A8%E5%B0%8E/"/>
      <url>/2021/03/09/SG%E5%AE%9A%E7%90%86%E8%88%87SG%E5%87%BD%E6%95%B8%E6%8E%A8%E5%B0%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在學校被問到賽局理論的東西，想起自己以前有學過sg函數這種東西，那時候覺得挺玄的，也沒認真推導跟思考，直接拿來用在題目上，感覺就像在玩「魔法」一樣。<br>現在有能力也有時間可以好好推導這個東西了。</p><hr><h1 id="一切起源自石頭"><a href="#一切起源自石頭" class="headerlink" title="一切起源自石頭"></a>一切起源自石頭</h1><p>某一天，有兩個極度聰明的小孩在玩遊戲，有$n$堆石頭，每堆有$a_n$顆石頭，每回合可以從任意一堆拿走$k$顆石頭，若無法再拿走石頭即輸，問在兩方採最優策略下是先手勝(N)或是先手敗(P)?</p><hr><h1 id="sg函數推導"><a href="#sg函數推導" class="headerlink" title="sg函數推導"></a>sg函數推導</h1><p>每次遇到這種問題時，都是同樣的模式，先討論$n=1, k=1$的情況:<br>根據剩餘的石頭數量，可以畫出有向圖，每點代表石頭剩餘數量:<br><img src="https://imgur.com/ojhNdHp.png" alt=""></p><blockquote><p>左下數字代表剩餘石頭數量</p></blockquote><p>可以知道當$a_1$是奇數時先手勝，反之。</p><p>而當$k=2$:<br><img src="https://imgur.com/XJquJbn.png" alt=""></p><p>由上圖可知兩個規則:</p><ol><li>只要可以轉移到的狀態中有P，此點為N</li><li>若只能轉移到N，此點為P</li></ol><p>由上面的規則就可以從終點回推到起點，就知道起點是先手敗或是先手勝。</p><p>現在或許可以思考$n&gt;1$的情形了，為了方便討論先固定$a_i = 1, i \in [1,n]$, $k=1$<br>$n=2$時，是先手敗(P)<br>$n=3$時，是先手勝(N)<br>$n=4$時，是先手敗(P)<br>…以此類推。</p><p>大膽做個猜想，若每堆的狀態N有奇數個，就是先手勝，若是偶數個，就是先手敗。<br>很可惜，這個想法在$a_i=1$時是對的；但是當$a_i$可以為2時可以找到反例:<br><img src="https://imgur.com/cq7jn33.png" alt=""></p><blockquote><p>上圖代表兩堆石頭($a_1 = 2, a_2 = 1$)各自的狀態圖</p></blockquote><p>仔細觀察剛剛$a_i=1$的圖與$a_i=2$的差別，可以感覺的出來，他們有某種層級結構，不如就將$a_i=1$的圖命為: <strong>一階</strong> (1!)，而$a_i=2$則命為: <strong>二階</strong> (2!)。<br>特別的，若是P點則稱: <strong>零階</strong> (0!)<br><img src="https://imgur.com/Nwa4QUy.png" alt=""></p><p>既然有一跟二了，那就會有三吧?<br>觀察二階圖形，他可以轉移到一階與零階，三階應當也有這種特性，可以轉移到零階，也可以轉移到一階、二階。<br><img src="https://imgur.com/JPeNHzr.png" alt=""><br>這種型態應該在$k=3$時才能出現，以此類推， <strong>$a$階只能在$k=a$時才會出現</strong> 。<br>並且可以得知「階」的另一個特性， <strong>$a$階可以轉移到$0$~$a-1$階</strong> ，其中0階可以升階，只是後手可以把他再降回原階，等同於局面沒有變動。<br>注意這裡可以將「階」定義到一個點上，可以自行思考為什麼。</p><p>而現在又出現一個問題了:<br>當$k = 2$，<br>若$a_i=3$，他的階數為多少? 將$a_i=3$畫出來，是P點，應為零階<br>而$a_i=4$，是N點，但是他轉移的狀態不像剛剛定義的「階」，這代表剛剛的定義需要擴展，不如先停下來；討論剛剛階的性質。<br><img src="https://imgur.com/PtEkcG3.png" alt=""></p><hr><p>先轉回來研究「階」組合起來的性質，若有兩堆石頭，為$a_1 = a, a_2 = b$，<br>$a = 0, b = 0$，是先手敗。(0! + 0! = P)<br>$a = 0, b = 1$，是先手勝。(0! + 1! = N)<br>$a = 0, b = 2$，是先手勝。(0! + 2! = N)<br>$a = 1, b = 1$，是先手敗。(1! + 1! = P)<br>$a = 1, b = 2$，是先手勝。(1! + 2! = N)<br>$a = 2, b = 2$，是先手敗。(2! + 2! = P)</p><p>觀察勝負的規律，當$a = b$是先手敗，其餘都是先手勝。</p><p>利用一點邏輯思考，當$a = b$，每當先手將其中一堆降階，後手總是可以將另一堆降為同一階，無論先手怎麼操作，狀態都會收斂到兩方皆為先手敗的狀態，導致先手敗。<br>而當$a \ne b, a &gt; b$，先手總是可以將第一堆石頭降階，與第二堆同階，造成與剛剛相同的情況，但是是後手敗。</p><p>於是就驗證出了這個規則: <strong>兩同階為P，兩異階為N</strong></p><p>回過頭來思考$n=1, a_i=4, k=2$究竟該怎麼定義到階上。<br>記得泰勒展開式嗎? 雖然完全無關，但是其中有個思想似乎可以套用在這邊，若$f(x)=g(x)$，則$f^{(n)}(x)=g^{(n)}(x)$，只要兩者特性完全相同，就可以判定兩者相同。</p><p>稱 $a_i=4$ 為 $x$ 階，將其與0階組合看看，是N；與1階，是P；與2階，是N。<br>寫成數學式子:<br>$x! + 0! = N$<br>$x! + 1! = P$<br>$x! + 2! = N$<br>他與1階的特性完全相同，所以可以說它是1階。</p><p>這時「階」的定義已經被擴展了，我們可以用組合已知階，來判斷其為哪一階。</p><p>不過這樣的數學定義不太簡潔，似乎可以簡化? 再深入研究看看$a_i=4$；上面的數學式子其實可以展開:<br>$x! + 0! = N$<br>|-&gt;  $0! + 0! = P$(雖然看起來是先手敗，但其實是上一局的後手敗)<br>|-&gt;  $2! + 0! = N$</p><p>$x! + 1! = P$<br>|-&gt;  $0! + 1! = N$(雖然看起來是先手勝，但其實是上一局的後手勝)<br>|-&gt;  $2! + 1! = N$</p><p>$x! + 2! = N$<br>|-&gt;  $0! + 2! = N$<br>|-&gt;  $2! + 2! = P$(雖然看起來是先手勝，但其實是上一局的後手勝)</p><p>發現一個規則，只要展開後是全N，即為先手敗，同時此點也是這階，或許還沒有足夠的證據看出來規律，我們來討論$k=3$的$a_i=5$<br><img src="https://imgur.com/ibeKI5R.png" alt=""></p><p>$x! + 0! = N$<br>|-&gt;  $0! + 0! = P$<br>|-&gt;  $2! + 0! = N$<br>|-&gt;  $3! + 0! = N$</p><p>$x! + 1! = P$<br>|-&gt;  $0! + 1! = N$<br>|-&gt;  $2! + 1! = N$<br>|-&gt;  $3! + 1! = N$<br>…(下略)</p><p>若$x$與組合的階$y$為同階，結果為P，而結果為P就代表，$x$可以轉移的所有狀態必跟$y$不同階。<br>而因為可以轉移的狀態[0, 1, 2, 3]只會有一個缺失，可以確定這個缺失必與$y$同階，故寫出以下式子:<br>$sg(status) = mex(sg(nextStatus)|status \to nextStatus)$<br>其中$mex$為最小的未出現的非負整數。</p><p>這下我們有一個好用的數學式子，來幫助我們表達一個狀態的「階」。</p><p>此時可以輕易判斷當$n=1$、任意$a_1,k$是先手勝或是先手敗。<br>但$n&gt;1$的情況又要如何判斷?</p><hr><h1 id="Nim-sum"><a href="#Nim-sum" class="headerlink" title="Nim-sum"></a>Nim-sum</h1><p>剛剛的問題是，石頭可以從任意一堆拿$k$顆，現在改成可以從任意一堆拿任意顆，情況似乎變複雜了，但是實際上變簡單了。<br>設每堆石頭為$a_i$顆，而每堆其實就代表一局遊戲。<br>現在有$n$局: $a_1,a_2,a_3…,a_n$，而$a_i \oplus a_j$代表將第$i$局遊戲與第$j$局組合起來一起玩。<br>同時$a_i$也可以說是一種狀態，$\oplus$即是將兩種狀態組合成一種狀態。</p><p>直覺告訴我們，只要在每一局遊戲中都採取最佳策略，那就會贏下整場遊戲，因此$\oplus$滿足交換律，亦即先玩完第一場或先玩完第二場都沒差。<br>接著我們也知道$(a_i \oplus a_j) \oplus a_k = a_i \oplus (a_j \oplus a_k)$，因為把兩局遊戲組合後，就算是一局大遊戲，先玩完也不影響整體勝負。<br>以及其他直覺的結論 $a_i \oplus 0 = a_i$、若$a_i = a_j$, $a_i \oplus a_j = P = 0$</p><p>利用剛剛推導出來的sg函數，我們可以知道某個狀態的階，進而判斷是先手勝或是先手敗。<br>特別的，$n=1$時，$sg(a) = a$。</p><p>根據sg函數的定義寫出$sg(a_1 \oplus a_2 … \oplus a_n) = mex(sg(a_1 \oplus … \oplus a_i’ … \oplus a_n) | a_i \to a_i’)$，這樣子可以反推回去，決定是究竟是先手勝或是先手敗。<br>然而每局的狀態難以這樣一一列舉，為了簡化情況，我們先討論$n = 2$:<br>$sg(0 \oplus 0) = P = 0$<br>$sg(0 \oplus a) = sg(a) = a$<br>$sg(a \oplus b) = P = 0$, 如果$a = b$<br>$sg(a \oplus b) = N$, 如果$a \ne b$</p><p>看著這個運算規則，越看越像xor，做個猜想: 在$n$為任意正整數下，$\oplus$與xor是等價的。<br>為此我們必須證明兩者等價:</p><p>當$a_i = 0, i \in [1, n]$，是終盤，兩者定義符合。</p><p>當$a_1$ $xor$ $a_2$ $xor$ … $a_n=0$，無法將其中一個數字改變，且維持$xor$和為0；換句話說，當$xor$和為0，下一步只會讓$xor$和為非0。<br>這其實就是最上面提到的第二點規則: <strong>若只能轉移到N，此點為P</strong> 。<br>證明這點很簡單，若將其中一數改成$a_i’$，而$xor$和變為$X$，<br>則$a_1$ $xor$ … $a_i’$… $a_n$ $=X=0$ $xor$ $a_i$ $xor$ $a_i’$，但是$a_i’&lt;a_i$，故$X = 0$ $xor$ $a_i’$ $xor$ $a_i \ne 0$<br>得證。</p><p>當$a_1$ $xor$ $a_2$ $xor$ … $a_n = X \ne 0$，可以將其中一數改變，並使$xor$和為0。<br>這也對應到最上面第一點規則: <strong>只要可以轉移到的狀態中有P，此點為N</strong> 。<br>若將$a_i$改成$a_i$ $xor$ $X$，則$xor$和為0。此時$a_i$ $xor$ $X$就是$a_i’$。<br>但是還必須證明$a_i’ &lt; a_i$，假設$X$在二進位下最高位1是第$k$位，則必有某$a_i$滿足二進位下第$k$位為1，顯然，$a_i$ $xor$ $X$第$k$位為0，得證$a_i’ &lt; a_i$。</p><p>現在我們可以非常迅速的計算一整個大遊戲的狀態了，因為$\oplus$與xor是等價，所以只要將$sg(a_1 \oplus a_2 … a_n)$裡面的值全部做xor運算即可。</p><p>必勝策略也顯而易見，先手只需要每次都使下一個狀態為0，即可獲勝。</p><hr><h1 id="回到最初的問題"><a href="#回到最初的問題" class="headerlink" title="回到最初的問題"></a>回到最初的問題</h1><p>回到一開始的問題，看似可以依剛才的結論，全部xor後判斷，但是實際上因為「無法任意改變數字」而存在錯誤，上面的證明有一步是將$a_i$變為$a_i$ $xor$ $X$，這代表$a_i$可能變成$0$ ~ $a_i-1$中任意一數，但是因為這個問題有拿走數的限制$k$，所以無法對所有狀態成立。<br>而一開始推導出來的「階」正好滿足此性質。($n$階可以轉移至$0$ ~ $n-1$階)<br>只要將一開始的每個狀態取sg()，就可以得知階數，最後再將全部xor起來，非0即為先手勝，0則為先手敗。</p><p>可能你會注意到0階接下來的轉移似乎有點問題，但是因為可以由後手轉移回0階，最終都會收斂至先手敗，所以對整體局面還是一樣。</p><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>只要先依$k$構建一DAG，從終盤逆推回去找到sg值，再將所有局面的sg值xor起來，就可以判斷問題解答。<br>寫成數學式子: $sg(<script type="math/tex">sg(a_1)$ $xor$ $sg(a_2)$ ... $xor$ $sg(a_n)</script>)$ = $sg(a_1)$ $xor$ $sg(a_2)$ … $xor$ $sg(a_n)$。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次研究的題目真硬，雖然學過了但是還是試著從零開始推導，結果真的推導出同樣的結論，這種過程真的挺好玩的，就像是在創造新的結構一樣，可以發現許多以前不曾想過的東西。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳化-梯度下降法(簡單版)</title>
      <link href="/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
      <url>/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>寫完了<a href="https://oemiliatano.github.io/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/">牛頓法</a> ，來寫梯度下降法。<br>擬牛頓法有點深奧，應該暫時不會寫。</p><hr><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><p>想法類似於牛頓法，但是少了Hessian矩陣的計算:</p><p>迭代公式:<br>$x_{k+1}=x_k - \alpha \nabla f(x_k)$<br>同樣，這邊$x$是一堆變量$a, b, c …$。</p><p>$\nabla f(x_k)$為梯度，可以利用對各變數偏微分得到，例如:<br>$\nabla f(x, y) = \frac{\partial f}{\partial x}(x, y)i + \frac{\partial f}{\partial y}(x, y)j$</p><p>而$\alpha$則是一個調整係數，一般都是在區間(0, 1]裡，具體什麼用途，必須配合等下的例子才能說明。</p><hr><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span> / <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-6</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-6</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0, y0 + h) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grad</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> np.array([dfdx(x, y), dfdy(x, y)])</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">10</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">5</span>, <span class="number">10</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 調整係數</span></span><br><span class="line">a = <span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 起始點</span></span><br><span class="line">preP = np.array([<span class="number">8.3</span>, <span class="number">7.6</span>])</span><br><span class="line">nowP = preP - grad(preP[<span class="number">0</span>], preP[<span class="number">1</span>]) * a</span><br><span class="line">plt.plot((preP[<span class="number">0</span>], nowP[<span class="number">0</span>]), (preP[<span class="number">1</span>], nowP[<span class="number">1</span>]), <span class="string">&#x27;bo-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">preP = nowP</span><br><span class="line">    nowP = preP - grad(preP[<span class="number">0</span>], preP[<span class="number">1</span>]) * a</span><br><span class="line">    plt.plot((preP[<span class="number">0</span>], nowP[<span class="number">0</span>]), (preP[<span class="number">1</span>], nowP[<span class="number">1</span>]), <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(nowP)</span><br><span class="line"><span class="built_in">print</span>(f(nowP[<span class="number">0</span>], nowP[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p><img src="https://imgur.com/O1w0iLp.gif" alt=""></p><blockquote><p>$\sqrt{x^2 + \frac{y^2}{3}}$, 起始值=(8.3, 7.6), $\alpha = 1$, 迭代次數 16<br>收斂值 $(x,y) = (-0.00243513, -0.10515567), f(x, y) = 0.06076047183997639$</p></blockquote><p><img src="https://imgur.com/3XIyWRX.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(0.3, 0.6), $\alpha = 0.7$, 迭代次數 4<br>收斂值 $(x,y) = (-0.7073123, 0.11798947), f(x, y) = -0.42295258860276885$</p></blockquote><p><img src="https://imgur.com/r7VMoej.png" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(-4, 0), $\alpha = 0.1$, 迭代次數 1<br>收斂值 <strong>無法收斂</strong><br>註解: 無法收斂的原因在下面會講</p></blockquote><p><img src="https://imgur.com/743JHoP.gif" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(-4, 0), $\alpha = 0.001$, 迭代次數 100<br>收斂值 $(x,y) = (0.65374851, 3.42158651), f(x, y) = -0.9962581603349078$</p></blockquote><p><img src="https://imgur.com/5q34ALw.gif" alt=""></p><blockquote><p>$(2x + 5)^2(213y - 0.65)^2 - 5$, 起始值=(0, 0), $\alpha = 0.1$, 迭代次數 4<br>收斂值 <strong>無法收斂</strong></p></blockquote><hr><h1 id="觀察結論"><a href="#觀察結論" class="headerlink" title="觀察結論"></a>觀察結論</h1><p>以上面的結果與其餘未放上來的資料來說，這個版本的梯度下降法不那麼實用。<br>當我們的函數值在 <strong>某點梯度極大</strong> ，我們的迭代點將會因為這個梯度”衝過頭”，更糟糕的是，衝過頭後的點梯度可能會更大(類似遊樂園的海盜船，但是停不下來)，導致 <strong>無法收斂</strong> 的情況，上面雖然只放了兩個例子，但是非常容易構造此種函數。</p><p>因為這樣子，所以才需要引入 <strong>調整係數</strong> ，但是又出現了另一個缺點，收斂太慢。<br>調整係數低確實可以提高收斂的機率，但是以此為代價，迭代次數亦會跟著成長。<br><img src="https://imgur.com/w4M2p3m.gif" alt=""></p><blockquote><p>衝過頭以致無法收斂的例子</p></blockquote><p><img src="https://imgur.com/JtNIGIb.gif" alt=""></p><blockquote><p>將調整係數調低後收斂</p></blockquote><p>當然這些問題其實可以透過一系列手段解決，而這些手段留在以後再說。</p><hr><h1 id="梯度下降法與牛頓法比較"><a href="#梯度下降法與牛頓法比較" class="headerlink" title="梯度下降法與牛頓法比較"></a>梯度下降法與牛頓法比較</h1><p>!藍色為牛頓法<br>!紅色為梯度下降法</p><p><img src="https://imgur.com/75zlqjD.gif" alt=""></p><blockquote><p>$(2x + 5)^2(213y - 0.65)^2 - 5$, 起始值=(0, 0), 迭代次數 6</p></blockquote><p><img src="https://imgur.com/WIR1zVT.gif" alt=""></p><blockquote><p>$(3x - 2)^2(y - 5)^2 - 1$, 起始值=(0, 0), 迭代次數 30<br>註解: 牛頓法在第5次就收斂了</p></blockquote><p><img src="https://imgur.com/ad9d7iA.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(0.3, 0.6), 迭代次數 10</p></blockquote><p><img src="https://imgur.com/2zusW8m.gif" alt=""></p><blockquote><p>$xe^{-x^2 - y^2}$, 起始值=(1, 0.2), 迭代次數 10</p></blockquote><p><img src="https://imgur.com/W0lxt00.gif" alt=""></p><blockquote><p>$\sqrt{x^2 + \frac{y^2}{3}}$, 起始值=(8.3, 7.6), 迭代次數 10</p></blockquote><p>可以知道牛頓法的收斂速度比梯度下降要快上許多，可以形象化理解為，梯度下降就是找周圍最陡峭、與等高線垂直的方向走，而牛頓法不只考慮最陡峭，同時考慮是否會變平緩或陡峭。</p><p>感覺梯度下降法如果調整係數低一點，穩定度會比牛頓法好上許多。但是收斂步驟增多又變成一大問題。<br>牛頓法收斂快，但是不穩定，尤其是Hessian逆矩陣對於運算效率是一種負擔。<br>兩者各有其問題、優點，或許可以在 <strong>擬牛頓法</strong> 、 <strong>變形梯度下降</strong> 找到更好的最佳化方法?</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization">https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization</a><br><a href="https://en.wikipedia.org/wiki/Gradient">https://en.wikipedia.org/wiki/Gradient</a><br><a href="https://en.wikipedia.org/wiki/Hessian_matrix">https://en.wikipedia.org/wiki/Hessian_matrix</a><br><a href="https://zhuanlan.zhihu.com/p/46536960">https://zhuanlan.zhihu.com/p/46536960</a><br><a href="https://zhuanlan.zhihu.com/p/37524275">https://zhuanlan.zhihu.com/p/37524275</a><br><a href="https://www.zhihu.com/question/19723347">https://www.zhihu.com/question/19723347</a></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最佳化-牛頓法</title>
      <link href="/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/"/>
      <url>/2021/03/01/%E6%9C%80%E4%BD%B3%E5%8C%96-%E7%89%9B%E9%A0%93%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前幾天在翻舊書，看到國中以前做過的求根\極值方法: 牛頓法，以前都是做單變量函數的，現在發現其實有多變量的。研究後發現蠻有趣的，就寫了這篇。</p><hr><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><p>多變量牛頓法主要求函數極值，原理跟單變量差不多，只是換成更高維度的東西。</p><p>單變量的迭代公式: $x_{k+1}=x_k - \frac{f’(x)}{f’’(x)}$</p><p>多變量的迭代公式: $x_{k+1}=x_k - \nabla f(x_k)\mathbf H^{-1} f(x_k)$<br>這邊$x$是一堆變量$a, b, c …$。<br>$\nabla f(x_k)$是$f(x)$在$x_k$的梯度，$\mathbf H^{-1} f(x_k)$是$f(x)$在$x_k$的Hessian逆矩陣。<br>這兩個對應到單變量一階導跟二階導倒數。</p><p>梯度可以用不同的方向向量去定義，但是這裡將梯度定義為分別將$x$, $y$固定後的導數組成的向量，也就是偏導數組成的向量，例如:<br>$\nabla f(x, y) = \frac{\partial f}{\partial x}(x, y)i + \frac{\partial f}{\partial y}(x, y)j$</p><p>Hessian逆矩陣是從Hessian矩陣求逆得到的，Hessian矩陣是多變數函數的所有二階偏導數組成的方塊矩陣，例如:<br>$\mathbf H f(x, y) = \begin{bmatrix} \frac{\partial^2 f}{\partial x^2} &amp; \frac{\partial^2 f}{\partial x \partial y} \\\ \frac{\partial^2 f}{\partial y \partial x} &amp; \frac{\partial^2 f}{\partial y^2} \end{bmatrix}$</p><hr><h2 id="實作想法"><a href="#實作想法" class="headerlink" title="實作想法"></a>實作想法</h2><p>考慮到視覺化的需求，用python來寫最合適。</p><p>因為只討論雙變量函數，所以Hessian矩陣只需要$2\times2$的就好，可以手動設。</p><p>而numpy提供的np.linalg.solve()也恰好可以求Hessian逆矩陣與梯度矩陣的乘積。</p><p>接著是計算偏導數，<br>如果你有看過我寫的<a href="https://oemiliatano.github.io/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/">曲線插值-樣條函數</a> 這篇，或許會發現我的微分是用原始定義去做的 $lim_{h \to 0} \frac{1}{h}[f(x + h) - f(x)]$ ，將$h$設成一個很小的數字，就可以逼近我們要的微分數值。<br>同樣的道理，偏微分也可以照著做:</p><p>$f_x(x, y) = \frac{\partial f}{\partial x}(x, y) = lim_{h \to 0} \frac{1}{h}[f(x + h, y) - f(x, y)]$</p><p>換成程式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br></pre></td></tr></table></figure></p><p>二階偏導同樣:</p><p>$\frac{\partial}{\partial x}(\frac{\partial f}{\partial x}(x, y)) = \frac{\partial}{\partial x}f_x(x, y)$</p><p>$=lim_{g \to 0} \frac{1}{g}[f_x(x + h, y) - f_x(x, y)]$<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0 + g, y0) - dfdx(x0, y0)) / g</span><br></pre></td></tr></table></figure></p><p>其餘偏導類似。</p><hr><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: x * np.exp(-x * x - y * y)</span><br><span class="line"></span><br><span class="line">eps = <span class="number">1e-6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏導數</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0 + h, y0) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (f(x0, y0 + h) - f(x0, y0)) / h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdx</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0 + g, y0) - dfdx(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdxdy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdx(x0, y0 + g) - dfdx(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dfdydy</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    g = <span class="number">1e-5</span></span><br><span class="line">    <span class="keyword">return</span> (dfdy(x0, y0 + g) - dfdy(x0, y0)) / g</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hessian矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">H</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    h = [[dfdxdx(x0, y0), dfdxdy(x0, y0)], [dfdxdy(x0, y0), dfdydy(x0, y0)]]</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度矩陣</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">grd</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    <span class="keyword">return</span> [dfdx(x0, y0), dfdy(x0, y0)]</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等高線圖</span></span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始值</span></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求Hessian逆矩陣與梯度矩陣的乘積</span></span><br><span class="line">k = -np.linalg.solve(H(x0, y0), grd(x0, y0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先迭代一次</span></span><br><span class="line">x1 = x0 + k[<span class="number">0</span>]</span><br><span class="line">y1 = y0 + k[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 畫線</span></span><br><span class="line">plt.plot((x0, x1), (y0, y1), <span class="string">&#x27;bo-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    x0 = x1</span><br><span class="line">    y0 = y1</span><br><span class="line">    k = -np.linalg.solve(H(x0, y0), grd(x0, y0))</span><br><span class="line">    x1 = x0 + L * k[<span class="number">0</span>]</span><br><span class="line">    y1 = y0 + L * k[<span class="number">1</span>]</span><br><span class="line">    plt.plot((x0, x1), (y0, y1), <span class="string">&#x27;ro-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最終值</span></span><br><span class="line"><span class="built_in">print</span>(x0, y0)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;extreme:&quot;</span>, f(x0, y0))</span><br></pre></td></tr></table></figure><hr><h2 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h2><p><img src="https://imgur.com/jx0qYxp.gif" alt=""></p><blockquote><p>$(ln(|x - 1|))(5y - 1) - 1$, 起始值=(1.1, 9), 迭代次數 6<br>收斂值 $(x,y) = (1.9999999999995695, 0.20000000000075954), f(x, y) = -1.0$</p></blockquote><hr><p><img src="https://imgur.com/d3Fg3lo.gif" alt=""></p><blockquote><p>$cos(\sqrt{x^2 + y^2})$, 起始值=(0.5, 1), 迭代次數 6<br>收斂值 $(x,y) = (-4.999999323762127e-06, -5.000008901435384e-06), f(x, y) = 0.999999999975$</p></blockquote><hr><p><img src="https://imgur.com/71BP3S6.gif" alt=""></p><blockquote><p>$xe^{-x^2-y^2}$, 起始值=(1, 0.2), 迭代次數 7<br>收斂值 $(x,y) = (0.7071017811951483, -4.999999497366208e-06), f(x, y) = 0.4288819424481872$</p></blockquote><hr><p><img src="https://imgur.com/7GgWBQH.gif" alt=""></p><blockquote><p>$xe^{-x^2-y^2}$, 起始值=(1, 0.3), 迭代次數 21<br>收斂值 <strong>無法收斂</strong></p></blockquote><hr><p><img src="https://imgur.com/B6U7DqW.gif" alt=""></p><blockquote><p>$sin(x) \times y^{\frac{2}{3}}$, 起始值=(-2, 0.9), 迭代次數 15<br>收斂值 $(x,y) = (-7.683814908002442e-05, -0.0020110391746036667), f(x, y) = -1.2242137360945188e-06$</p></blockquote><hr><p><img src="https://imgur.com/Fc5308N.gif" alt=""></p><blockquote><p>$sin(x) \times y^{\frac{2}{3}}$, 起始值=(-1, 2), 迭代次數 21<br>收斂值 $(x,y) = (-20.42035724833452 -4848738.969554567), f(x, y) = -28647.443380356$<br>註解: 收斂到奇怪的地方了…</p></blockquote><hr><h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>看的出來，多變量牛頓法其實就跟單變量牛頓法有著一樣的缺點: <strong>不穩定</strong>、<strong>起始點敏感</strong><br>更糟糕的情況，Hessian矩陣可能沒有逆，例如:$f(x, y) = ln(x^2 + y^2)$。</p><p>但同時優點也很明顯: <strong>收斂速度快</strong> (上面的迭代次數有調高，以求比較精準的收斂值)，比較簡單的函數甚至可以兩步到位。</p><p>個人覺得實際應用不可能直接用純的牛頓法，弊大於利，畢竟起始點必須選的很好才有可能收斂，應該搭配其他演算法抓起始點的大略位置，再給牛頓法去迭代。</p><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這次的東西用到好多沒看過的數學方法，不過還好不太深，還可以理解，但是僅僅能寫出陽春版的牛頓法，貌似還可以通過Hessian矩陣是否正定來判斷狀態?<br>待研究…</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95">https://zh.wikipedia.org/zh-tw/%E7%89%9B%E9%A1%BF%E6%B3%95</a><br><a href="https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization">https://en.wikipedia.org/wiki/Newton&#39;s_method_in_optimization</a><br><a href="https://en.wikipedia.org/wiki/Gradient">https://en.wikipedia.org/wiki/Gradient</a><br><a href="https://en.wikipedia.org/wiki/Hessian_matrix">https://en.wikipedia.org/wiki/Hessian_matrix</a><br><a href="https://zhuanlan.zhihu.com/p/46536960">https://zhuanlan.zhihu.com/p/46536960</a><br><a href="https://zhuanlan.zhihu.com/p/37524275">https://zhuanlan.zhihu.com/p/37524275</a><br><a href="https://www.zhihu.com/question/19723347">https://www.zhihu.com/question/19723347</a></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 可視化函數 2</title>
      <link href="/2021/02/27/python-%E5%8F%AF%E8%A6%96%E5%8C%96%E5%87%BD%E6%95%B8-2/"/>
      <url>/2021/02/27/python-%E5%8F%AF%E8%A6%96%E5%8C%96%E5%87%BD%E6%95%B8-2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>延續<a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">上一篇</a><br>昨天在研究牛頓法、擬牛頓法、梯度下降法，在學著將它們的迭代過程畫出來的過程學到了可視化函數的新東西，留點紀錄。</p><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><h2 id="等高線圖"><a href="#等高線圖" class="headerlink" title="等高線圖"></a>等高線圖</h2><hr><p>需要用到contour這個函數，先來最簡單的</p><p>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/g1ndgh4.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目標函數</span></span><br><span class="line">f = <span class="keyword">lambda</span> x, y: np.sin(x) * np.power(y ** <span class="number">2</span>, <span class="number">1.</span>/<span class="number">3.</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生數據點</span></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># x, y 標籤</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等高線圖</span></span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line"><span class="comment"># 寫出等高線的高度</span></span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><hr><h3 id="輪廓等高圖"><a href="#輪廓等高圖" class="headerlink" title="輪廓等高圖"></a>輪廓等高圖</h3><p>需要用到contourf。</p><p>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/tcksYG5.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只有這裡不一樣</span></span><br><span class="line">C = plt.contourf(X, Y, Z)</span><br></pre></td></tr></table></figure></p><p>如果需要的函數不支援np.array這種操作(例如:math的函數)，就需要自己一個一個展開X, Y<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = X * <span class="number">0</span> <span class="comment"># 一定要*0，強迫複製出一個新的array</span></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(X, Y):</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> xx , yy <span class="keyword">in</span> <span class="built_in">zip</span>(x, y):</span><br><span class="line">        Z[i][j] = f(xx, yy)</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.contour(X, Y, Z)</span><br></pre></td></tr></table></figure></p><hr><h3 id="三維平面等高線"><a href="#三維平面等高線" class="headerlink" title="三維平面等高線"></a>三維平面等高線</h3><p>結合上一次的3D函數，這次我們要在它下面畫出投影的等高線</p><p>$sin(\sqrt{x^2+y^2})$:<br><img src="https://imgur.com/3judVES.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x, y : np.sin(np.sqrt(x ** <span class="number">2</span> + y ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line">ax.view_init(<span class="number">45</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">256</span>)</span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line"></span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.plot_surface(X, Y, Z, rstride = <span class="number">1</span>, cstride = <span class="number">1</span>, cmap = <span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 與上篇相比多加了這行</span></span><br><span class="line"><span class="comment"># offset代表將圖投影到z軸某個座標，這裡選最小值，也就是地板</span></span><br><span class="line">ax.contour(X, Y, Z, offset = Z.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure></p><p>甚至可以畫出各面的投影<br><img src="https://imgur.com/YBTnBrG.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zdir代表投影到哪個座標</span></span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;z&#x27;</span>, offset = Z.<span class="built_in">min</span>())</span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;x&#x27;</span>, offset = X.<span class="built_in">min</span>())</span><br><span class="line">ax.contour(X, Y, Z, zdir = <span class="string">&#x27;y&#x27;</span>, offset = Y.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure></p><hr><p>$f(x, y) = cos(\sqrt{x^2 + y^2})$:<br><img src="https://imgur.com/WVvfsPA.png" alt=""></p><p>$f(x, y) = e^{-x^2-y^2}$<br><img src="https://imgur.com/wnoK6gK.png" alt=""></p><p>$f(x, y) = ln(x^2 + y^2)$<br><img src="https://imgur.com/jMIqq2L.png" alt=""></p><p>$f(x, y) = xe^{-x^2-y^2}$<br><img src="https://imgur.com/jbEBAtM.png" alt=""></p><p>$f(x, y) = sin(x) * y^{\frac{2}{3}}$<br><img src="https://imgur.com/k2zeTES.png" alt=""></p><hr><h2 id="向量場圖"><a href="#向量場圖" class="headerlink" title="向量場圖"></a>向量場圖</h2><p>最簡單的，每個點$(x,y)$都有向量$\vec{v}(x, y)$<br><img src="https://imgur.com/mBFfaeI.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">u, v = X, Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 畫出向量，第一對(X, Y)代表位置(x, y), 第二對(u, v)代表指向</span></span><br><span class="line">plt.quiver(X, Y, u, v)</span><br></pre></td></tr></table></figure></p><p>而應用在函數上，可以利用梯度函數numpy.gradient來設定向量方向，這樣就知道函數的大致走向。<br>$sin(x) \times y^{\frac{2}{3}}$:<br><img src="https://imgur.com/utYmC78.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x, y: np.sin(x) * np.power(y ** <span class="number">2</span>, <span class="number">1.</span>/<span class="number">3.</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">2</span>, <span class="number">2</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(X, Y)</span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度函數</span></span><br><span class="line"><span class="comment"># 不知道為甚麼向量方向要倒過來才能正確，可能跟gradient函數有關</span></span><br><span class="line">v, u = np.gradient(Z)</span><br><span class="line"></span><br><span class="line">plt.quiver(X, Y, u, v)</span><br><span class="line">C = plt.contour(X, Y, Z)</span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><hr><p>$f(x, y) = xe^{-x^2-y^2}$:<br><img src="https://imgur.com/qEQ8Lwl.png" alt=""></p><p>$f(x, y) = ln(x^2 + y^2)$<br><img src="https://imgur.com/2GmsvMu.png" alt=""></p><p>$f(x, y) = cos(\sqrt{x^2 + y^2})$:<br><img src="https://imgur.com/8yhOEGd.png" alt=""></p><hr><h3 id="三維向量場"><a href="#三維向量場" class="headerlink" title="三維向量場"></a>三維向量場</h3><p><img src="https://imgur.com/qlyxmAt.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line">ax.view_init(<span class="number">45</span>, <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">X = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">Y = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line">Z = np.linspace(-<span class="number">.8</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">X, Y, Z = np.meshgrid(X, Y, Z)</span><br><span class="line"></span><br><span class="line">u = np.sin(X) * np.cos(Y) </span><br><span class="line">v = -np.cos(X) * np.cos(Z)</span><br><span class="line">w = np.cos(Y) * np.sin(Z)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.quiver(X, Y, Z, u, v, w, length = <span class="number">.1</span>, normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>目前都是看什麼、需要什麼，然後才學什麼。總感覺很不扎實，希望上了大學可以有一系列連貫的學習路程。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.contour.html">https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.contour.html</a><br><a href="https://blog.csdn.net/lens___/article/details/83960810">https://blog.csdn.net/lens___/article/details/83960810</a><br><a href="https://www.itread01.com/content/1550129762.html">https://www.itread01.com/content/1550129762.html</a><br><a href="https://matplotlib.org/stable/gallery/mplot3d/contour3d_3.html">https://matplotlib.org/stable/gallery/mplot3d/contour3d_3.html</a><br><a href="https://oemiliatano.github.io/2020/04/22/3D-functions/">https://oemiliatano.github.io/2020/04/22/3D-functions/</a><br><a href="https://www.mathworks.com/help/matlab/ref/gradient.html">https://www.mathworks.com/help/matlab/ref/gradient.html</a><br><a href="https://www.pluvet.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8-python-%E4%B8%AD%E7%BB%98%E5%88%B6%E5%90%91%E9%87%8F%E5%9C%BA%EF%BC%88%E4%BD%BF%E7%94%A8-matplotlib%EF%BC%89/">https://www.pluvet.com/2020/04/10/%E5%A6%82%E4%BD%95%E5%9C%A8-python-%E4%B8%AD%E7%BB%98%E5%88%B6%E5%90%91%E9%87%8F%E5%9C%BA%EF%BC%88%E4%BD%BF%E7%94%A8-matplotlib%EF%BC%89/</a><br><a href="https://www.cnpython.com/qa/112014">https://www.cnpython.com/qa/112014</a><br><a href="https://sq.163yun.com/blog/article/236582359586304000">https://sq.163yun.com/blog/article/236582359586304000</a><br><a href="https://blog.csdn.net/qq_41856733/article/details/102677984">https://blog.csdn.net/qq_41856733/article/details/102677984</a><br><a href="https://numpy.org/doc/stable/reference/generated/numpy.gradient.html">https://numpy.org/doc/stable/reference/generated/numpy.gradient.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零零碎碎的發現</title>
      <link href="/2021/02/20/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%99%BC%E7%8F%BE/"/>
      <url>/2021/02/20/%E9%9B%B6%E9%9B%B6%E7%A2%8E%E7%A2%8E%E7%9A%84%E7%99%BC%E7%8F%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊會把很多個零碎的知識點集中，整體沒什麼連貫性，只是很有趣而已。</p><h1 id="主體"><a href="#主體" class="headerlink" title="主體"></a>主體</h1><h2 id="指對數-三角函數擴展到複數域"><a href="#指對數-三角函數擴展到複數域" class="headerlink" title="指對數, 三角函數擴展到複數域"></a>指對數, 三角函數擴展到複數域</h2><h3 id="對數"><a href="#對數" class="headerlink" title="對數:"></a>對數:</h3><p>根據歐拉公式$e^{i\theta} = (cos\theta + isin\theta)$，所有複數都可以用$re^{i\theta}$表達。<br>這就讓對數可以突破正實數的限制(0還是不行)，例如:</p><ul><li>$ln(-1) = ln(e^{i\pi}) = i\pi$</li><li>$ln(i) = ln(e^{i\frac{\pi}{2}}) = i\frac{\pi}{2}$</li></ul><h3 id="指數"><a href="#指數" class="headerlink" title="指數:"></a>指數:</h3><p>同樣的，根據歐拉公式，複數代入指數也能計算，$x^{ai+b} = e^{(ln x)(ai + b)}$。<br>以前一些看似無解的方程式也有解了，例如:</p><ul><li>$1^x = 2$, $x = \frac{ln(2)}{2n\pi i}$</li></ul><h3 id="三角函數"><a href="#三角函數" class="headerlink" title="三角函數:"></a>三角函數:</h3><p>這次需要用到泰勒展開，眾所周知，</p><ul><li>$e^x = 1 + \frac{x}{1!} + \frac{x^2}{2!}…$</li><li>$sin x = x - \frac{x^3}{3!} + \frac{x^5}{5!}…$</li></ul><p>將$e^x$改成$e^{ix}$及$e^{-ix}$，</p><ul><li>$e^{ix} = 1 + \frac{ix}{1!} - \frac{x^2}{2!} - \frac{ix^3}{3!}…$</li><li>$e^{-ix} = 1 - \frac{ix}{1!} - \frac{x^2}{2!} + \frac{ix^3}{3!}…$</li></ul><p>$e^{ix} - e^{-ix}$後會發現只要多除$2i$即是$sin x$<br>亦即，</p><ul><li>$sin x = \frac{e^{ix} - e^{-ix}}{2i}$</li></ul><p>$cos x$也可以用同樣的方法寫出來</p><ul><li>$cos x = \frac{e^{ix} + e^{-ix}}{2}$。</li></ul><p>當然也可以用歐拉公式推得，<br>$e^{ix} = (cos x + isin x)$</p><p>$e^{i(-x)} = (cos x - isin x)$</p><p>$e^{ix} - e^{i(-x)} = 2i sin x$</p><p>$\frac{e^{ix} - e^{i(-x)}}{2i} = sin x$</p><h2 id="實數階導數-積分"><a href="#實數階導數-積分" class="headerlink" title="實數階導數, 積分"></a>實數階導數, 積分</h2><p>沒看錯，繼階乘後，導數也可以有$\frac{1}{2}$階，或是$\pi$階，連積分都可以。<br>設一函數$f(x) = x^n$，則</p><ul><li>$k(k&lt;n)$階導數為$f^{(k)}(x) = \frac{n!}{(n-k)!}x^{(n-k)}$</li></ul><p>還記得階乘其實可以解析出去嗎?<br>將上式改寫成</p><ul><li>$f^{(k)}(x) = \frac{\Gamma(n+1)}{\Gamma(n-k+1)}x^{(n-k)}$<br>這下子就可以寫出$\frac{1}{2}$階導數了。</li></ul><p>例子:</p><ul><li>$f(x) = x$, $\frac{1}{2}$階導數是$\frac{\Gamma(2)}{\Gamma(\frac{3}{2})}x^{\frac{1}{2}} = \frac{2}{\sqrt{\pi}}x^{\frac{1}{2}}$</li></ul><p>當然，複數階導數也可以。</p><hr><p>積分的話，需要用到引理，在此不證明:</p><ul><li>$\int^t_a \int^y_a f(x, y)dx dy = \int^t_a \int^t_x f(x, y)dy dx$</li></ul><p>假設$I_2 = \int^{\alpha_3}_0 \int^{\alpha_2}_0 f(\alpha_1) d\alpha_1 d\alpha_2$<br><img src="https://imgur.com/YOa7ume.png" alt=""><br>(這邊的mathjax壞了只好用圖片代替)</p><p>繼續寫出$I_3$, $I_4$…<br>$I_3 = \int^{\alpha_4}_0 I_2 = \frac{1}{2} \int^{\alpha_4}_0 f(\alpha_1)(\alpha_4 - \alpha_1)^2 d\alpha_1$<br>$I_4 = \int^{\alpha_5}_0 I_3 = \frac{1}{6} \int^{\alpha_5}_0 f(\alpha_1)(\alpha_5 - \alpha_1)^3 d\alpha_1$</p><p>可以發現一規律，且可以用數學歸納法證明無誤</p><ul><li>$I_n = \frac{1}{(n-1)!} \int^{\alpha}_0 f(x) (\alpha-x)^{n-1} dx$</li></ul><p>又看到階乘了，直接換成$\Gamma$函數</p><ul><li>$I_n = \frac{1}{\Gamma(n)} \int^{\alpha}_0 f(x) (\alpha-x)^{n-1} dx$</li></ul><p>這下子我們就可以代實數進去了(複數也可以)。</p><h2 id="多變數泰勒展開式"><a href="#多變數泰勒展開式" class="headerlink" title="多變數泰勒展開式"></a>多變數泰勒展開式</h2><p>某一天在別人的blog看到這個詞，但是沒有點進去，而是開始自己試圖將單變數泰勒展開推導至多變數，所以不確定推導的正確性。</p><p>我自己對泰勒展開的推導是如此(簡化一點，一律只討論$x=0$附近):<br>假設某函數$f(x)$可以寫成多項式$a_0 + a_1x + a_2x^2 + a_3x^3 … a_nx^n = g(x)$，</p><p>我們也很直覺的知道當兩函數相等，$f^{(n)}(x) = g^{(n)}(x), n \in \mathbb{N}$</p><p>利用這點可以知道$a_0 = f(0)$, $a_1 = f’(0)$, $a_2 = \frac{f’’(0)}{2!}$, …, $a_n = \frac{f^{(n)}(0)}{n!}$</p><p>故$f(x) = f(0) + f’(0)x + \frac{f’’(0)}{2!}x^2 + … \frac{f^{(n)}(0)}{n!}x^n$</p><hr><p>現在推廣至多變數，理應也是利用類似$f^{(n)}(x) = g^{(n)}(x), n \in \mathbb{N}$的方法去定義。</p><p>假設某函數$f(x, y)$可以寫成多項式$c + a_1x + b_1y + a_2x^2 + b_2y^2 + a_3x^3 +b_3y^3 … a_nx^n b_ny^n = g(x, y)$，</p><p>可以知道$\frac{\partial f}{\partial x}(x, y) = \frac{\partial g}{\partial x}(x, y)$, $\frac{\partial f}{\partial y}(x, y) = \frac{\partial g}{\partial y}(x, y)$</p><p>$\frac{\partial^2 f}{\partial x^2}(x, y) = \frac{\partial^2 g}{\partial x^2}(x, y)$, $\frac{\partial^2 f}{\partial y^2}(x, y) = \frac{\partial^2 g}{\partial y^2}(x, y)$</p><p>接著就可以用剛剛的方法求各項係數，但是當我想展開$f(x,y) = xy$時，卻無法正確展開，所以我認為還需要多加上各變數的乘積，</p><p>$f(x, y) = d + a_1x + b_1y + c_{1,1}xy + a_2x^2 + b_2y^2 + c_{1, 2}xy^2 + c_{2, 1}x^2y + c_{2, 2}x^2y^2 …$</p><p>利用偏微分可以知道<br>$d = f(0, 0)$, $a_1 = \frac{\partial f}{\partial x}(0, 0)$, $b_1 = \frac{\partial f}{\partial y}(0, 0)$, $c_{1, 1} = \frac{\partial^2 f}{\partial x \partial y}(0, 0)$</p><p>$a_2 = \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}(x, y)$, $b_2 = \frac{1}{2!}\frac{\partial^2 f}{\partial y^2}(x, y)$</p><p>得$f(x, y) = f(0, 0) + \frac{\partial f}{\partial x}(0, 0)x + \frac{\partial f}{\partial y}(0, 0)y + \frac{\partial^2 f}{\partial x \partial y}(0, 0)xy + \frac{1}{2!}\frac{\partial^2 f}{\partial x^2}(x, y)x^2 + \frac{1}{2!}\frac{\partial^2 f}{\partial y^2}(x, y)y^2 …$</p><p>更多變數時也是一樣，但是我不知道要怎麼更簡潔的寫出來 (Q _ Q)</p><ul><li>2.27.21 更新<br>後來有想到可以用$\sum_{n=0}^{\infty} \sum_{a_1 + a_2 + … + a_k = n} \frac{1}{a_1! a_2! … a_k!} \frac{\partial^n f}{\partial x_{1}^{a_1} \partial x_{2}^{a_2} … \partial x_{k}^{a^k}}(0, …, 0)x_{1}^{a_1}x_{2}^{a_2}…x_{k}^{a^k}$</li></ul><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://en.wikipedia.org/wiki/Fractional_calculus">https://en.wikipedia.org/wiki/Fractional_calculus</a><br><a href="https://zhuanlan.zhihu.com/p/124627581">https://zhuanlan.zhihu.com/p/124627581</a><br><a href="https://en.wikipedia.org/wiki/Taylor%27s_theorem">https://en.wikipedia.org/wiki/Taylor%27s_theorem</a><br><a href="https://mathinsight.org/taylors_theorem_multivariable_introduction">https://mathinsight.org/taylors_theorem_multivariable_introduction</a><br><a href="https://sites.math.washington.edu/~folland/Math425/taylor2.pdf">https://sites.math.washington.edu/~folland/Math425/taylor2.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>曲線插值-三次樣條函數</title>
      <link href="/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/"/>
      <url>/2021/02/15/%E6%9B%B2%E7%B7%9A%E6%93%AC%E5%90%88-%E6%A8%A3%E6%A2%9D%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>學測前被人推坑過曲線插值，現在就來寫寫看。<br>被推坑的是<a href="http://mirlab.org/jang/books/matlabprogramming4guru/10-1_regressionLin4curveFitting.asp?title=10-1%20%BDu%A9%CA%B0j%C2k%A1G%A6%B1%BDu%C0%C0%A6X">多項式插值</a><br>但是這篇不是多項式，而是樣條函數。</p><hr><h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>跟多項式插值不一樣的點有</p><ul><li><p>用低次的樣條函數比較不會產生高次多項式函數的”亂流”，且效果不錯<br><img src="https://imgur.com/KIkT758.png" alt=""></p><blockquote><p>預測全球人口的多項式擬合，次數到8時會產生反常結果(source: <a href="http://mirlab.org/jang/books/matlabprogramming4guru/10-1_regressionLin4curveFitting.asp?title=10-1%20%BDu%A9%CA%B0j%C2k%A1G%A6%B1%BDu%C0%C0%A6X">10-1 線性迴歸：曲線擬合</a>)</p></blockquote></li><li><p>並非一個函數用到底，而是利用取樣點之間作分割，分成小區間，利用某些特性做連結，以達到光滑的目的<br><img src="https://imgur.com/n1fSqrR.png" alt=""></p><blockquote><p>上面是每個子區間都是次數=1的樣子，當然可以使用次數更高的函數</p></blockquote></li></ul><p>高中都學過「插值法」，用來算不在log表上的數字或是求多項式，而樣條插值是利用分段的函數，構成一個大函數，預測內插值。</p><p><img src="https://4.bp.blogspot.com/-Tw4BlGwhpQg/VSK_3PKjU8I/AAAAAAAAoEk/54rgZCaoxTk/s1600/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%2B2015-04-07%2B%E4%B8%8A%E5%8D%8812.49.48.png" alt=""></p><blockquote><p>線性樣條插值，最簡單的插值法，高中常用(source: <a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">三次樣條插值</a>)</p></blockquote><p>線性插值雖然簡單，但無法滿足工程上「光滑」的需求，於是三次樣條就誕生了，最高次數為三能確保不過度扭曲，又可以確保光滑。</p><hr><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>假設有一複雜函數$f(x)$(難以評估)，需要用簡單函數$s(x)$去逼近，我們現在有$n+1$個取樣點$x_0, x_1$…$x_n$，由此分割出$n$個子區間，<br>$x_0$, $x_1$中間的樣條函數為$s_1(x)$，$x_{i-1}$, $x_i$中間的樣條函數為$s_i(x)$，$i \in [1,n]$<br>那該如何求出$s_i(x) = q_i x^3 + r_i x^2 + s_i x + t_i$ ?<br>我們有以下條件:</p><ul><li>$s_i(x_i) = s_{i+1}(x_i)$</li><li>$s_i’(x_i) = s_{i+1}’(x_i)$</li><li>$s_i’’(x_i) = s_{i+1}’’(x_i)$<br>因為m=3，可知所有$s_i’’(x)$為同一直線，可寫出直線</li></ul><blockquote><p>$\frac{y-s_i’’(x_i)}{x-x_i}=\frac{s_i’’(x_{i-1})-s_i’’(x_i)}{x_{i-1}-x_i}$</p></blockquote><p>整理一下</p><blockquote><p>$s_i’’(x)=y=(s_i’’(x_{i-1})-s_i’’(x_i))\frac{x-x_i}{x_{i-1}-x_i}+s_i’’(x_i)$</p></blockquote><p>積分，這邊將$s_i’’(x_i)$寫成$m_i$($m_i$是對應到$x_i$的$i$，因為所有的$s_i’’(x)$都是同一條直線，如果是對應到$s_i$，$m_i$就不會有變化)</p><blockquote><p>$s_i’’(x) = (m_{i-1}-m_i)\frac{x-x_i}{x_{i-1}-x_i}+m_i$<br>$s_i’’(x) = \frac{x-x_i}{x_{i-1}-x_i}m_{i-1} + \frac{x_{i-1}-x}{x_{i-1}-x_i}m_i$<br>$s_i’(x) = \frac{(x-x_i)^2}{2(x_{i-1}-x_i)}m_{i-1}-\frac{(x_{i-1}-x)^2}{2(x_{i-1}-x_i)}m_i+C_1$<br>$s_i(x) = \frac{(x-x_i)^3}{6(x_{i-1}-x_i)}m_{i-1}+\frac{(x_{i-1}-x)^3}{6(x_{i-1}-x_i)}m_i+C_1x+C_2$</p></blockquote><p>現在要求$C_1$, $C_2$，將$s_i(x_i)$寫成$y_i$(同樣，是對應$x_i$)，過程略…</p><blockquote><p>$C_1 = \frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{x_i-x_{i-1}}{6}(m_i - m_{i-1})$<br>$C_2 = y_i-\frac{y_i-y_{i-1}}{x_i-x_{i-1}}x_i-\frac{x_{i-1}-x_i}{6}(m_ix_{i-1}-m_{i-1}x_i)$</p></blockquote><p>利用算好的$C_1$, $C_2$將$s_i(x)$寫完整</p><blockquote><p>$s_i(x)=\frac{(x-x_i)^3}{6(x_{i-1}-x_i)}m_{i-1}+\frac{(x_{i-1}-x)^3}{6(x_{i-1}-x_i)}m_i+ [\frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{x_i-x_{i-1}}{6}(m_i - m_{i-1})]x$<br>$+y_i-\frac{y_i-y_{i-1}}{x_i-x_{i-1}}x_i-\frac{x_{i-1}-x_i}{6}(m_ix_{i-1}-m_{i-1}x_i)$</p></blockquote><p>現在只有$m_i$需要求解，這時需要用$s_i’(x_i) = s_{i+1}’(x_i)$，注意這時是要先把$s_i(x)$跟$s_{i+1}(x)$寫出來再代$x_i$，不然容易搞混。<br>整理等式極為繁瑣，在此直接給出最後整理好的結果</p><blockquote><p>$\frac{6}{x_{i-1}-x_{i+1}}(\frac{y_i-y_{i-1}}{x_i-x_{i-1}}-\frac{y_{i+1}-y_i}{x_{i+1}-x_i}) = \frac{x_{i-1}-x_i}{x_{i-1}-x_{i+1}}m_{i-1} + 2m_i + \frac{x_i-x_{i+1}}{x_{i-1}-x{i+1}}m_{i+1}$</p></blockquote><p>代換一下，等下比較好寫</p><blockquote><p>$k_i = a_im_{i-1} + 2m_i + c_im_{i+1}$, $i \in [1, n-1]$ —(1)</p></blockquote><p>我們有$m_i$, $i \in [0,n]$共$n+1$個未知數要求解，但是上面只有$n-1$個方程式，剩下兩個需要從邊界條件中得到<br>邊界條件分三種:</p><ul><li>$s_1’(x_0)=f’(x_0)$, $s_n’(x_n)=f’(x_n)$</li><li>$s_1’’(x_0)=f’’(x_0)$, $s_n’’(x_n)=f’’(x_n)$</li><li>$s_1’(x_0)=s_n(x_n)$, $s_1’’(x_0)=s_n’’(x_n)$</li></ul><h2 id="邊界條件"><a href="#邊界條件" class="headerlink" title="邊界條件"></a>邊界條件</h2><p>邊界條件有許多種，每種都會對樣條函式產生不盡相同的影響。<br><img src="https://1.bp.blogspot.com/-OzV3YgFSP2Q/VSLTPL_3uKI/AAAAAAAAoFg/kyL15pyxTXY/s1600/26193013-20d427db372c4913b3337945008177a7.png" alt=""></p><blockquote><p>source: <a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">三次樣條插值</a></p></blockquote><ul><li>第一種:<br>先將$s_1’(x_0)$, $s_n’(x_n)$寫出來</li></ul><blockquote><p>$y_0’=f’(x_0)=s_1’(x_0)=\frac{x_0-x_1}{2}m_0-\frac{y_1-y_0}{x_1-x_0}-\frac{1}{6}(x_1-x_0)(m_1-m_0)$<br>$y_n’=f’(x_n)=s_n’(x_n)=-\frac{x_{n-1}-x_n}{2}m_n+\frac{y_n-y_{n-1}}{x_n-x_{n-1}}-\frac{1}{6}(x_n-x_{n-1})(m_n-m_{n-1})$</p><p>$y_0’+\frac{y_1-y_0}{x_1-x_0}=\frac{x_0-x_1}{2}m_0-\frac{1}{6}(x_1-x_0)(m_1-m_0)$<br>$y_n’-\frac{y_n-y_{n-1}}{x_n-x_{n-1}}=-\frac{x_{n-1}-x_n}{2}m_n-\frac{1}{6}(x_n-x_{n-1})(m_n-m_{n-1})$</p><p>$k_0=\frac{6}{x_0-x_1}(y_0’+\frac{y_1-y_0}{x_1-x_0})=2m_0+m_1$<br>$k_n=\frac{6}{x_{n-1}-x_n}(\frac{y_n-y_{n-1}}{x_n-x_{n-1}}-y_n’)=m_{n-1}+2m_n$</p></blockquote><p>利用那$n-1$個條件與算好的邊界條件寫出矩陣<br>$\begin{bmatrix} 2 &amp; 1 \\\ a_1 &amp; 2 &amp; c_1 &amp; \\\ &amp; a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; &amp; &amp; … \\\ &amp;  &amp;  &amp;  &amp;  &amp; 1 &amp; 2\end{bmatrix}\vec{m}=\vec{k}$<br>解矩陣的步驟就等下再寫。</p><ul><li>第二種:</li></ul><blockquote><p>$s_1’’(x_0)=f’’(x_0)=m_0$<br>$s_n’’(x_n)=f’’(x_n)=m_n$</p></blockquote><p>由上面的等式知</p><blockquote><p>$k_1-a_1m_0=+2m_1+c_1m_2$<br>$k_{n-1}-c_{n-1}m_n=a_{n-1}m_{n-2}+2m_{n-1}$</p></blockquote><p>寫出矩陣<br>$\begin{bmatrix} 2 &amp; c_1 \\\ a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; a_3 &amp; 2 &amp; c_3 &amp; \\\ &amp; &amp; &amp; … \\\ &amp;  &amp;  &amp;  &amp;  &amp; a_{n-1} &amp; 2\end{bmatrix}\vec{m}= \begin{bmatrix}k_1-a_1f’’(x_0) \\\ k2 \\\ … \\\ k_{n-1}-c_{n-1}f’’(x_n) \end{bmatrix}$<br>注意這裡的$\vec{m}$是$m_1$到$m_{n-1}$。</p><ul><li>第三種:</li></ul><blockquote><p>$s_1’(x_0)=s_n’(x_n)$<br>$s_1’’(x_0)=s_n’’(x_n)$</p></blockquote><p>由第二個等式可知</p><blockquote><p>$m_0 = m_n$</p></blockquote><p>現在我們只有$n$個未知數需要求解<br>由第一個等式，知</p><blockquote><p>$2(x_0-x_1+x_{n-1}-x_n)m_0+(x_0-x_1)m_1+(x_{n-1}-x_n)m_{n-1}=6(\frac{y_1-y_0}{x_1-x_0}+\frac{y_n-y_{n-1}}{x_n-x_{n-1}})$</p></blockquote><p>代換</p><blockquote><p>$a_0m_0+b_0m_1+c_0m_{n-1}=k_0$</p></blockquote><p>再由(1)得</p><blockquote><p>$k_{n-1}=a_{n-1}m_{n-2}+2m_{n-1}+c_{n-1}m_n$</p></blockquote><p>寫出矩陣<br>$\begin{bmatrix} a_0 &amp; b_0 &amp; &amp; … &amp; &amp; &amp; c_0 \\\ a_1 &amp; 2 &amp; c_1 &amp; \\\  &amp; a_2 &amp; 2 &amp; c_2 &amp; \\\ &amp; &amp; &amp; … \\\ c_{n-1} &amp;  &amp;  &amp; …  &amp;  &amp; a_{n-1} &amp; 2\end{bmatrix}\vec{m}=\vec{k}$<br>$\vec{m}$是從$0~n-1$，$\vec{k}$同理。</p><hr><h2 id="解方程"><a href="#解方程" class="headerlink" title="解方程"></a>解方程</h2><p>算出來的矩陣為$A$，寫出等式$A\vec{m}=\vec{k}$<br>將$A$拆解成$LU$矩陣，<br>$L = \begin{bmatrix} d_0 &amp; &amp; &amp; &amp; &amp; \\\ l_1 &amp; d_1 &amp; &amp; \\\  &amp; l_2 &amp; d_2 &amp; &amp; \\\ &amp; &amp; &amp; … \\\ &amp; &amp; &amp; &amp; l_n &amp; d_n\end{bmatrix}$<br>$U = \begin{bmatrix} 1 &amp; u_0 &amp; &amp; &amp;  \\\ &amp; 1 &amp; u_1 &amp; \\\ &amp; &amp; 1 &amp; u_2 &amp; \\\ &amp; &amp; &amp; … &amp; &amp; \\\ &amp; &amp; &amp; &amp; &amp; u_{n-1} \\\ &amp; &amp; &amp; &amp; &amp; 1 \end{bmatrix}$</p><p>根據使用的邊界條件不同而有所不同，而第一,二種步驟是相同的<br>先推出$d,l,u$的遞推關係，解出$\vec{w}$ ($U\vec{m}$)<br>在利用$U\vec{m}=\vec{w}$解出$\vec{m}$</p><ul><li>第一種:</li></ul><p>由$A=LU$可以觀察到</p><blockquote><p>$d_0=2,u_0=\frac{1}{2}$<br>$l_i=a_i$<br>$d_i=2-u_{i-1}l_i$<br>$u_i=\frac{c_i}{d_i}$</p></blockquote><p>由$L\vec{w}=\vec{k}$知</p><blockquote><p>$w_0=\frac{k_0}{d_0}$<br>$w_i=\frac{k_i-l_iw_{i-1}}{d_i}$</p></blockquote><p>再由$U\vec{m}=\vec{w}$得</p><blockquote><p>$m_n=w_n$<br>$m_i=w_i-u_im_{i+1}$</p></blockquote><ul><li>第二種:</li></ul><p>由$A=LU$可以觀察到</p><blockquote><p>$d_1=2$<br>$l_i=a_i$<br>$d_i=2-l_iu_{i-1}$<br>$u_i=\frac{c_i}{d_i}$</p></blockquote><p>由$L\vec{w}=\vec{k}$知</p><blockquote><p>$w_1=\frac{k_1}{d_1}$<br>$w_i=\frac{k_i-l_iw_{i-1}}{d_i}$</p></blockquote><p>再由$U\vec{m}=\vec{w}$得</p><blockquote><p>$m_n=w_n$<br>$m_i=w_i-u_im_{i+1}$</p></blockquote><ul><li>第三種:</li></ul><p>這個無法用上面的方法拆，只能用高斯$O(n^3)$求逆矩陣</p><p>現在有了具體的步驟就可以寫出程式了。<br>解第一二種矩陣的方法有個具體的名字: 追趕法，不多介紹，畢竟不是主角。</p><hr><h1 id="code"><a href="#code" class="headerlink" title="code:"></a>code:</h1><p>(目前只有第一,二種邊界條件)</p><ul><li><p>目標函數:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">exp</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">df</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">10e-8</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(<span class="built_in">f</span>(x + dx)) || <span class="built_in">isinf</span>(<span class="built_in">f</span>(x + dx)))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">f</span>(x) - <span class="built_in">f</span>(x - dx)) / dx;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">f</span>(x + dx) - <span class="built_in">f</span>(x)) / dx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">ddf</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx = <span class="number">10e-8</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isnan</span>(<span class="built_in">df</span>(x + dx)) || <span class="built_in">isinf</span>(<span class="built_in">df</span>(x + dx)))</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">df</span>(x) - <span class="built_in">df</span>(x - dx)) / dx;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">df</span>(x + dx) - <span class="built_in">df</span>(x)) / dx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>採樣點, 邊界類型設定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> datSeed = <span class="number">1</span>, datStep = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> dataCnt = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> st = datSeed, ed = datSeed + ((<span class="type">double</span>)dataCnt - <span class="number">1.0</span>) * datStep, step = <span class="number">0.001</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> Type = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setSample</span><span class="params">(vector&lt;<span class="type">double</span>&gt;&amp; v, vector&lt;<span class="type">double</span>&gt;&amp; u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>(); u.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x = datSeed;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dataCnt; x += datStep, ++i)</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(x), u.<span class="built_in">emplace_back</span>(<span class="built_in">f</span>(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>矩陣A, 向量k的設定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType1_SetMat</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[<span class="number">0</span>] = <span class="number">6</span> * (SampleY[<span class="number">1</span>] - SampleY[<span class="number">0</span>] - <span class="built_in">df</span>(SampleX[<span class="number">0</span>])) / (g[<span class="number">1</span>] * g[<span class="number">1</span>]);</span><br><span class="line">    k[SampleN] = <span class="number">6</span> * ((SampleY[SampleN - <span class="number">1</span>] - SampleY[SampleN]) / g[SampleN] - <span class="built_in">df</span>(SampleX[SampleN])) / g[SampleN];</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SampleN + <span class="number">1</span>; ++i)</span><br><span class="line">        A[i].<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][i - <span class="number">1</span>] = g[i] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">        A[i][i] = <span class="number">2</span>;</span><br><span class="line">        A[i][i + <span class="number">1</span>] = g[i + <span class="number">1</span>] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">2</span>, A[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, A[SampleN][SampleN] = <span class="number">2</span>, A[SampleN][SampleN - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType2_SetMat</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k[<span class="number">1</span>] -= (SampleX[<span class="number">0</span>] - SampleX[<span class="number">1</span>]) * <span class="built_in">ddf</span>(SampleX[<span class="number">0</span>]) / (SampleX[<span class="number">0</span>] - SampleX[<span class="number">2</span>]);</span><br><span class="line">    k[SampleN - <span class="number">1</span>] -= (SampleX[SampleN - <span class="number">1</span>] - SampleX[SampleN]) * <span class="built_in">ddf</span>(SampleX[SampleN]) / (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN]);</span><br><span class="line"></span><br><span class="line">    A.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SampleN + <span class="number">1</span>; ++i)</span><br><span class="line">        A[i].<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; SampleN - <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        A[i][i - <span class="number">1</span>] = g[i] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">        A[i][i] = <span class="number">2</span>;</span><br><span class="line">        A[i][i + <span class="number">1</span>] = g[i + <span class="number">1</span>] / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span>, A[<span class="number">1</span>][<span class="number">2</span>] = (SampleX[<span class="number">1</span>] - SampleX[<span class="number">2</span>]) / (SampleX[<span class="number">0</span>] - SampleX[<span class="number">2</span>]);</span><br><span class="line">    A[SampleN - <span class="number">1</span>][SampleN - <span class="number">1</span>] = <span class="number">2</span>, A[SampleN - <span class="number">1</span>][SampleN - <span class="number">2</span>] = (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN - <span class="number">1</span>]) / (SampleX[SampleN - <span class="number">2</span>] - SampleX[SampleN]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解矩陣</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType1</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; m, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; l, d, u, w;</span><br><span class="line">    l.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); d.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); u.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>), w.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">0</span>], u[<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">1</span>] / d[<span class="number">0</span>], w[<span class="number">0</span>] = k[<span class="number">0</span>] / d[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = A[i][i - <span class="number">1</span>];</span><br><span class="line">        d[i] = A[i][i] - l[i] * u[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; SampleN)</span><br><span class="line">            u[i] = A[i][i + <span class="number">1</span>] / d[i];</span><br><span class="line">        w[i] = (k[i] - l[i] * w[i - <span class="number">1</span>]) / d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[SampleN] = w[SampleN];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = SampleN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i] = w[i] - m[i + <span class="number">1</span>] * u[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bondType2</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt;&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; m, vector&lt;<span class="type">double</span>&gt;&amp; k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; l, d, u, w;</span><br><span class="line">    l.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); d.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>); u.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>), w.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">2</span>, u[<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">2</span>] / d[<span class="number">1</span>], w[<span class="number">1</span>] = k[<span class="number">1</span>] / d[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; SampleN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = A[i][i - <span class="number">1</span>];</span><br><span class="line">        d[i] = <span class="number">2</span> - l[i] * u[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; SampleN - <span class="number">1</span>)</span><br><span class="line">            u[i] = A[i][i + <span class="number">1</span>] / d[i];</span><br><span class="line">        w[i] = (k[i] - l[i] * w[i - <span class="number">1</span>]) / d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m[SampleN - <span class="number">1</span>] = w[SampleN - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = SampleN - <span class="number">2</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i] = w[i] - m[i + <span class="number">1</span>] * u[i];</span><br><span class="line">    &#125;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="built_in">ddf</span>(SampleX[<span class="number">0</span>]);</span><br><span class="line">    m[SampleN] = <span class="built_in">ddf</span>(SampleX[SampleN]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>樣條函數</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">s</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((x &lt; SampleX[<span class="number">0</span>]) || (x &gt; *SampleX.<span class="built_in">rbegin</span>()))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt; SampleX[i]) ++i;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    res = (x - SampleX[i]) * (x - SampleX[i]) * (x - SampleX[i]) * m[i - <span class="number">1</span>] + (SampleX[i - <span class="number">1</span>] - x) * (SampleX[i - <span class="number">1</span>] - x) * (SampleX[i - <span class="number">1</span>] - x) * m[i];</span><br><span class="line">    res /= (<span class="number">6</span> * g[i]);</span><br><span class="line">    res += ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + g[i] * (m[i] - m[i - <span class="number">1</span>]) / <span class="number">6</span>) * x;</span><br><span class="line">    res += SampleY[i] - (g[i] * g[i] * m[i]) / <span class="number">6</span> - ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + (m[i] - m[i - <span class="number">1</span>]) * g[i] / <span class="number">6</span>) * SampleX[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主函式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">setSample</span>(SampleX, SampleY);</span><br><span class="line"></span><br><span class="line">    SampleN = SampleX.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    g.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= SampleN; ++i)</span><br><span class="line">        g[i] = SampleX[i - <span class="number">1</span>] - SampleX[i];</span><br><span class="line"></span><br><span class="line">    k.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; SampleN; ++i)</span><br><span class="line">        k[i] = ((SampleY[i - <span class="number">1</span>] - SampleY[i]) / g[i] + (SampleY[i + <span class="number">1</span>] - SampleY[i]) / g[i + <span class="number">1</span>]) * <span class="number">6</span> / (g[i] + g[i + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    m.<span class="built_in">resize</span>(SampleN + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bondType1_SetMat</span>(A, k);</span><br><span class="line">        <span class="built_in">bondType1</span>(A, m, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Type == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bondType2_SetMat</span>(A, k);</span><br><span class="line">        <span class="built_in">bondType2</span>(A, m, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fstream fs;</span><br><span class="line">    fs.<span class="built_in">open</span>(<span class="string">&quot;function.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> x = st; x &lt;= ed; x += step)</span><br><span class="line">    &#123;</span><br><span class="line">        fs &lt;&lt; <span class="built_in">f</span>(x) &lt;&lt; endl;</span><br><span class="line">        fs &lt;&lt; <span class="built_in">s</span>(x) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ed &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函式可視化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;function.txt&quot;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">1</span>, <span class="number">10.9</span>, <span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">a = []</span><br><span class="line">b = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> x:</span><br><span class="line">    s = f.readline()</span><br><span class="line">    a.append(<span class="built_in">float</span>(s.strip()))</span><br><span class="line">    s = f.readline()</span><br><span class="line">    b.append(<span class="built_in">float</span>(s.strip()))</span><br><span class="line"></span><br><span class="line">y1 = np.array(a) <span class="comment"># real blue</span></span><br><span class="line"><span class="comment">#print(y1)</span></span><br><span class="line">y2 = np.array(b) <span class="comment"># predict orange</span></span><br><span class="line"><span class="comment">#print(y2)</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2)</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>花了兩天的時間終於結束整個推導過程跟code debug，原本以為會很簡單，沒想到過程的推導繁瑣至極…這大概是有史以來寫過最長的一篇文了。</p><p>樣條函數的擬合效果挺不錯的，只要約6, 7個採樣點就可以很好的擬合出原本的函數，只是在某些一些點無法微分的函數擬合效果不是很好，只能增加採樣點。<br>(紅色是目標函數, 綠色是第一種邊界條件, 藍色是第二種)</p><p><img src="https://imgur.com/hytXkXP.png" alt=""></p><blockquote><p>$e^x$, <code>datSeed = 1, datStep = 1, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/WlSwGnm.png" alt=""></p><blockquote><p>$\frac{3}{x^2}$, <code>datSeed = 1, datStep = 1, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/UoE0L3D.png" alt=""></p><blockquote><p>$\frac{3}{x^2}$, <code>datSeed = 1, datStep = 0.1, dataCnt = 50</code></p></blockquote><p><img src="https://imgur.com/fPh6bwY.png" alt=""></p><blockquote><p>$sin(cos(x))$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/Ky3TnK4.png" alt=""></p><blockquote><p>$sin(\sqrt{x})$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/F9CBySG.png" alt=""></p><blockquote><p>$|x - 1.5| \times e^{sin(|-0.1x|)}$, <code>datSeed = 1, datStep = 0.3, dataCnt = 7</code></p></blockquote><p><img src="https://imgur.com/80opHHs.png" alt=""></p><blockquote><p>$\frac{1}{1 + 25x^2}$, <code>datSeed = -1, datStep = 0.4, dataCnt = 6</code></p></blockquote><p><img src="https://imgur.com/LZp794H.png" alt=""></p><blockquote><p>$\frac{1}{1 + 25x^2}$, <code>datSeed = -1, datStep = 0.1, dataCnt = 21</code></p></blockquote><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://zhuanlan.zhihu.com/p/62860859">https://zhuanlan.zhihu.com/p/62860859</a><br><a href="https://zh.wikipedia.org/zh-tw/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0">https://zh.wikipedia.org/zh-tw/%E6%A0%B7%E6%9D%A1%E5%87%BD%E6%95%B0</a><br><a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC">https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC</a><br><a href="https://zh.wikipedia.org/wiki/%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1">https://zh.wikipedia.org/wiki/%E9%BE%99%E6%A0%BC%E7%8E%B0%E8%B1%A1</a><br><a href="https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html">https://mropengate.blogspot.com/2015/04/cubic-spline-interpolation.html</a><br><a href="http://math.ecnu.edu.cn/~jypan/Teaching/NA/ch02e.pdf">http://math.ecnu.edu.cn/~jypan/Teaching/NA/ch02e.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>階乘推導至Gamma函數</title>
      <link href="/2020/12/31/%E8%A7%A3%E6%9E%90%E7%A0%94%E6%8B%93-%E9%9A%8E%E4%B9%98/"/>
      <url>/2020/12/31/%E8%A7%A3%E6%9E%90%E7%A0%94%E6%8B%93-%E9%9A%8E%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在2020的最後一天完成這件事，剩下的留待明年吧…</p><p>在知道有解析研拓這種東西後，我試著把一些高中的函數展開，比如log, sin, cos, exponential，但是階乘這個常見的東西卻困擾著我，到底要怎麼展開。</p><hr><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>首先考慮這個函數: $f(k,m)=\int_0^1 x^k (1-x)^m dx$，為甚麼需要這個函數呢? 當我們對它分部積分後會得到</p><blockquote><p>$f(k,m) = \frac{m}{k+1}f(k+1,m-1)$</p></blockquote><p>這樣一個遞迴式。<br>把它展開後會得到$f(k,m)=\frac{m!}{\prod_{i=1}^{m+1}(k+i)}$，移項得到$f(k,m)\prod_{i=1}^{m+1}(k+i)=m!$<br>這算是階乘展開的第一步，雖然這個形式還只能代正整數。<br>我們繼續把它展開，無法代除了正整數以外是因為這部分$\prod_{i=1}^{m+1}(k+i)$，如果可以把它消掉或許可以成功拓展。<br>令$k=\frac{a}{b}$，整理上面的公式得，</p><blockquote><p>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \frac{m!}{\prod_{i=1}^{m+1}(\frac{a}{b}+i)}$<br>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \frac{m!b^{m+1}}{\prod_{i=1}^{m+1}(a+ib)}$</p></blockquote><p>如果取極限$a \to 1$, $b \to 0$，右邊式子的分數就會消掉，但是上面的$b^{m+1}$很礙事，既然解決不了問題，就解決造成問題的東西，<br>先把$b^{m+1}$弄去左邊，再取極限</p><blockquote><p>$\lim_{a \to 1} lim_{b \to 0} b^{-(m+1)}\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = m!$</p></blockquote><p>現在我們focus在積分上，我們期望把積分裡面的$x^{\frac{a}{b}}$去掉，令$x=k^c$, $dx = ck^{c-1}dk$</p><blockquote><p>$\int_0^1 x^{\frac{a}{b}} (1-x)^m dx = \int_0^1 k^{\frac{ac}{b}} (1-k^c)^m ck^{c-1} dk$</p></blockquote><p>要把$x^{\frac{a}{b}}$(也就是$k^{\frac{ac}{b}}$)，必須使$\frac{ac}{b}+c-1=0$，解出$c=\frac{b}{a+b}$。<br>將上面的極限式換掉</p><blockquote><p>$\lim_{a \to 1} lim_{b \to 0} b^{-(m+1)}\int_0^1 \frac{b}{a+b}{(1-k^{\frac{b}{a+b}})}^m dk = m!$<br>$\lim_{a \to 1} lim_{b \to 0} (a+b)^{-(m+1)}\int_0^1 ({\frac{1-k^{\frac{b}{a+b}}}{\frac{b}{a+b}}})^m dk = m!$<br>$lim_{b \to 0} (1+b)^{-(m+1)}\int_0^1 ({\frac{1-k^{\frac{b}{1+b}}}{\frac{b}{1+b}}})^m dk = m!$<br>$\int_0^1 lim_{b \to 0} ({\frac{1-k^{\frac{b}{1+b}}}{\frac{b}{1+b}}})^m dk = m!$</p></blockquote><p>考慮一極限$lim_{x \to 0} \frac{1-k^x}{x}$，根據那個好用到不行的法則，得到$lim_{x \to 0} \frac{1-k^x}{x} = -ln k$。</p><blockquote><p>$\int_0^1 (-ln k)^m dk = m!$</p></blockquote><p>令$k=e^{-t}$, $dk = -e^{-t}dt$</p><blockquote><p>$\int_{\infty}^0 -t^m e^{-t} dt = m!$<br>$\int_0^{\infty} t^m e^{-t} dt = m!$</p></blockquote><p>至此，我們可以代入奇怪的數進階乘了d(`･∀･)b<br>甚至可以對$e^{-t}$泰勒展開，拓展到複數域。</p><p>小常識: 階乘其實有很多種解析方式，每種都會產生不同的函數，這只是其中一種，也是實務上使用最多的一種，因為可以連結到Gamma function: $\Gamma(x) = (x-1)!$</p><hr><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.cust.edu.tw/mathmet/graph/gamma-prop.htm">http://www.cust.edu.tw/mathmet/graph/gamma-prop.htm</a><br><a href="https://cosx.org/2013/01/lda-math-gamma-function/">https://cosx.org/2013/01/lda-math-gamma-function/</a><br><a href="https://zhuanlan.zhihu.com/p/114041258">https://zhuanlan.zhihu.com/p/114041258</a><br><a href="https://www.csie.ntu.edu.tw/~b89089/link/gammaFunction.pdf">https://www.csie.ntu.edu.tw/~b89089/link/gammaFunction.pdf</a><br><a href="https://kknews.cc/zh-tw/education/vlkv53a.html">https://kknews.cc/zh-tw/education/vlkv53a.html</a><br><a href="http://sgpwe.izt.uam.mx/files/users/uami/jdf/proyectos/Euler_integral.pdf">http://sgpwe.izt.uam.mx/files/users/uami/jdf/proyectos/Euler_integral.pdf</a></p><hr><p>新年新希望: 數學15級, 英文15級, 自然15級, 研究Gamma function, 補完vpython, 共形映射的文章, 學好abstract algebra, linear algebra, real/complex analysis</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>隱藏在碰撞的$\pi$</title>
      <link href="/2020/11/05/%E9%9A%B1%E8%97%8F%E5%9C%A8%E7%A2%B0%E6%92%9E%E7%9A%84%E7%9A%84pi/"/>
      <url>/2020/11/05/%E9%9A%B1%E8%97%8F%E5%9C%A8%E7%A2%B0%E6%92%9E%E7%9A%84%E7%9A%84pi/</url>
      
        <content type="html"><![CDATA[<p>在3blue1brown的頻道看了<a href="https://www.youtube.com/watch?v=HEfHFsfGXjs">https://www.youtube.com/watch?v=HEfHFsfGXjs</a> ，覺得這個超有趣的，分享一下。</p><p>在無摩擦力的環境中，有一面質量無限大，並且不會吸收任何能量的牆，以及兩個方塊。</p><p><img src="https://i.imgur.com/3VLfZSR.png" alt=""></p><p>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的1倍，整個系統的碰撞數為3。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的100倍，整個系統的碰撞數為31。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的10000倍，整個系統的碰撞數為314。<br>當最右邊的方塊以速度$V$往左移動，且質量為左邊方塊的1000000倍，整個系統的碰撞數為3141。</p><p>當最右邊的方塊($m_2$)以速度$V$往左移動，且左邊方塊質量為$m_1$，求這個系統的總碰撞次數?</p><hr><p>可以寫出動能守恆與動量守恆兩個式子:</p><blockquote><p>$\frac{1}{2}m_1v_1^2 + \frac{1}{2}m_2v_2^2 = k$<br>$m_1v_1 + m_2v_2 = p$</p></blockquote><p>有上面的提示，我們可以對號入座一下，把動能守恆的式子改寫成圓方程式:<br>$(\sqrt{m_1}v_1)^2 + (\sqrt{m_2}v_2)^2 = 2k$<br>這就是在兩軸分別代表$\sqrt{m_1}v_1$, $\sqrt{m_2}v_2$時的圓方程式。<br><img src="https://i.imgur.com/k6P7aMd.png" alt=""></p><p>初始點很顯然在最下方(定義向左的速度為負)，<br><img src="https://i.imgur.com/bJlookq.png" alt=""><br>經過一次碰撞後，點會往上升一點，且往左一點，並因為遵守動能守恆而會在圓上。<br><img src="https://i.imgur.com/8uUl1Sb.png" alt=""><br>經過許多碰撞後，最終$v1$會與$v2$同方向(&gt;0)，且小於$v2$。<br><img src="https://i.imgur.com/O47tW36.png" alt=""></p><p>進入下一步前，我們得先了解那條紅色的線是怎麼來的。<br>還記得動量守恆嗎? 我們可以將其改寫:<br>$\sqrt{m_1}(\sqrt{m_1}v_1) + \sqrt{m_2}(\sqrt{m_2}v_2) = p$<br>這樣在軸上實際代表一條斜率為$-\sqrt{\frac{m_1}{m_2}}$的直線，而每次左方塊與右方塊碰撞時，必遵守這個式子，也就是說點必在此直線上。($p$會因為左方塊與牆壁的碰撞而改變)<br>那麼圓與直線的交點即為碰撞後的位置。<br>至於中間幾條與$x$軸平行的是左方塊與牆壁的碰撞。</p><p>因為斜率一樣，且中間的線平行$x$軸，可以很清楚的確定這些角度$\theta$一樣。<br><img src="https://i.imgur.com/KHe8xfU.png" alt=""></p><p>而這樣問題就變成了</p><blockquote><p>$n\theta &lt; \pi$，問最大的$n$為何，$n \in N$。</p></blockquote><p>對於$\theta$我們可以從斜率著手，$tan \theta = \sqrt{\frac{m_1}{m_2}}$<br><img src="https://i.imgur.com/EKO11c5.png" alt=""><br>取$tan^{-1}$後，$\theta = tan^{-1} \sqrt{\frac{m_1}{m_2}}$<br>設$Tm_1 = m_2$，$\theta = tan^{-1} \sqrt{\frac{1}{T}}$<br>問題變成:<br>$n &lt; \frac{\pi}{tan^{-1} \sqrt{\frac{1}{T}}}$</p><p>對於$tan^{-1}$有個性質，$tan^{-1} 10^{-x}$約等於$10^{-x}$，$x$越大，這個性質越明顯。<br>故如果$T$為$10^x$則可以換成<br>$n &lt; \frac{\pi}{tan^{-1} 10^{-\frac{x}{2}}}$<br>$n &lt; \frac{\pi}{10^{-\frac{x}{2}}}$<br>$n &lt; 10^{\frac{x}{2}}\pi$<br>答案為:</p><blockquote><p>$n = \lfloor 10^{\frac{x}{2}}\pi \rfloor$</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高維球體體積推導</title>
      <link href="/2020/11/04/%E9%AB%98%E7%B6%AD%E7%90%83%E9%AB%94%E9%AB%94%E7%A9%8D%E6%8E%A8%E5%B0%8E/"/>
      <url>/2020/11/04/%E9%AB%98%E7%B6%AD%E7%90%83%E9%AB%94%E9%AB%94%E7%A9%8D%E6%8E%A8%E5%B0%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>來完結<a href="https://oemiliatano.github.io/2020/05/08/%E5%9B%9B%E7%B6%AD%E6%94%B6%E7%B4%8D%E7%AE%B1/">以前</a> 的心願。(((o(ﾟ▽ﾟ)o)))</p><h1 id="推導"><a href="#推導" class="headerlink" title="推導"></a>推導</h1><p>首先可以先從2維到3維推導，根據常識，可以知道3維體積就是無限多個2維面積的總和。<br>也就是說將無限多個2維球面積加起來，就是3維體積，這同時也是切片法的概念。<br>同樣的道理，將3維球體體積加起來，即是4維球體體積。</p><ul><li>3維球體體積推導:</li></ul><p>$x^2+y^2+z^2=r^2$，因為我們需要知道2維切面的半徑，所以先將$z^2$(或任意軸)搬過去，<br>$x^2+y^2=r^2-z^2=R^2$，現在只要在z軸上走動，就可以知道這個2維切面的半徑為何。<br>現在我們來積分，$V_3 = 2\int_{0}^{r} \pi R^2 dz = 2\pi \int_{0}^{r} r^2-z^2 dz$。<br>反導函數即為$r^2 z - \frac{1}{3} z^3$，則$V_3 = \frac{4}{3}r^3\pi$</p><ul><li>4維球體體積推導:</li></ul><p>$x^2+y^2+z^2+k^2=r^2$，同樣的把戲，$x^2+y^2+z^2=r^2-k^2=R^2$<br>$V_4 = 2\int_{0}{r} \pi \frac{4}{3}R^3 dk$，因為$(r^2-k^2)^{\frac{1}{2}} = R$,<br>$\frac{8}{3}\pi \int_{0}^{r} (r^2 - k^2)^{\frac{3}{2}} dk$，這裡需要用到變數代換了，不然根本沒辦法做。<br>$k = r (sinu)$,$dk = r (cosu) du$，換完變成<br>$\frac{8}{3}\pi \int_{0}^{\frac{\pi}{2}} (r^2 - r^2sin^2u)^{\frac{3}{2}} r(cosu) du$<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} cos^4u du$<br>這邊需要用到$cos2u = 2cos^2u - 1$?<br>兩邊平方，$cos^2 2u = 4cos^4u - 4cos^2u + 1$,$cos^4u = \frac{1}{4}cos^2 2u + cos^2u - \frac{1}{4}$。<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} \frac{1}{4}cos^2 2u + cos^2u - \frac{1}{4} du$，同樣利用上面的公式再換一下，<br>$\frac{8}{3}\pi r^4 \int_{0}{\frac{\pi}{2}} \frac{1}{8}cos 4u + \frac{1}{2}cos 2u + \frac{3}{8} du$，反導函數為$\frac{1}{32}sin4u+\frac{1}{4}sin2u+\frac{3}{8}u$<br>最終得到$V_4 = \frac{1}{2} \pi^2 r^4$</p><ul><li>5維球體體積推導:</li></ul><p>$x^2+y^2+z^2+k^2+l^2=r^2$,$x^2+y^2+z^2+k^2=r^2-l^2=R^2$<br>依樣畫葫蘆，$2\int_{0}^{r} \frac{1}{2} \pi^2 r^4$，得到$\frac{8}{15} \pi^2 r^5$</p><ul><li>n維球體體積推導:</li></ul><p>利用以上的方法將2~10維的體積全列出來</p><p>2: $r^2 \pi$<br>3: $\frac{4}{3} r^3 \pi$<br>4: $\frac{1}{2} r^4 \pi^2$<br>5: $\frac{8}{15} r^5 \pi^2$<br>6: $\frac{1}{6} r^6 \pi^3$<br>7: $\frac{16}{105} r^7 \pi^3$<br>8: $\frac{1}{24} r^8 \pi^4$<br>9: $\frac{32}{945} r^9 \pi^4$<br>10:$\frac{1}{120} r^{10} \pi^5$</p><p>可以發現$\pi$的次方一直都是$\lfloor \frac{n}{2} \rfloor$，以及$r$的次方為$n$</p><p>進一步分成偶數與奇數的話，前面的分數就會有某種規律可循，偶數為$\frac{1}{\frac{n}{2}!}$，而奇數為$\frac{2^{\lceil \frac{n}{2} \rceil}}{\prod_{i=1}^{\frac{n-1}{2}} (2i+1)}$<br>故可以整理出通式:</p><p>when n is odd,<br>$V_n = \frac{2^{\lceil \frac{n}{2} \rceil}}{\prod_{i=1}^{\frac{n-1}{2}} (2i+1)} r^n \pi^{\lfloor \frac{n}{2} \rfloor}$<br>else<br>$V_n = \frac{1}{\frac{n}{2}!} r^n \pi^{\lfloor \frac{n}{2} \rfloor}$</p><p>補充: 在上面的推導中寫道 $V_3 = 2\int_{0}^{r} \pi R^2 dz$，可以想像為一個圓形乘上z軸上一個小小的高，同樣的想法也可以適用於高維度空間。</p><p>補充: 球面積是體積的微分(對r)，可以自己想想看為什麼。</p><h1 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h1><p>這個問題算是我想了很久才想出來的，一般高中教材是用旋轉法來計算球體積，但是這個方法拓展到高維，我就不知道怎麼做了，要繞哪一軸旋轉? 轉什麼?<br>既然常用的推不出去，只好從最基礎的定義去推導，才能推廣到高維。<br>思考的過程很有趣，故留筆此篇。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指數與對數函數交點個數</title>
      <link href="/2020/11/04/%E6%8C%87%E6%95%B8%E8%88%87%E5%B0%8D%E6%95%B8%E5%87%BD%E6%95%B8%E4%BA%A4%E9%BB%9E%E5%80%8B%E6%95%B8/"/>
      <url>/2020/11/04/%E6%8C%87%E6%95%B8%E8%88%87%E5%B0%8D%E6%95%B8%E5%87%BD%E6%95%B8%E4%BA%A4%E9%BB%9E%E5%80%8B%E6%95%B8/</url>
      
        <content type="html"><![CDATA[<p>$log_a x$與$a^x$只有一個交點，請問$a$為多少?</p><ol><li>先考慮$a&gt;1$</li></ol><p><img src="https://i.imgur.com/iyOXXc3.png" alt=""></p><blockquote><p>$a=e，無交點$</p></blockquote><p><img src="https://i.imgur.com/JXpQjxK.png" alt=""></p><blockquote><p>$a=1.44，兩交點$</p></blockquote><p>首先，我們知道$log_a x$與$a^x$對稱於$x=y$直線，那麼如果只有一交點，則交點必在其($x=y$)上。<br>假設交點為$(k, k)$，而因為$x=y$是$log_a x$的切線，故$log_a x$在$x=k$的斜率為1，而$a^x$也是。<br>將$log_a x$微分後得到$\frac{1}{xlna}$，當$x=\frac{1}{lna}$時，斜率才為1。<br>將$a^x$微分後得$a^x ln a$，將$x=\frac{1}{ln a}$代進去，整理一下會寫出$eln a = 1$，套進上面的$\frac{1}{ln a}$後得到$x = e$<br>則$a^e = e$，$a = \sqrt[e]{e}$，大約是1.44。</p><p>也就是說當$1 &lt; a \leq \sqrt[e]{e}$時，才會有一個或一個以上交點存在。</p><ol><li>考慮$a&lt;1$</li></ol><p><img src="https://i.imgur.com/rUquHBE.png" alt=""></p><blockquote><p>$a=0.066$，恰一交點</p></blockquote><p><img src="https://i.imgur.com/HX6w2Ig.png" alt=""></p><blockquote><p>$a=0.022$，恰三交點</p></blockquote><p>可知道恰一交點時，$log_a x$與$a^x$的交點之切線斜率為-1。<br>利用微分故技重施，$\frac{1}{xln a}$，當$x=-\frac{1}{ln a}$時，斜率才為-1。<br>$a^x ln a$，將上面的$x$帶進去，得到$e^{-1}ln a = -1$，套進上面的$\frac{1}{ln a}$得到$x=\frac{1}{e}$，因為必交於$x=y$上，故$y = \frac{1}{e}$。<br>則$a=e^{-e}$，約為0.0659。</p><p>也就是說當$e^{-e} \leq a &lt; 1$，只會有一交點。 而當$0 &lt; a &lt; e^{-e}$，則會有三個交點。</p><p>綜上所述，可以整理出規則:<br>$a \in (0,e^{-e})$時，有三個交點。<br>$a \in [e^{-e}, 1)$時，有一個交點。<br>$a \in (1, \sqrt[e]{e})$，有兩個交點。<br>$a = \sqrt[e]{e}$，有一個交點。<br>$a \in (\sqrt[e]{e}, \infty)$，有零個交點。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從零開始的微積分 Integral 1</title>
      <link href="/2020/08/13/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Integral-1/"/>
      <url>/2020/08/13/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Integral-1/</url>
      
        <content type="html"><![CDATA[<p>一個簡單的問題: 求$f(x)$於$x\in[a,b]$與$x$軸圍成的面積。</p><p>可以很直覺的想到將切片法，$\sum f(x)\times \Delta x$，只要$\Delta x$夠小，面積就會夠接近。<br>我們可以將上面的式子改成一個比較簡潔的寫法: $\int_{a}^{b} f(x) dx$。<br>現在可以寫出一個函數$A(a,b) = \int_{a}^{b} f(x) dx$，為了方便討論，假定$a=0$，$A(b) = \int_{0}^{b} f(x) dx$。</p><p>請先裝作不知道微積分基本定理，可以發現他們似乎有某種關係，$A(b)$會將$f(x), x\in[0,b]$的面積變成一條線<br><img src="https://i.imgur.com/kwTRBok.png" alt=""><br><img src="https://i.imgur.com/GMYzoZJ.png" alt=""></p><p>什麼東西乘上$\Delta x$後會等於$\Delta y$，你寫出了$\frac{\Delta y}{\Delta x}$，你意外的發現$f(x)$其實就只是$A(b)$在某一點的斜率，<br>而求瞬間斜率已經有一個好用的微分了，你可以大膽寫下$A(b) = \int_{0}^{b} A’(x) dx = \int_{0}^{b} \frac{dA(x)}{dx} dx$，<br>因此現在要求$f(x)$於$x\in[0,b]$與$x$軸圍成的面積，只需要找到一個$A(x)$微分後等於$f(x)$的函數，再將$b$代入就是答案，<br>而$x\in [a,b]$可以用求兩次面積扣掉後得到，$A(b)-A(a) = \int_{a}^{b} f(x) dx$。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從零開始的微積分 Differential</title>
      <link href="/2020/07/24/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Differential/"/>
      <url>/2020/07/24/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-Differential/</url>
      
        <content type="html"><![CDATA[<p>有了極限的概念，微分就比較好理解了(或許吧lul</p><h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><blockquote><p>定義一函數的平均變化率為$\frac{f(x+h)-f(x)}{h}$，則$\lim\limits_{h\to 0} \frac{f(x+h)-f(x)}{h}$為該函數在點$x$的瞬間變化率。又可以寫成$\frac{df(x)}{dx}$</p></blockquote><p>有些人會把$\frac{df(x)}{dx}$當作一種表示方法:$f(x)$對$x$微分，但是我認為以另一種方式去理解的話會有更加深刻的看法。</p><p>對於一個曲線，我們可以取兩點$a, b$，並且得知兩點之間的平均變化率。<br><img src="https://i.imgur.com/6SHD6c1.png" alt=""><br>而現在我們把$|b-a|$慢慢縮小<br><img src="https://i.imgur.com/3LotS8m.png" alt=""><br>越來越小…<br><img src="https://i.imgur.com/l2gYfeP.png" alt=""><br>我們可以寫成$dx = b - a$，表示一個微小的$x$變化，同樣的這個曲線的輸出值$f(x)$，也會有個微小的輸出變化$dy = f(b) - f(a) = f(a + dx) - f(a)$，而這段的平均變化率寫成$\frac{dy}{dx}$。<br>所以$dx, dy$是可以有意義的，不只是表示而已，至少我這樣理解一直都是對的，知道這點會讓以後的微積分運算變得直覺許多。</p><h1 id="具象化微分公式"><a href="#具象化微分公式" class="headerlink" title="具象化微分公式"></a>具象化微分公式</h1><p><strong>加法:</strong> $\frac{d(f(x) + g(x))}{dx}=\frac{df(x)}{dx} + \frac{dg(x)}{dx}$<br>$f(x)+g(x)$可以看成兩條線相連，而$df(x)$、$dg(x)$則是微小的變化量，寫成$d(f(x) + g(x))=df(x) + dg(x)$，同除$dx$，取極限，噹噹(｡A｡)</p><p><strong>乘法:</strong> $\frac{d(f(x)g(x))}{dx}=\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx}$<br>$f(x)\times g(x)$可以看成一個矩形的面積，<br><img src="https://i.imgur.com/niLqoBt.png" alt=""><br>求面積變化量相當於微小的變化量$df(x)g(x)$、$dg(x)f(x)$與$dg(x)df(x)$的和。<br>寫成$d(f(x)g(x)) = df(x)g(x) + dg(x)f(x) + df(x)dg(x)$，兩邊同除$dx$，取極限$\lim\limits_{dx\to 0}$，得到$\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx} + \frac{dg(x)df(x)}{dx}$<br>最後一項會因為$dg(x)$取了極限而為0(或是$df(x)$都可以，看你的$dx$要跟誰除)。<br>最後就成為了$\frac{f(x)\times g(x)}{dx}=\frac{df(x)g(x)}{dx} + \frac{dg(x)f(x)}{dx}$</p><p><strong>減法:</strong> $\frac{d(f(x) - g(x))}{dx}=\frac{df(x)}{dx} - \frac{dg(x)}{dx}$<br>就跟加法一樣的想法，不多贅述。</p><p><strong>除法:</strong> $\frac{d\frac{f(x)}{g(x)}}{dx} = \frac{\frac{df(x)g(x)}{dx}-\frac{dg(x)f(x)}{dx}}{g^2(x)}$<br>這個我不知道怎麼具象化出來…只能用代數去解了(´・ω・`)<br>$h(x) = \frac{f(x)}{g(x)}$<br>$h(x)g(x) = f(x)$<br>$\frac{dh(x)g(x)}{dx} + \frac{dg(x)h(x)}{dx} = \frac{df(x)}{dx}$</p><p>$\frac{dh(x)g(x)}{dx} = \frac{df(x)}{dx} - \frac{dg(x)h(x)}{dx}$</p><p>$\frac{dh(x)}{dx} = \frac{\frac{df(x)}{dx} - \frac{dg(x)h(x)}{dx}}{g(x)}$</p><p>$\frac{dh(x)}{dx} = \frac{\frac{df(x)}{dx} - \frac{dg(x)\frac{f(x)}{g(x)}}{dx}}{g(x)}$</p><p>$\frac{dh(x)}{dx} = \frac{df(x)g(x)}{dx g^2(x)} - \frac{dg(x)f(x)}{dx g^2(x)}$</p><p>$\frac{d\frac{f(x)}{g(x)}}{dx} = \frac{\frac{df(x)g(x)}{dx}-\frac{dg(x)f(x)}{dx}}{g^2(x)}$</p><p><strong>冪次:</strong> $\frac{dx^n}{dx} = nx^{n-1}$</p><ul><li>從$n=2$開始，可以想像一個$x\times x$的正方形，其變化量是$d(x^2)=2dx \times x + dx^2$，同除$dx$，取$dx\to 0$的極限下，會讓$dx$接近0而被消去</li><li>$n=3$，想像一個$x\times x\times x$的立方體，變化量是$d(x^3) = 3dx\times x^2 + 3dx^2\times x + dx^3$，同上面的操作。</li><li>$n=4$，無法想像但是可以找到一些規律，變化量是$d(x^4) = 4dx\times x^3 …$之類的，因為之後的項全都有$dx$，所以都會被忽略掉。</li><li>$n=n$，可以想到$d(x^n) = ndx\times x^{n-1}…$，得到$\frac{dx^n}{dx} = nx^{n-1}$</li></ul><p><strong>鏈式:</strong> $\frac{dg(f(x))}{dx} = \frac{dg(f(x))}{df(x)}\frac{df(x)}{dx}$<br><img src="https://i.imgur.com/GHv9s4W.png" alt=""><br>把$f(x)$看做一個數$k$<br><img src="https://i.imgur.com/AgxsFsW.png" alt=""><br>可以寫出$\frac{dg(k)}{dk} \times dk = dg(k)$，其中$dg(k)$為這個函數$g(x)$的變化量。<br>將$k$寫回去後，$\frac{dg(f(x))}{df(x)} \times df(x) = dg(f(x))$，同除$dx$，$\frac{dg(f(x))}{df(x)} \times \frac{df(x)}{dx} = \frac{dg(f(x))}{dx}$</p><h1 id="隱微分"><a href="#隱微分" class="headerlink" title="隱微分"></a>隱微分</h1><p>相信一開始學到圓方程式如何微分時，大部分人都會感到困惑。<br>書上都直接寫$x^2+y^2=r^2$，微分$2xdx+2ydy=0$，做一下對調$-\frac{x}{y}=\frac{dy}{dx}$，就好了。<br>看起來很對，但是很奇怪，我們到底在對甚麼微分?</p><p>其實本質上仍然是對$x$微分，只是書本常常省略(可能只是我看的書沒寫)。<br>假設$y=f(x)$，$x^2+f(x)^2=r^2$對$x$微分，$2x+2f(x)\frac{df(x)}{dx}=0$，排列一下$\frac{df(x)}{dx}=-\frac{x}{f(x)}$，把$f(x)$換成$y$，這跟上面那個微分方式是等價的。</p><p>隱微分對於複雜的方程式非常有用。</p><h1 id="泰勒展開式"><a href="#泰勒展開式" class="headerlink" title="泰勒展開式"></a>泰勒展開式</h1><p>有些函數很難求出某些特定值，例如$cos 9.02323$這種，如果可以把它寫成多項式的話，就可以得到近似值。<br>我們說某個多項式等於某個函數，只要他們的各階導數相同。</p><p>推導(以$cos x$當例子):<br>我們假設有一個多項式$ax^2+bx+c$，我們要讓他盡量等於$cos x$，首先注意到的是$cos 0=1$，所以$c=1$。<br>接著$\frac{dcos x}{dx}=-sinx$，而$-sin 0 = 0$；$ax^2+bx+c$微分後$2ax+b$，$x=0$時應該要是0所以$b=0$。<br>再微一次就可以知道$a=-\frac{1}{2}$，這樣我們就得到了一個接近$cos x$的二次函數。</p><p>顯然我們可以對cos無限求導，也就是說，我們需要一個無限多項的函數來表達，<br>$a0+a_1x^1+a_2x^2+a_3x^3…$<br>通過上述的規則可知，$a_0=1$, $a_1=0$, $a_2=-\frac{1}{2}$, $a_3=0$, $a_4=\frac{1}{24}$…</p><p>一般化形式:<br>$a0+a_1x^1+a_2x^2+a_3x^3…$=$f(x)$</p><p>$a_0=f(0)$, $a_1=\frac{df}{dx}(0)$, $a_2=\frac{\frac{d^2f}{dx^2}(0)}{2}$, $a_3=\frac{\frac{d^3f}{dx^3}(0)}{6}$…，通過這步驟可以發現$a_k=\frac{f^{(k)}(0)}{k!}$，<br>所以$f(x)=\sum_{k=0}^\infty{\frac{f^{(k)}(0)}{k!}x^k}$，寫出泰勒展開式了!<br>如果已知$f^{(k)}(a)$可以寫成$f(x)=\sum_{k=0}^\infty{\frac{f^{(k)}(a)}{k!}(x-a)^k}$ (偏移)</p><h2 id="精選題目區"><a href="#精選題目區" class="headerlink" title="精選題目區"></a>精選題目區</h2><ol><li><p>$h(x)=\sqrt[3]{x^2+\sqrt{x^3+1}}$, 求$\frac{dh(x)}{dx}$</p></li><li><p>求過圓$x^2+y^2=25$上一點$(3,-4)$的切線方程式?</p></li><li><p>$x^{\frac{2}{3}}+y^{\frac{2}{3}}=a^{\frac{2}{3}}, a&gt;0$，證明過其上任一點的切線，被坐標軸截出線段長度為一常數。<br>$x^{\frac{2}{3}}+y^{\frac{2}{3}}=r$被稱為星狀圖<br><img src="https://i.imgur.com/5lwwqFZ.png" alt=""></p></li><li><p>求$\frac{dsin^{-1}(x)}{dx}$</p></li><li><p>求$\frac{dsin^2(x)}{dx}$</p></li><li><p>$sin(x+y)=y^2cos(x)$, 求$\frac{dy}{dx}$</p></li><li><p>求$\frac{da^x}{dx}$, $a$是一常數且$a\in \Bbb{R}$</p></li><li><p>求$\frac{e^{sec3x}}{dx}$</p></li><li><p>求$\frac{dln(x)}{dx}, x&gt;0$</p></li><li><p>$f(x)=\pi^{e^{x^{\sqrt{10}}}}$, 求$\frac{df(x)}{dx}$</p></li><li><p>求$\frac{d\log_a x}{dx}$</p></li><li><p>$y=\frac{x^{\frac{3}{4}}\sqrt{x^2+1}}{(3x+2)^5}$, 求$\frac{dy}{dx}$</p></li><li><p>求$\frac{dx^{x^{x}}}{dx}, x&gt;0$</p></li><li><p>求$\frac{d(sinx)^{lnx}}{dx}, x&gt;0$</p></li><li><p>一倒立的圓錐形容器，高$4m$，底半徑$2m$，現以$2m^3/min$的速率倒入水，則當水面高$3m$時，水面升高的速率? 加速度? (hint: $V=\frac{1}{3}\pi r^2h$)</p></li><li><p>一時鐘時針長$8mm$，分針長$4mm$，則在1點時，兩針針尖距離的變化率(mm/hr)?</p></li><li><p>一粒子P在平面上運動，時間$t, t&gt;0$，位置為曲線$xy+2x=2t$與$y=x^2t$的交點，則$t=2$時P與原點的距離變化率?</p></li><li><p>一雪球體積融化的速度與表面積成正比。假設經過3小時體積融化一半，則在何時完全融化?</p></li></ol><p>題目來源: <a href="http://www.math.ntu.edu.tw/~hchu/Calculus/">http://www.math.ntu.edu.tw/~hchu/Calculus/</a> (感謝講義製作人!)</p><h2 id="題目講解區"><a href="#題目講解區" class="headerlink" title="題目講解區:"></a>題目講解區:</h2><ol><li><p>連鎖律<br><strong>Answer:</strong> $\frac{1}{3}(x^2+\sqrt{x^3+1})^{-\frac{2}{3}}(2x+\frac{3x^2}{2\sqrt{x^3+1}})$</p></li><li><p>隱微分<br><strong>Answer:</strong> $\frac{3}{4}(x-3)=y+4$</p></li><li><p>隱微分後找到在$(x_0, y_0)$的x-軸截距及y-軸截距。</p></li><li><p>需要用到定理: $(f^{-1})’ (b) = \frac{1}{(f)’ (f^{-1}(b))}$，請自行證明<br><strong>Answer:</strong> $\frac{1}{\sqrt{1-x^2}}$</p></li><li><p>連鎖律<br><strong>Answer:</strong> $sin 2x$</p></li><li><p>隱微分+連鎖律<br><strong>Answer:</strong> $\frac{cos(x+y)+y^2sin x}{2ycosx -cos(x+y)}$</p></li><li><p>利用自然對數的性質<br><strong>Answer:</strong> $2^xln 2$</p></li><li><p>自然對數、三角函數微分<br><strong>Answer:</strong> $e^{sec3x}3tan(3x)sec(3x)$</p></li><li><p>反函數定理(參p4)<br><strong>Answer:</strong> $\frac{1}{x}$</p></li><li><p>連鎖律<br><strong>Answer:</strong> $ln(\pi)\pi ^{e^{x^{\sqrt{10}}}}e^{x^{\sqrt{10}}}\sqrt{10}x^{\sqrt{10}-1}$</p></li><li><p>一般對數轉換成自然對數<br><strong>Answer:</strong> $\frac{1}{xln a}$</p></li><li><p>對數微分法:<br>設$y=f(x)$，兩邊取$ln$，$ln|y|=ln|f(x)|$，微分$\frac{dln|y|}{dx}=\frac{ln|f(x)|}{dx}$<br>$\frac{dy}{|y|dx}=\frac{df(x)}{|f(x)|dx}$，得$\frac{dy}{dx}=\frac{df(x)}{dx}$</p><p>套用到這題，$ln y = ln(x^{\frac{3}{4}}\sqrt{x^2+1}) - ln(3x+2)^5$，微分後你就知道怎麼做了 :)<br><strong>Answer:</strong> $\frac{x^{\frac{3}{4}}\sqrt{x^2+1}}{(3x+2)^5}(\frac{3}{4x}+\frac{x}{x^2+1}-\frac{15}{3x+2})$</p></li><li><p>同樣是對數微分法<br><strong>Answer:</strong> $[x^x(1 + ln x)lnx + x^{x-1}]x^{x^x}$</p></li><li><p>又是對數微分法<br><strong>Answer:</strong> $(\frac{ln(sinx)}{x}+ln(x)cot(x))(sinx)^{lnx}$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{8}{9\pi}$, $\frac{128}{243\pi ^2}$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $-\frac{22}{3\sqrt{5-2\sqrt{3}}}\pi$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{sqrt{5}}{2}^3$</p></li><li><p>(施工中)<br><strong>Answer:</strong> $\frac{3\sqrt[3]{2}}{\sqrt[3]{2}-1}$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從零開始的微積分 Limitation</title>
      <link href="/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-limitation/"/>
      <url>/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93-limitation/</url>
      
        <content type="html"><![CDATA[<p>極限應該是大部分人學習微積分第一個學的吧。<br>很多人都會把極限當成純粹把數字帶進去，尤其是初學者，然而如果是以這種方式去了解，之後面對不連續的函數時，將會感到困惑、不直覺，只有了解極限的定義後才可以有好的觀念去處理之後的問題。</p><h1 id="序列極限"><a href="#序列極限" class="headerlink" title="序列極限:"></a>序列極限:</h1><blockquote><p>設$ \{ x_n \} , x_n \in R, L \in R, n=1,2…$，存在任意實數$\epsilon$與$N$使得當$n&gt;N$，存在$|x_n - L| &lt; \epsilon$，則稱序列${x_n}$存在極限值$L$。</p></blockquote><p>這是柯西在19世紀給出的極限的定義，而正是這種定義使現代微積分(極限微積分)與古典微積分(無窮小微積分)畫上了界線。</p><p>舉個例子，$\{0.1, 0.001, 0.0001, 0.00001, …, 10^{-k}\}$，我們可以找到任意實數，存在$|x_n - 0|&lt; \epsilon$，所以這個序列存在極限值0。<br>理解了序列極限，函數極限就不難理解了。</p><h1 id="函數極限"><a href="#函數極限" class="headerlink" title="函數極限:"></a>函數極限:</h1><p><img src="https://i.imgur.com/rRIjuNg.jpg" alt=""></p><blockquote><p>假設有一個實函數$f(x)$，而對於點$x$可以找到任意實數$\delta$使得$|x - c|&lt; \delta$，如果我們可以找到任意實數$\epsilon$，以及一個實數$L$，使得$|f(x)- L|&lt; \epsilon$，則我們說$\lim\limits_{x\to c} f(x) = L$</p></blockquote><p>利用剛剛的序列極限思想，可以很輕鬆的理解，一個序列$\{x_k\}$不斷趨近於$c$，同時定義序列$\{f(x_1), f(x_2), f(x_3), …, f(x_k)\}$，可以找到任意實數使$|f(x_n)-L|&lt; \epsilon$，則此函數在$c$上的極限值為$L$</p><p>我以前常常思考 “趨近”是否就是”等於”?<br>後來我認為，這兩種觀念不該混為一談，別再問”趨近”是不是”等於”了，這兩個根本無法比較。<br>趨近是指一個序列的極限值為某數，所以一般寫 某個極限=某個數字，是指說 這個序列的極限值=某個數字。</p><p>再補充一點，當時柯西寫出極限定義時，實數還是不完備的，可能中間還有奇怪的數字(A理數, B理數…)，之後由許多數學家寫出實數基本定理後才使上面的定義變嚴謹。<br>實數基本定理證明了實數是連續的，且只要兩實數中間無任何實數則兩實數相等。</p><h1 id="極限性質"><a href="#極限性質" class="headerlink" title="極限性質"></a>極限性質</h1><p>_只有當右側極限存在才成立。_<br>$\lim\limits_{n\to c} k\times f(n) = k \times \lim\limits_{n\to c} f(n)$<br>$\lim\limits_{n\to c} [f(n) + g(n)] = \lim\limits_{n\to c} f(n) + \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} [f(n) - g(n)] = \lim\limits_{n\to c} f(n) - \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} [f(n) \times g(n)] = \lim\limits_{n\to c} f(n) \times \lim\limits_{n\to c} g(n)$<br>$\lim\limits_{n\to c} \frac{f(n)}{g(n)} = \frac{\lim\limits_{n\to c} f(n)}{\lim\limits_{n\to c} g(n)}$</p><h1 id="精選題目區"><a href="#精選題目區" class="headerlink" title="精選題目區:"></a>精選題目區:</h1><ol><li>$\lim\limits_{x\to 0} \frac{|x|}{x}$</li><li>$\lim\limits_{x\to 3^+} \lfloor x \rfloor$, $\lim\limits_{x\to 3^-} \lfloor x \rfloor$</li><li>$\lim\limits_{x\to 2^+} \frac{x-3}{x^2-4}, \lim\limits_{x\to 2^-} \frac{x-3}{x^2-4}$</li><li>$\lim\limits_{x\to 2} \frac{(x-2)^2}{x^2-4}$</li><li>$\lim\limits_{x\to 2^+} tan^{-1} \frac{1}{x-2}$</li><li>$\lim\limits_{\theta \to 0} \frac{\sin \theta}{\theta}$</li><li>$\lim\limits_{\theta \to 0} \frac{\sin (\theta - 1)}{\theta - 1}, \lim\limits_{\theta \to 1} \frac{\sin (\theta - 1)}{\theta - 1}$</li><li>$\lim\limits_{\theta \to 0} \frac{\cos \theta -1}{\theta}, \lim\limits_{\theta \to 0} \frac{\cos \theta -1}{\theta ^2}$</li><li>$\lim\limits_{x\to 0} tan x \sin \frac{1}{x}$</li></ol><h1 id="題目講解區"><a href="#題目講解區" class="headerlink" title="題目講解區:"></a>題目講解區:</h1><ol><li><p>左極限、右極限不同，所以不存在極限。<br><strong>Answer:不存在極限</strong></p></li><li><p>如果你把它的函數圖形畫出來，你就會知道了。<br><img src="https://i.imgur.com/reuzeIU.png" alt=""><br><strong>Answer:3,2</strong></p></li><li><p>(a)上方極限為-1，下方為0，則極限值為$- \infty$<br>(b)上方極限為-1，下方為-0，則極限值為$\infty$<br><strong>Answer:</strong> $- \infty$,$\infty$</p></li><li><p>先把x-2這個因式消掉就可以了。<br><strong>Answer:0</strong></p></li><li><p>實際上這個等同於$\lim\limits_{x\to 0^+} tan^{-1} \frac{1}{x}$，而又等同於$\lim\limits_{x\to \infty ^+} tan^{-1} x$，這下你就知道了。<br><strong>Answer:</strong> $\frac{\pi}{2}$</p></li><li><p>需要用到夾擠定理(三明治定理)，依下圖可以寫出不等式$\frac{\sin \theta}{2} \leq \frac{\pi \theta}{2 \pi} \leq \frac{tan \theta}{2}$(三角形與扇形面積)，解出來就得到答案。<br><img src="https://i.imgur.com/69xvwLs.png" alt=""><br><strong>Answer:1</strong></p></li><li><p>同樣的，兩個都可以將$\theta -1$替換掉，跟第五題一樣。<br><strong>Answer:</strong> $\sin 1$, <strong>1</strong></p></li><li><p>$\frac{\cos \theta -1}{2}= \sin^2 \frac{\theta}{2}$，使用這個公式就好(ゝ∀･)<br><strong>Answer:0</strong>, $- \frac{1}{2}$</p></li><li><p>$-1 \leq \sin \frac{1}{x} \leq 1$，$-tan x \leq \sin \frac{1}{x} \leq tan x$，當x趨近於0，$0 \leq \sin \frac{1}{x} \leq 0$(夾擠定理)。<br><strong>Answer:0</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從零開始的微積分 前言</title>
      <link href="/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93/"/>
      <url>/2020/07/16/Re-%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E5%A7%8B%E3%82%81%E3%82%8B-%E3%81%B3%E3%81%9B%E3%81%8D%E3%81%B6%E3%82%93/</url>
      
        <content type="html"><![CDATA[<p>最近喜歡上了微積分(びせきぶん)，突然覺得自己以前算的都不叫數學，很久沒有遇過這麼有趣又能使我思考的東西。<br>貌似又找到了小時候自學程式興奮感了(,,・ω・,,) 就像走進一個未知的世界一樣，到處都是冒險的感覺。</p><p>這個系列會更新很久，可能一個月更新一次吧lul，主要是記錄一些對於微積分的學習筆記、理解，以及一些特別的題目。</p><p>對了，這個系列 <strong>不適合沒有學過微積分觀念的人</strong> ，這系列主要目的是提出我對於微積分的觀點，以祈產生不同的想法。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino專題製作 part 3</title>
      <link href="/2020/07/15/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-3/"/>
      <url>/2020/07/15/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-3/</url>
      
        <content type="html"><![CDATA[<p>發現其實移植到Nano板上面沒什麼好講的，就講講機械手臂跟我遇到的困難好了。</p><p>這個機械手臂其實是上課老師做出來的公制版本，而我把重心放在加速度器測距跟藍芽傳輸，所以我沒自己用一個出來。<br>(機械手臂 圖)<br>這個機械手臂總共有四個馬達，第一個馬達在最下面，負責xy平面(桌面)的旋轉；第二個馬達在中間，負責垂直xy平面的旋轉，第三個、第四個負責比較細部的操作，這邊就沒用到了。</p><p>接著要做的是加速器測距，這個就令我感到困難重重了…</p><p>考慮到感測器可以在短時間取得加速度資料，可以直接使用黎曼積分，不用使用什麼很複雜的公式，只需要國中物理的程度就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int8_t</span> dt = <span class="number">1</span>; <span class="comment">// ms</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[<span class="number">3</span>], v[<span class="number">3</span>], d[<span class="number">3</span>]; <span class="comment">//Acceleration, Velocity, Displacement</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">get_Acce</span>(); <span class="comment">//接受加速度器資料</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">d[i] += <span class="number">0.5</span> * a[i] * dt * <span class="number">0.0001</span> * dt * <span class="number">0.0001</span> + v[i] * <span class="number">0.0001</span>;</span><br><span class="line">v[i] += a[i] * dt * <span class="number">0.0001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">blth</span>(d[<span class="number">0</span>], d[<span class="number">1</span>], d[<span class="number">2</span>]); <span class="comment">//傳送回控制機械手臂的版子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因為這個加速度器其實蠻(不精準的…放在桌上不動xy軸還是會有值出現。<br>所以我在get_Acce()中加上很多過濾雜質的步驟，比如說直接向下取整之類的，但是在過程中也會讓很多資訊消失@@</p><p>最後的結果就是測出來的距離很不準，如果可以多加幾個感測器去校準說不定可以更好? 但是我沒時間做QAQ</p><p>接著是因為這個機械手臂的構造是用旋轉來位移，牽涉到兩個軸，而不是只要動一軸就好，而且機械手臂要接收的角度，這就需要用反三角函數了。<br><img src="https://i.imgur.com/RR2kJlL.png" alt=""><br>r是機械手臂的臂長，L是某個平面上的位移量。<br>根據$2r sin \frac{\theta}{2} = L$這個等式，可以得到$\theta = 2sin^{-1} \frac{L}{2r}$。</p><p>基本上就是這樣了，因為加速度器的誤差以及機械手臂的構造，導致最終成品…差強人意吧(｡ŏ_ŏ)</p><p>(我每次都沒拍照，害我都沒圖放 (´-ι_-｀)</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>從零開始的discord bot 心得</title>
      <link href="/2020/06/19/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E7%9A%84discord-bot-%E5%BF%83%E5%BE%97/"/>
      <url>/2020/06/19/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E7%9A%84discord-bot-%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>!!這是從<a href="https://emiliatancoding.blogspot.com/">舊blog</a> 轉移過來的。</p><p>在某一天的午後，突然被拉去寫discord bot，經過許多波折與心血，覺得有一點價值，所以決定記錄下來。<br><img src="https://i.imgur.com/GRXts6Y.png" alt=""></p><p>前幾天，google了資料找到一個頻道有專門在做discord bot的教學。所以就照做了個。<br>一開始很順利，不過python官網載下來的IDE似乎有問題，所以我最後決定使用VS的python。</p><p>接下來就是開始麻煩的地方了，我發現照影片做的bot需要我開啟終端才會回應，也就是說想要這隻bot 24小時待命需要我一直開著電腦，當下決定上網找方法解決，然而卻因為找錯方向所以以為discord提供的webhook就是host功能…<br>導致我以為是自己code有問題，但是後來想想自己電腦上都可以，那有可能的原因就是存code的伺服器(github)需要其他檔案,或webhook其實不是host功能。<br><img src="https://i.imgur.com/NHrhM7T.png" alt=""></p><p>再來幾天就是確認這兩個問題，上網瘋狂找資料後發現兩種都有，但是主要問題是搞錯webhook的功能，最後發現要用heroku+github，一個host一個存code，持久化bot的夢想差點就要實現了，直到heroku狠狠把它摔在地上，碎的跟課本上的碎琉璃一樣。<br><img src="https://i.imgur.com/QTixKyK.jpg" alt=""></p><p>好巧不巧，剛好撞上期中考，這件事我只好列入長期追蹤清單。</p><p>在那段時期的沉澱，我不斷思考是甚麼的問題，伺服器, code, 或者只是我的方向又錯了?<br>反正後來還是沒有任何的進展，就算我只丟一個超簡單的bot還是沒辦法成功host，原因未知。<br>期中考前一個禮拜發現 heroku有跟github連動的功能，抱著死馬當活馬醫的心態試了一下，似乎有host? 綠燈是亮了，但是不知道為甚麼bot還是下線中 Q口Q<br><img src="https://i.imgur.com/uMTQACx.jpg" alt=""></p><p>最後那個頻道出了一集有關host bot的影片，他是用repl.it + uptimerobot，一個host+存code，一個監控repl.it有沒有關掉bot，有就重開。<br>PS. repl.it會隔一段時間就自動關掉bot，所以才需要uptimerobot。</p><p>突破了持久化問題，我的bot瞬間進化了很多，差不多是中古到工業革命。</p><p>接下來的問題其實比起前面都還好，我打算在我的bot加一個neko的功能，主要是受到Fredboat這個音樂bot的影響，這個音樂bot藏了很多彩蛋，我記得我第一次不小心用出來的彩蛋是;;explosion(我也不曉得為甚麼我會打這個東西)，接下來是;;neko, ;;magic, ;;hug，反正一堆奇怪的東西都被我試出來了@@<br><img src="https://i.imgur.com/YvdTdp7.png" alt=""></p><p>我一開始以為是Fredboat自己有用一個圖庫，後來看了看圖片的link，是通向一個叫cdn.nekos.life的網站底下的文件，我決定也在自己的bot實現這個功能。<br>我最一開始的想法就是網路爬蟲，訪問伺服器然後取得檔案列表，不過我對網路爬蟲只有概念，沒有實作過，所以呢…google!<br>但是這就出現了一個問題，首先爬蟲沒辦法取得伺服器檔案列表(其實我也不知道這個神奇想法到底從哪冒出來的，仔細想的話這當然不行且不合理，誰會希望伺服器的檔案被拿到)，再來是我看到的爬蟲都是處理那種有文字跟圖片的網站，爬蟲的原理就是拿到網頁的原始碼，然後進行處理，過濾不相干的東西，只看的到想看的。但是如果你剛剛自己連了一下cdn.neko.life會發現這根本不是一般的網站。<br><img src="https://i.imgur.com/V7gHDHs.png" alt=""></p><p>至此，neko指令開發陷入停滯。</p><p>某一天突然靈機一動，把neko.life貼到google上，結果找到了真的可以觀賞的網頁(=^･ω･^=)<br>而且還找到了nekos.py的模組…似乎是neko.life的製作團隊寫的模組，而且有很多種語言版本(C#, js, python…)，不過在我的電腦上執行不起來，應該是bug。<br>我花了一個下午剖析了nekos.py的原碼，最終發現主要的關鍵是一個叫nekos.life/api/v2/img的網頁，應該也是他們寫的，這個網頁可以隨機找尋圖庫裡面其中一張，並回傳json檔在網頁上，所以爬蟲拿到的就是純粹的json檔，在python裡可以直接用.json()轉換! 基本上這在我的一般python程式可以正常運作。</p><p>不過當我嘗試把code移植到bot的code時，python一直報錯，簡單說就是json格式問題，因為我自己從來沒深入研究過json檔與爬蟲(雖然有爬過文但是看到不是想要的就跳過，所以幾乎沒有充足的經驗)，導致我以為是repl.it不開放requests模組的使用，但是查了一下明明有支援，再度絕望 =。=</p><p>接下來我發呆了一段時間，我思考過很多可能性: 我爬蟲寫爛了, repl.it的requests模組其實跟我VS的是不同版本, 網站有防爬蟲機制。<br>我先檢查了我的code，跟nekos.py原碼比對後，沒差。<br>repl.it的requests跟我裝的都沒差，因為安裝一定都用python官網裝最新的。<br>防爬蟲機制應該在我用python小程式測試時就出現了。</p><p>最後我把爬蟲拿到的網頁原始碼print出來，發現跟我用電腦看到的完全不一樣，真的完全不一樣。</p><p>最後我認為是防爬蟲的機制導致的，因為也只剩下這個可能性了，我加上反”反爬蟲”的headers，成功了。<br>最終neko指令大功告成，我還順便加了fox指令ヽ(=^･ω･^=)丿<br><img src="https://i.imgur.com/TwSzD5m.png" alt=""></p><p>接下來是有關zj的解題數查詢，hunt [id]，我們打算用id去查找使用者的AC數,WA數…<br>有了neko指令的爬蟲知識，這個功能開發基本是沒有難度。<br>可以用爬蟲獲取zj排行榜的網頁原始碼，注意到zj排行榜的url是…page=1&amp;，可以用迴圈去取得網頁原始碼，然後找id的位置，再從id位置找CE，這個區塊就是我們獵物的資料。</p><p>hunt指令實作完成。</p><p>但是因為hunt裡面使用到大量的字串比對，所以速度蠻慢的，可能需要用剖析器加速。</p><p>(功能開發未完…)</p><p>心得:</p><p>整體下來，我認為這個比寫題目有趣很多，不過很吃英文, 資料搜尋, 問題猜測, 還有耐心，code的實力我覺得不太重要，大致上就是貼code然後修修改改，主要的難點在於該怎麼找到問題的癥結點，尤其是在沒人可以幫助你的情況下，只有上網才能找到答案，而且還不一定可以找到你要的答案，或是中文很少人在討論這個問題，必須去找英文資料，看官方的開發手冊。<br>雖然難度頗大，但是成就感十足。(真希望考試都可以考這種題目Zzz。)</p><p>突然曉得為何python會突然火起來，真的太方便了，如果要用C++難度大概是UR難度吧，C#也是可以寫，但不知道有沒有支援discord的模組。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino專題製作 part 2</title>
      <link href="/2020/06/18/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-2/"/>
      <url>/2020/06/18/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-2/</url>
      
        <content type="html"><![CDATA[<p><strong>!!這裡只講HC05，如果是HC06請按Backspace離開。</strong></p><p>這是我遇過目前最難的部分了。首先使用主從連線的話，需要進入”AT模式”，而新手明顯的不懂到底怎麼進入，尤其是HC05有兩種版本，只有KEY腳位的與只有EN腳位的。<br>兩種進入AT模式的方法又不一樣，容易把新手搞瘋。</p><p>而在處理完AT設定後，Serial視窗上的傳送結尾必須調成NL&amp;CR，還要設定傳送Baud Rate為38400(HC05預設值)，有很多細節需要注意，完全一個新手殺手。</p><hr><p>首先 <strong>配線</strong>: RX -&gt; 11, TX -&gt; 10, EN不須接(如果有KEY位，且，如果需要進入AT mode，請在通電前接上3.3V腳位)</p><p>接著進入AT mode，如果是只有EN的，在通電前按住HC05上面的小按鈕(通電後可以放開)，他的作用可以讓HC05的34腳位通電進入AT mode；而如果是只有KEY，請在通電前接上3.3V腳位。</p><p>打開Serial視窗，設定好 <strong>Baud Rate 38400</strong> 跟結尾符號 <strong>NL&amp;CR</strong>。<br>“正常來說”，沒錯，”正常來說”，當你打出”AT”後，應該會出現”ERROR:(0)”，再打一次，”理論上”，HC05會回你”OK”。(如果都無法，應該檢查一下配線、型號、線路的穩定)。</p><p>如果你是想用手機連藍牙的話，不需要進入AT mode(可能需要載特別的bluetooth app)，但是如果要兩隻HC05互連，需要設定主從關係(主為輸出訊息，從為接收):</p><p>在從的那端，輸入”AT+ADDR?”得到從端的MAC值(不知道這可不可以稱作MAC值?)，請記好。<br>接著在主的那端，輸入”AT+ROLE=1”，接著”AT+BIND=(剛剛從端的MAC值)”。</p><p>接下來”應該”可以讓他們自動互連了，如何判斷呢，在初始狀態下，兩塊模組應該會連閃紅燈，接著一陣死寂，然後兩個紅燈同頻率閃著。</p><p>上 <strong>code</strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;SoftwareSerial.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">SoftwareSerial <span class="title">BTS</span><span class="params">(<span class="number">10</span>, <span class="number">11</span>)</span></span>; <span class="comment">//rx, tx，配線跟程式設定上是相反的，至於為什麼: &quot;嘴巴講的話，要用耳朵聽&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">pinMode</span>(<span class="number">9</span>, OUTPUT);    <span class="comment">//如果有KEY位的話。</span></span><br><span class="line">  <span class="built_in">digitalWrite</span>(<span class="number">9</span>, HIGH);</span><br><span class="line">  </span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line">  Serial.<span class="built_in">println</span>(<span class="string">&quot;Enter AT commands:&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  BTS.<span class="built_in">begin</span>(<span class="number">38400</span>);      <span class="comment">//設定Baud rate</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(BTS.<span class="built_in">available</span>())</span><br><span class="line">    Serial.<span class="built_in">write</span>(BTS.<span class="built_in">read</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(Serial.<span class="built_in">available</span>())</span><br><span class="line">    BTS.<span class="built_in">write</span>(Serial.<span class="built_in">read</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在測試時有些有趣的事情，兩塊模組的MAC值是相同的，原本以為會有問題，後來發現一點問題都沒有。<br>還有Baud rate的問題，弄了很久才搞懂，但是HC05 AT mode設定的Baud Rate到底是設定對於電腦的還是藍牙的，我仍不懂。</p><p>就這樣吧(｡ŏ_ŏ) 下次把藍牙移植到Nano板上，再加個加速度模組把資料回傳。</p><p>這種模組化的測試方式很有用，單個模組看不出優點，但在多個模組在合併時，就會展現出極大的優勢。<br>這是物件導向程式設計裡的一種思維方式，算是啟發我的重要思想(?)。</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arduino專題製作 part 1</title>
      <link href="/2020/06/18/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-1/"/>
      <url>/2020/06/18/Arduino%E5%B0%88%E9%A1%8C%E8%A3%BD%E4%BD%9C-part-1/</url>
      
        <content type="html"><![CDATA[<p>又重回到這個熟悉的又有點討厭的領域了@@</p><p>這次做的跟以前國中的循跡自走車不太一樣(其實只是我還沒想好:P )。<br>現在的構思是穿戴式裝置，放一個加速度感應在手上，大概控制機械手臂之類的?<br>反正就先照著這個思路先去做模組測試吧，之後的應用再想想……</p><p>我擁有的材料: 藍牙模組 <strong>HC-05</strong> x2, 加速度模組 <strong>Adafruit ADXL345</strong> x(很多個，因為怕壞掉), <strong>arduino Nano</strong> x1, <strong>arduino</strong>(純的) x(要幾個有幾個)。</p><p>這次先測試 <strong>Adafruit ADXL345</strong>。<br><img src="https://i.imgur.com/UNZCJM9.jpg" alt=""></p><p>在寫code之前要先將<a href="https://github.com/adafruit/Adafruit_ADXL345">Adafruit_ADXL345_U.h</a> , <a href="https://github.com/adafruit/Adafruit_Sensor">Adafruit_Sensor.h</a> 這兩個程式庫include</p><p>然後 <strong>配線</strong>: SDA -&gt; A4, SCL -&gt; A5<br>不講廢話直上 <strong>code</strong>:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Adafruit_Sensor.h&gt;</span></span></span><br><span class="line"><span class="comment">// https://github.com/adafruit/Adafruit_Sensor</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Adafruit_ADXL345_U.h&gt;</span></span></span><br><span class="line"><span class="comment">// https://github.com/adafruit/Adafruit_ADXL345</span></span><br><span class="line"> </span><br><span class="line">Adafruit_ADXL345_Unified accel = <span class="built_in">Adafruit_ADXL345_Unified</span>(<span class="number">923</span>); <span class="comment">//923只是編號，可自取，不要重複就好</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Serial.<span class="built_in">begin</span>(<span class="number">9600</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(!accel.<span class="built_in">begin</span>())</span><br><span class="line">    Serial.<span class="built_in">println</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  accel.<span class="built_in">setRange</span>(ADXL345_RANGE_16_G); <span class="comment">//簡單講一下2,4,8,16_G的差別，越低的對於低速動作越敏銳，越高對於高速則越敏銳。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">sensors_event_t</span> event;</span><br><span class="line">  accel.<span class="built_in">getEvent</span>(&amp;event);</span><br><span class="line"> </span><br><span class="line">  <span class="type">float</span> now[<span class="number">3</span>] = &#123;event.acceleration.x, event.acceleration.y, event.acceleration.z&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (byte i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">Serial.<span class="built_in">print</span>(now[i]);</span><br><span class="line">Serial.<span class="built_in">print</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Serial.<span class="built_in">println</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其實挺簡單的。 當初在測試時，z軸的數字是9.4多，還以為是壞了，但是覺得這數字挺熟悉但是又不像，嗯…學校是在半山腰，這點誤差好像很正常(?</p><p>嘛，就先這樣吧。下次做HC-05的測試。</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.25 無題</title>
      <link href="/2020/05/25/5-25-%E7%84%A1%E9%A1%8C/"/>
      <url>/2020/05/25/5-25-%E7%84%A1%E9%A1%8C/</url>
      
        <content type="html"><![CDATA[<p>一整個禮拜的雨終於傾倒完了，然而段考的腳步聲卻近在眼前，這個禮拜陪伴我的不只雨滴、還有無止盡的小考、複習、心中的壓力。<br>我常仰望那陰沉沉的天空，詢問著那不會有回應的問題，祈禱著陽光可以重新出現。<br>然而出現的不是陽光，而是一科科的課業，有如噩獸般襲來，無法殺死地存在於我的身邊。不盡理想的成績又像是猛烈又迅速的毒藥，幾乎要讓我的心死去。<br>聆聽著那點點雨滴落下的聲音，我聽不見任何聲音，早已忘卻蟬鳴之聲，無法明瞭那穹頂的高，金黃色的稻田，如今只是一片荒野。</p><p>學測倒數八個月，過去揮霍的昨日已然用盡，留殘僅剩的明日。</p><p>不曉得那些考卷上的人是否也曾有同樣的感受，一聲不吭的壓力隨著靜脈緩緩蔓延於身體，白月再不能成圓，孤夜再不能靜，曦光再不能現。<br>但這些人的文章卻總是遠傳千古的文章，不曉得為何，或許是嘗過了人生百態，寂靜的蟬鳴也是有聲，荒野上的孤寂也是種醇酒；月不能圓卻依然無暇，陰雨遮蔽的陽光卻仍照耀大地。<br>回首望著這鐫刻群星的五千年，時間早已沒有任何意義，「古今多少事，都付笑談中」。我孤單地在群星中寫下著將被浪花掏盡的無名。</p><p>鐘聲迴盪下，我仍寫著考卷，而雨滴停止了下落，當我望向那窗外之時，那一抹陽光早已使雨後的葉閃閃發亮，一絲陽光早已從雲縫中誕生，一縷蟬聲再度響起。<br>像是在嘲笑我，太陽在放學的路上灼熱著我的臉龐，蟬聲持續不斷的響著。</p><p>獨自走在回去的道路上，這西沉的陽光，仍照耀著彼方。</p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何隨機的建一棵樹</title>
      <link href="/2020/05/10/%E5%A6%82%E4%BD%95%E9%9A%A8%E6%A9%9F%E7%9A%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E6%A8%B9/"/>
      <url>/2020/05/10/%E5%A6%82%E4%BD%95%E9%9A%A8%E6%A9%9F%E7%9A%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E6%A8%B9/</url>
      
        <content type="html"><![CDATA[<p>最近在出題目，必須弄出一顆隨機的樹。<br>我一開始只想到一個錯誤的方法: 將數字從$1$到$n$丟入一個陣列$A$，然後將他們打亂，從$A_1$連到$A_n$。<br>很明顯這是一棵樹，但是這只有一條鍊==</p><p>後來又想了一個: 選取一個數字當根，從集合裡面找出$k$個點，加入到根的子節點中，之後dfs，重複這個動作。<br>同樣的，這個方法也有漏洞，由於沒有限制深度，所以第一個子樹會很深，一點都不像是隨機的。<br>而加上限制深度後，有時候會無法將所有點都排上去，不過限制深度不失為一個好方法，但是與”隨機”還是有點差距。</p><p>如果改成bfs呢?<br>選取一個數字當根，從集合裡面找出$k$個點，加入到根的子節點中以及queue中，再從queue中拿出點，之後，重複這個動作。<br>還是有一個漏洞，因為放入queue的順序是有序的，所以一樣會跟dfs的結果一樣，不過這個比較好解決，直接在queue裡面shuffle就好了。</p><p>這樣複雜度只有$O(n)$</p><p>在洗澡時又想出了一個方法，不過複雜度比較高。<br>將每個點賦予兩個隨機數字$(x,y)$，分別灑在平面上，$n^2$建邊，距離當權值，接著選取最中心的點做根，再用最小生成樹的方法來做成樹即可。</p><p>複雜度$O(n^2)$，也沒有比較快。<del>但是感覺比較帥(笑</del></p><p>寫這篇文章時發現只要將第一個方法改良一下就行了，從那些未使用的點中選取$k$個，做成一條鍊，從樹集合中挑出一個點，接上剛剛的鍊就好。</p><p>複雜度$O(n)$</p><p>至於賦值的部分，可以依需求直接random在陣列上，或是因應樹的結構dfs動態賦值。</p><p>11.5.20更新<br><a href="https://zh.wikipedia.org/wiki/%E6%99%AE%E5%90%95%E5%BC%97%E5%BA%8F%E5%88%97">普呂弗序列</a>，這個更適合用來建樹。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四維收納箱?</title>
      <link href="/2020/05/08/%E5%9B%9B%E7%B6%AD%E6%94%B6%E7%B4%8D%E7%AE%B1/"/>
      <url>/2020/05/08/%E5%9B%9B%E7%B6%AD%E6%94%B6%E7%B4%8D%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<p>最近化學課在教晶體堆積結構，到體心立方結構時出了神就想到了下面這個東西。</p><p>考慮一個中心點在(0,0,0)的正方形，邊長為2，則四個頂點為(1, 1), (1, -1), (-1, -1), (-1, 1)。<br>在各個頂點畫出半徑為1的圓，則最中間-也就是(0, 0, 0)-會有空隙，可以放入一個直徑為方形對角線減去2的圓。<br><img src="https://i.imgur.com/KkTTBQ2.png=50x50" alt=""></p><p>把它一般化一下，設正方形邊長為2r，則外邊四圓半徑為r，而中心圓的半徑為$\sqrt{2} r - r=(\sqrt{2} - 1)r$</p><p>現在將問題拓展到三維。<br>同樣的利用對角線減去邊長找出中心圓直徑，對角線: $\sqrt{(2r)^2 + (2r)^2 + (2r)^2}$，則中心圓半徑為$(\sqrt{3} - 1)r$</p><blockquote><p>猜測: $r’ = (\sqrt{n} - 1)r$, $n$為維度, $r’$為中心圓半徑。</p></blockquote><p>證明:<br>n維正立方體對角線為$\sqrt{n(2r)^2}$，而根據圓的定義，從球心到球面上各點距離相同，則球心與對角線的交點距離r，則$r’ = \sqrt{n} r - r = (\sqrt{n} - 1)r$</p><p>第2, 3維都可以理解，但是當我來到4維後，出現了一個弔詭的現象。<br>設$r’=t_nr$，$t_n$為第n維下的比值，依上面的推論$t_n=\sqrt{n} - 1$。<br>$t_4 = 1$，也就是說中心圓的直徑已經跟正方體的邊長相同了!<br>$t_5 = 1.236..$，已經超出正方體了。<br>甚至連體積都比容納他的正方體還大，以我的智商實在無法理解0.0</p><p><a href="https://oemiliatano.github.io/2020/11/04/%E9%AB%98%E7%B6%AD%E7%90%83%E9%AB%94%E9%AB%94%E7%A9%8D%E6%8E%A8%E5%B0%8E/">體積的計算方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 隨筆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探vpython</title>
      <link href="/2020/05/03/%E5%88%9D%E6%8E%A2vpython/"/>
      <url>/2020/05/03/%E5%88%9D%E6%8E%A2vpython/</url>
      
        <content type="html"><![CDATA[<p>折騰了六天的課，終於可以好好休息一天了 -_-</p><p>初次聽到vpython這個套件是在電腦課上聽到的，當初沒甚麼興趣，現在倒是來了興致少了時間…</p><h2 id="等加速度運動"><a href="#等加速度運動" class="headerlink" title="等加速度運動"></a>等加速度運動</h2><p>這是課本裡運動學最簡單的東西。</p><p>首先定義好物件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vpython <span class="keyword">as</span> vp</span><br><span class="line"></span><br><span class="line">monitor = vp.canvas(title = <span class="string">&quot;uniform accelerated motion&quot;</span>)</span><br><span class="line">ground = vp.box(pos = vp.vector(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), size = vp.vector(<span class="number">10</span>, <span class="number">0.4</span>, <span class="number">2</span>))</span><br><span class="line">cube = vp.box(pos = vp.vector(-<span class="number">4.9</span>, <span class="number">0.3</span>, -<span class="number">0.8</span>), size = vp.vector(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>), color = vp.color.purple)</span><br></pre></td></tr></table></figure></p><p>注意他size是指整個物體的長寬高，而不是從pos開始算。<br><img src="https://i.imgur.com/2qUar1y.png" alt=""><br>所以上面的正方體座標就是(0.5, 0.5, 0.5), (-0.5, 0.5, 0.5), (0.5, -0.5, 0.5)…</p><p>定義部分應該很好理解。</p><p>物件運動的部分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0.1</span></span><br><span class="line">v = <span class="number">0</span></span><br><span class="line">dt = <span class="number">0.01</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cube.pos.x &lt; <span class="number">4.9</span>:</span><br><span class="line">    vp.rate(<span class="number">1000</span>)</span><br><span class="line">    cube.pos.x += dt * v</span><br><span class="line">    v += a * dt</span><br></pre></td></tr></table></figure></p><p>就只是這樣而已，很簡單。<br>但是你會發現一開始的鏡頭會被地板擋住，可以使用vp.canvas(…, center = vp.vector(x, y, z), …)來調整</p><p>就先這樣了…以後還有時間再更新…</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sudoku!</title>
      <link href="/2020/04/24/Sudoku/"/>
      <url>/2020/04/24/Sudoku/</url>
      
        <content type="html"><![CDATA[<p>小時候常玩的遊戲，但是一碰到需要假設數字很多的就會開始亂掉。<br>我的人工dfs只能塞大概4個堆疊而已。</p><p>一般我在手做數獨時都會用原本數字來限制某些格子的可能性，總有幾個可以刪到剩下一個，從1開始枚舉，用原本的數字開始限制，只要每次都可以寫上新的數字就不要進行假設。<br>基本上，在中等難度還可以用這套方式避開大量的假設。<br>但一旦到了難度偏高的時候，這種方法會因為數字開始變得稀疏而完全不管用。所以還是會有很多很多假設數字(腦中記憶體已用完)。</p><p>而現在我們有了電腦，只要可以設計出好的演算法就可以快速求解我花了兩天的數獨了。</p><ul><li><p><strong>窮舉</strong><br>  枚舉所有可能出現的數字。<br>  對，就只是這樣而已。<br>  但是也挺慢的。可以到好幾十秒。</p></li><li><p><strong>窮舉+剪枝</strong><br>  當我們填上數字時，會導致那行、列與所在的大格能選的數字減少，也就是說原本每格都可以填上一些候補數，之後的格子則會受到先前的限制，當限制多到無法再某格填入任何數 且 整個數獨未完成的話，這一步即是錯的。<br>  這個方法讓電腦可以不用枚舉一定不會有解的方向，速度必然會快上一點。</p><p>  <strong>實作第一版:</strong></p><p>  每格都有一些候補數，當每次操作時都需要刪除其他格的候補數，或是拿到候補數，所以會需要能夠處理刪除、詢問的容器。<br>  想了想就是C++ STL的<code>set</code>最適合。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sudoku-ver exhaustion.cpp</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; nineCell[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; rSet[<span class="number">10</span>];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; cSet[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> fix[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> table[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetXinCell</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nineCell[r / <span class="number">3</span>][c / <span class="number">3</span>].<span class="built_in">erase</span>(x);</span><br><span class="line">rSet[r].<span class="built_in">erase</span>(x);</span><br><span class="line">cSet[c].<span class="built_in">erase</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveXinCell</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nineCell[r / <span class="number">3</span>][c / <span class="number">3</span>].<span class="built_in">emplace</span>(x);</span><br><span class="line">rSet[r].<span class="built_in">emplace</span>(x);</span><br><span class="line">cSet[c].<span class="built_in">emplace</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Set(s) s.begin(), s.end()</span></span><br><span class="line"><span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">findCandidate</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; tmp, res;</span><br><span class="line"><span class="built_in">set_intersection</span>(<span class="built_in">Set</span>(rSet[r]), <span class="built_in">Set</span>(cSet[c]), <span class="built_in">inserter</span>(tmp, tmp.<span class="built_in">begin</span>()));</span><br><span class="line"><span class="built_in">set_intersection</span>(<span class="built_in">Set</span>(tmp), <span class="built_in">Set</span>(nineCell[r / <span class="number">3</span>][c / <span class="number">3</span>]), <span class="built_in">inserter</span>(res, res.<span class="built_in">end</span>()));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">9</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; Candidates = <span class="built_in">findCandidate</span>(r, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : Candidates)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetXinCell</span>(r, c, it);</span><br><span class="line">fix[r][c] = <span class="literal">true</span>;</span><br><span class="line">table[r][c] = it;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _r = r, _c = c;</span><br><span class="line"><span class="keyword">while</span> (fix[_r][_c])</span><br><span class="line">&#123;</span><br><span class="line">++_c;</span><br><span class="line">_r += _c / <span class="number">9</span>;</span><br><span class="line">_c %= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(_r, _c))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">table[r][c] = <span class="number">0</span>;</span><br><span class="line">fix[r][c] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">RemoveXinCell</span>(r, c, it);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">9</span>; ++k)</span><br><span class="line">&#123;</span><br><span class="line">nineCell[i / <span class="number">3</span>][j / <span class="number">3</span>].<span class="built_in">emplace</span>(k);</span><br><span class="line">rSet[i].<span class="built_in">emplace</span>(k);</span><br><span class="line">cSet[j].<span class="built_in">emplace</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; table[i][j];</span><br><span class="line"><span class="keyword">if</span> (table[i][j])</span><br><span class="line">&#123;</span><br><span class="line">fix[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetXinCell</span>(i, j, table[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (fix[r][c])</span><br><span class="line">&#123;</span><br><span class="line">++c;</span><br><span class="line">r += c / <span class="number">9</span>;</span><br><span class="line">c %= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(r, c);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt; <span class="string">&quot;answer:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; table[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!((j + <span class="number">1</span>) % <span class="number">3</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!((i + <span class="number">1</span>) % <span class="number">3</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  拿了十個Expert難度的數獨來測試:<br>  <img src="https://i.imgur.com/8lPFyCO.png" alt=""><br>  : <code>3474 ms</code></p><p>  <img src="https://i.imgur.com/rz8b82a.png" alt=""><br>  : <code>4300 ms</code></p><p>  <img src="https://i.imgur.com/NVyYFgt.png" alt=""><br>  : <code>1960 ms</code></p><p>  <img src="https://i.imgur.com/yLT8SXZ.png" alt=""><br>  : <code>10590 ms</code></p><p>  <img src="https://i.imgur.com/18hZyjD.png" alt=""><br>  : <code>2762 ms</code></p><p>  <img src="https://i.imgur.com/soykQ3L.png" alt=""><br>  : <code>181 ms</code></p><p>  <img src="https://i.imgur.com/qEcv9OJ.png" alt=""><br>  : <code>2041 ms</code></p><p>  <img src="https://i.imgur.com/3uUbDkS.png" alt=""><br>  :<code>1494 ms</code></p><p>  <img src="https://i.imgur.com/gL3kitg.png" alt=""><br>  :<code>466 ms</code></p><p>  <img src="https://i.imgur.com/I4WGn6Y.png" alt=""><br>  :<code>10205 ms</code></p><p>  <strong>平均:</strong>   <code>3747 ms</code><br>  <strong>標準差:</strong> <code>3529</code></p><p>  可以發現這種方式非常不穩定，原因是當我們填入數字時，如果他是對的，那我們在這一層就不會往下試數，反之。<br>  而我們用的set是有序的，會由小到大枚舉，所以如果前面的數字正確答案是比較後面的數字，例如9，就會花費非常多時間。<br>  為了不要讓他是有序的，我們可以通過random戳候補數，這樣可以讓期望時間變小。</p><p>  同上面數據的結果:<br>  第一次:<br>  :<code>3058 ms</code><br>  :<code>3995 ms</code><br>  :<code>3805 ms</code><br>  :<code>2411 ms</code><br>  :<code>2863 ms</code><br>  :<code>124  ms</code><br>  :<code>70   ms</code><br>  :<code>299  ms</code><br>  :<code>38   ms</code><br>  :<code>8382 ms</code></p><p>  <strong>平均:</strong>   <code>2504 ms</code><br>  <strong>標準差:</strong> <code>2479</code></p><p>  第二次:<br>  :<code>2914 ms</code><br>  :<code>3947 ms</code><br>  :<code>3681 ms</code><br>  :<code>2469 ms</code><br>  :<code>2766 ms</code><br>  :<code>122  ms</code><br>  :<code>72   ms</code><br>  :<code>296  ms</code><br>  :<code>35   ms</code><br>  :<code>8172 ms</code></p><p>  <strong>平均:</strong>   <code>2447 ms</code><br>  <strong>標準差:</strong> <code>2416</code></p><p>  變得比較穩定，總體來看也變快了。</p><p>  不過這還可以優化，C++ STL的<code>set</code>底層通常採用<a href="https://zh.wikipedia.org/zh-tw/%E7%BA%A2%E9%BB%91%E6%A0%91">紅黑樹</a>實現<br>  雖然期望複雜度很好，但是STL的封裝導致常數頗大。</p><p>  每行、列、宮都是一個集合，且最多只有9個數字。<br>  有沒有想到什麼東西阿，<strong>位元壓縮</strong>!</p><p>  每個行、列、宮都可以壓縮成一個整數，第<code>i</code>位=1代表數字<code>i</code>是可選的，反之。<br>  所以對於$(r, c)$的候補數就是 集合$S_r\bigcap S_c\bigcap Cells_{r,c}$。<br>  加入一個數字與刪除一個數字也不過是在三個集合中做xor操作罷了。<br>  這種作法常數小了很多，且記憶體也非常小，使用<code>int16_t</code>的話，也不過幾KB。<br>  可謂兼具時間與空間的作法。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sudoku-ver bit.cpp</span></span><br><span class="line"><span class="type">int</span> table[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"><span class="type">bool</span> fix[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nineCell[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> rSet[<span class="number">10</span>], cSet[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findCandidate</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> nineCell[r / <span class="number">3</span>][c / <span class="number">3</span>] &amp; rSet[r] &amp; cSet[c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetXinCell</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">rSet[r] ^= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">cSet[c] ^= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">nineCell[r / <span class="number">3</span>][c / <span class="number">3</span>] ^= (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">9</span> &amp;&amp; c == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> candidate = <span class="built_in">findCandidate</span>(r, c) &amp; ((<span class="number">1</span> &lt;&lt; <span class="number">10</span>) - <span class="number">1</span>) ^ <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; candidate; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (candidate &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetXinCell</span>(r, c, i);</span><br><span class="line">fix[r][c] = <span class="literal">true</span>;</span><br><span class="line">table[r][c] = i;</span><br><span class="line">candidate ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _r = r, _c = c;</span><br><span class="line"><span class="keyword">while</span> (fix[_r][_c])</span><br><span class="line">&#123;</span><br><span class="line">++_c;</span><br><span class="line">_r += _c / <span class="number">9</span>;</span><br><span class="line">_c %= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">dfs</span>(_r, _c))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">table[r][c] = <span class="number">0</span>;</span><br><span class="line">fix[r][c] = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">SetXinCell</span>(r, c, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(fix, <span class="literal">false</span>, <span class="built_in">sizeof</span>(fix));</span><br><span class="line"><span class="built_in">memset</span>(nineCell, <span class="number">-1</span>, <span class="built_in">sizeof</span>(nineCell));</span><br><span class="line"><span class="built_in">memset</span>(rSet, <span class="number">-1</span>, <span class="built_in">sizeof</span>(rSet));</span><br><span class="line"><span class="built_in">memset</span>(cSet, <span class="number">-1</span>, <span class="built_in">sizeof</span>(cSet));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; table[i][j];</span><br><span class="line"><span class="keyword">if</span> (table[i][j])</span><br><span class="line">&#123;</span><br><span class="line">fix[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetXinCell</span>(i, j, table[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> START, END;</span><br><span class="line">START = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (fix[r][c])</span><br><span class="line">&#123;</span><br><span class="line">++c;</span><br><span class="line">r += c / <span class="number">9</span>;</span><br><span class="line">c %= <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs</span>(r, c);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\nanswer:&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; table[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!((j + <span class="number">1</span>) % <span class="number">3</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!((i + <span class="number">1</span>) % <span class="number">3</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;execution time: &quot;</span> &lt;&lt; (END - START) &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  同樣依上面的測試數據:<br>  :<code>17 ms</code><br>  :<code>23 ms</code><br>  :<code>25 ms</code><br>  :<code>41 ms</code><br>  :<code>15 ms</code><br>  :<code>11 ms</code><br>  :<code>18 ms</code><br>  :<code>11 ms</code><br>  :<code>6  ms</code><br>  :<code>43 ms</code></p><p>  <strong>平均:</strong>   <code>21 ms</code><br>  <strong>標準差:</strong> <code>12</code></p><p>  這速度差了不只一個檔次，可見常數對於程式的影響多大。</p></li><li><p><strong>DLX algorithm</strong><br>  網路上很多人都說是解數獨的最快算法。</p><p>  詳細實作方式會另外寫一篇文章解釋。</p><p>  測試結果:<br>  :<code>5 ms</code><br>  :<code>4 ms</code><br>  :<code>6 ms</code><br>  :<code>7 ms</code><br>  :<code>5 ms</code><br>  :<code>5 ms</code><br>  :<code>6 ms</code><br>  :<code>4 ms</code><br>  :<code>7 ms</code><br>  :<code>4 ms</code></p><p>  <strong>平均:</strong>   <code>5 ms</code><br>  <strong>標準差:</strong> <code>1</code></p><p>  看來真的是最快數獨算法了。<br>  但是空間的使用也比bit版本多很多，大概10倍左右，是一個空間換取時間的優秀策略。</p></li></ul><p>延伸話題:</p><ul><li><p><strong>數獨的終盤</strong>:<br>  2005年由Bertram Felgenhauer和Frazer Jarvis計算出合法數獨的終盤共有6,670,903,752,021,072,936,960個，而如果將等價盤去掉，則有5,472,730,538個<br>  而每個終盤又可以做出$\sum^{64}_{i=1} C^{81}_{i}$個題目，數字已經過於龐大，以至於對於我們沒甚麼意義(反正就是一輩子都寫不完)。</p></li><li><p><strong>數獨的最少提示數</strong>:<br>  已經被證明最少要有17個提示數才能使數獨是唯一解。<br>  由Gary McGuire, Bastian Tugemann, Gilles Civario給出的證明: <a href="https://arxiv.org/pdf/1201.0749.pdf">https://arxiv.org/pdf/1201.0749.pdf</a></p></li><li><p><strong>各種腦動大開的數獨</strong>:<br>  對角線數獨<br>  <img src="https://i.imgur.com/hoZ9og7.png" alt=""></p><p>  鋸齒數獨<br>  <img src="https://i.imgur.com/lDRM4Zp.png" alt=""></p><p>  連體數獨<br>  <img src="https://i.imgur.com/gU4TxjW.jpg" alt=""><br>  <img src="https://i.imgur.com/GZR6AgA.jpg" alt=""></p><p>  killer數獨<br>  <img src="https://i.imgur.com/csDzhXo.png" alt=""></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> games </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python - 可視化函數</title>
      <link href="/2020/04/22/3D-functions/"/>
      <url>/2020/04/22/3D-functions/</url>
      
        <content type="html"><![CDATA[<p>昨天一個心血來潮，想自己做看看可視化函數。<br><img src="https://i.imgur.com/nHKmZlc.png" alt=""></p><p>我一開始想用C++寫，但是想到python在這方面似乎比較簡單，所以我就決定使用python來做(懶)</p><p>我是用Anaconda做的，畢竟裡面都已經裝好了，不用白不用。</p><p>首先我第一個做的是二維平面的圖:<br><img src="https://i.imgur.com/9QijOUV.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># function</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生一段從-10到10的數字，間隔 0.125</span></span><br><span class="line">x = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">.125</span>)</span><br><span class="line">y = f(x)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>非常之簡單。</p><p>接著是兩個圖交疊的:<br><img src="https://i.imgur.com/aNHenMI.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 將上面的code改一下就好了</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">10</span> * np.sin(x)</span><br><span class="line">g = <span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">.125</span>)</span><br><span class="line">y1 = f(x)</span><br><span class="line">y2 = g(x)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>似乎有點過於簡單了?</p><p>接著是3D的圖形，根據我上網找的資料，需要用到<code>mpl_toolkits.mplot3d</code>裡面的<code>Axes3D</code>。<br>因為現在是x, y會產生一個面，然後再根據在面上的某個位置，決定畫在Z軸的哪裡。<br>所以我們需要<code>np.meshgrid(x, y)</code>這個函式來產生這個面。</p><p>三維:<br><img src="https://i.imgur.com/tcf81OH.png" alt=""></p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ax = Axes3D(fig)</span></span><br><span class="line"><span class="comment"># 2022.5.18 更新</span></span><br><span class="line"><span class="comment"># 上述寫法已經被拋棄，應該改成</span></span><br><span class="line">ax = plt.axes(projection = <span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">.125</span>)</span><br><span class="line">y = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">.125</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生輸入面</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line">Z = X + Y</span><br><span class="line"></span><br><span class="line">ax.plot_surface(X, Y, Z)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>覺得好像只是單一顏色好像太單調了。<br>順便也把圖形弄得複雜一點。</p><p>$f(x, y) = x^2+y^2$:<br><img src="https://i.imgur.com/dX6inWg.png" alt=""></p><p>$f(x, y) = \sqrt{x^2+y^2}$:<br><img src="https://i.imgur.com/an0LC6v.png" alt=""></p><p>$f(x, y) = cos(\sqrt{x^2+y^2})$:<br><img src="https://i.imgur.com/UyBqdjK.png" alt=""></p><p>$f(x, y) = sin(\sqrt{x^2+y^2})$:<br><img src="https://i.imgur.com/xhifgrA.png" alt=""></p><p>$f(x, y) = sin(x \times y)$ :<br><img src="https://i.imgur.com/2oeIN7U.png" alt=""></p><p>$f(x, y) = sin(exp(x^2 + y^2))$: (xy平面上視角)<br><img src="https://i.imgur.com/UPJvyDW.png" alt=""></p><p><strong>code</strong>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line"># ax = Axes3D(fig)</span><br><span class="line">ax = plt.axes(projection = &quot;3d&quot;)</span><br><span class="line"></span><br><span class="line">ax.view_init(45, 45)</span><br><span class="line"></span><br><span class="line">ax.set_xlabel(&#x27;x&#x27;)</span><br><span class="line">ax.set_ylabel(&#x27;y&#x27;)</span><br><span class="line">ax.set_zlabel(&#x27;z&#x27;)</span><br><span class="line"></span><br><span class="line">ax.set_zlim3d(-3, 3)</span><br><span class="line"></span><br><span class="line">x = np.arange(-5, 5, .125)</span><br><span class="line">y = np.arange(-5, 5, .125)</span><br><span class="line"></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line">Z = f(X, Y)</span><br><span class="line"></span><br><span class="line"># rstride, cstride 相當於row, column的解析度，數值越高解析度越低，可以自己調調看</span><br><span class="line"># cmap則是顏色映射表，有許多預設種類</span><br><span class="line">ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = &#x27;rainbow&#x27;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>我們還有一個複數域沒用到，但是當我試著想畫出複數域時，問題開始變得棘手了…<br>當我們輸入進一個複數$a+bi$時需要兩個變數$(a, b)$去記錄，而函數輸出是$c+di$也需要兩個變數$(c, d)$去記錄。<br>很明顯的我們需要四個軸來表示，但是我們就算畫出來了，我們也無法理解(吧，還是只有我無法理解?</p><p>我上網找到幾個方法:</p><ol><li>只畫實部</li><li>只畫虛部</li><li>畫在複數平面上，對於原點的距離</li><li>畫複數平面上的方位角</li><li>用顏色代表第四維度</li><li>Conformal map，共形映射</li></ol><p>前四個方法都需要犧牲一點東西。<br>只畫實部、只畫虛部就不多講了。值得注意的是，通常會把方位角代進sin()，以此讓它變成連續的。<br>PS. 可以使用<code>mpmath</code>的<code>arg()</code>算方位角</p><p>$f(x) = x^2 + 1$(未用sin):<br><img src="https://i.imgur.com/gukQCpn.png" alt=""><br>$f(x) = x^2 + 1$(使用sin):<br><img src="https://i.imgur.com/hLVuzCQ.png" alt=""></p><p>巴尼斯G函數的複數平面上的方位角(未用sin):<br><img src="https://i.imgur.com/7PnpifK.png" alt=""><br>巴尼斯G函數的複數平面上的方位角(使用sin):<br><img src="https://i.imgur.com/YBGoMnj.png" alt=""></p><p>第五個方法需要用到colormap，彩色映射的方法。</p><p><strong>code:</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mpmath</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(x) = x ** 2 + 1</span></span><br><span class="line">f = <span class="keyword">lambda</span> x: np.power(x, <span class="number">2</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = plt.axes(projection = <span class="string">&quot;3d&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定視角</span></span><br><span class="line">ax.view_init(<span class="number">45</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f(a + bi) = c + di</span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">.125</span>)</span><br><span class="line">b = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">.125</span>)</span><br><span class="line"></span><br><span class="line">A, B = np.meshgrid(a, b)</span><br><span class="line">an, bn = A.shape</span><br><span class="line">C, D = A * <span class="number">0</span>, A * <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(an):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(bn):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            z = mpmath.mp.mpc(A[i, j], B[i, j])</span><br><span class="line">            w = f(z)</span><br><span class="line">            </span><br><span class="line">            C[i, j] = w.real</span><br><span class="line">            D[i, j] = w.imag</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">except</span> (ValueError, TypeError, ZeroDivisionError):</span><br><span class="line">            <span class="comment"># do something...</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用顏色代表虛部</span></span><br><span class="line">color_dimension = D</span><br><span class="line">minn, maxx = color_dimension.<span class="built_in">min</span>(), color_dimension.<span class="built_in">max</span>()</span><br><span class="line">norm = matplotlib.colors.Normalize()</span><br><span class="line">m = plt.cm.ScalarMappable(norm = norm, cmap = <span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">fcolors = m.to_rgba(color_dimension)</span><br><span class="line"></span><br><span class="line">surf = ax.plot_surface(A, B, C, rstride = <span class="number">1</span>, cstride = <span class="number">1</span>, facecolors = fcolors, vmin = minn, vmax = maxx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 右邊那條</span></span><br><span class="line">plt.colorbar(m)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>$f(x) = x^2 + 1$<br><img src="https://i.imgur.com/qmrPOYI.png" alt=""></p><p>$f(x) = x^\pi$<br><img src="https://i.imgur.com/fPHHC5L.png" alt=""></p><p>$f(x) = sin(x) \times cos(x)$<br><img src="https://i.imgur.com/rjTaflP.png" alt=""></p><p>至於第六個方法，待研究…</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mo&#39;s algorithm</title>
      <link href="/2020/04/19/mo-s-algorithm/"/>
      <url>/2020/04/19/mo-s-algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="莫隊算法"><a href="#莫隊算法" class="headerlink" title="莫隊算法"></a>莫隊算法</h3><blockquote><p>給定一長度為 $n$的數列，有 $q$個詢問，問區間 $l,r$內眾數出現幾次? 有幾個眾數?<br>!可以離線</p></blockquote><p>這題目乍看下是要刻一個比較特殊的線段樹，但是真的需要嗎?</p><p>首先，我們把問題reduce成</p><blockquote><p>給定一長度為 $n$的數列，有兩個索引 $l,r$，有 $q$個操作，使 $l$變大或變小1、使 $r$變大或變小1，問每次操作區間 $l,r$內眾數出現幾次? 有幾個眾數?</p></blockquote><p>這個問題看起來就簡單多了。<br>設<code>app[x]</code>, <code>cnt[c]</code>, <code>maxcur</code>為 $x$出現幾次、出現 $c$次的有幾種數字、目前的眾數是出現幾次。<br>每次移動雙指標時，都去維護<code>app[x], cnt[c], maxcur</code>，<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --cnt[app[x]];</span><br><span class="line">    --app[x];</span><br><span class="line">    ++cnt[app[x]];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt[maxcur] == <span class="number">0</span>)</span><br><span class="line">        --maxcur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    --cnt[app[x]];</span><br><span class="line">    ++app[x];</span><br><span class="line">    ++cnt[app[x]];</span><br><span class="line">    </span><br><span class="line">    maxcur = <span class="built_in">max</span>(maxcur, app[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//~~</span></span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&quot;L l&quot;</span>)</span><br><span class="line">        <span class="built_in">add</span>(arr[--l]);    <span class="comment">//左指標左移</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;L r&quot;</span>)</span><br><span class="line">        <span class="built_in">sub</span>(arr[l++]);    <span class="comment">//左指標右移</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R l&quot;</span>)</span><br><span class="line">        <span class="built_in">sub</span>(arr[r--]);    <span class="comment">//右指標左移</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&quot;R r&quot;</span>)</span><br><span class="line">        <span class="built_in">add</span>(arr[++r]);    <span class="comment">//右指標右移</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; maxcur &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; cnt[maxcur] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>這樣的複雜度是$O(q)$。完美解決。</p><p>但是這個問題跟原始問題比起來，差在一個 <strong>移動是連續的</strong>；一個是 <strong>左界右界亂跳</strong>。<br>那我們不妨讓原始題目的詢問左右界排序成連續的樣子。</p><p>依照左界大小將詢問排序，再依照剛剛的做法去做，但是這樣會有一個問題</p><blockquote><p>右界怎麼辦?</p></blockquote><p>如果有很多筆操作，左界都相同，但是右界差距極大，這樣複雜度最差是$O(n^2)$</p><p>有沒有一種辦法去同時把左界排序又能維護好右界遞增呢?<br>有，但是左右界都需要犧牲一點單調性。</p><p>利用分塊的思想，將$n$個元素切成$K$塊，接著將所有詢問按照$L_i$所在的區塊排序，如果在同一個區塊，就再對</p><p>$R_i$做排序。</p><ul><li><p><strong>複雜度分析</strong>:<br>  因為分塊的特性，在同一塊的左界不會移動超過$\frac{N}{K}$次，而左界屬於不同塊的操作，移動次數最多也不會超過N次。所以左界移動複雜度是$O(\frac{NQ}{K})$。<br>  對於右界因為$R_i$是遞增，所以對於同一塊複雜度最多$O(N)$，對不同塊因為交界最多$K$次，每次最多也$O(N)$，所以維護右界複雜度為$O(NK)$。<br>  取$K=\sqrt N$，複雜度為 $O(Q\sqrt N +N \sqrt N)$</p></li><li><p><strong>奇偶優化</strong>:<br>  每一塊的$R_i$都是遞增，因此在遇到交界處時會有一個”大斷層”，導致右界必須移動許多次，但是如果反過來變成奇數塊遞增，而偶數塊遞減，就會讓右界的移動接近連續<br>  實做判斷區塊是否為偶數進行遞增或遞減排序。</p></li><li><p><strong>code:</strong><br>  因為有點長，所以貼連結: <a href="https://pastebin.com/sLbTNxmP">Mo’s alogrithm</a></p></li></ul><p>練習題: <a href="https://zerojudge.tw/ShowProblem?problemid=b417">zj b417</a>(模板題),<a href="https://tioj.ck.tp.edu.tw/problems/1699">tioj 1699</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Treap</title>
      <link href="/2020/04/19/Treap/"/>
      <url>/2020/04/19/Treap/</url>
      
        <content type="html"><![CDATA[<h3 id="treap"><a href="#treap" class="headerlink" title="treap"></a>treap</h3><p><strong>!這裡只討論split-merge treap</strong></p><p>屬於二元平衡樹的一種，因為 <strong>易編寫</strong> <strong>速度快</strong> <strong>靈活性高</strong> 的特性而在競程占有一席之地。<br>他可以解決 segment tree 的問題，也可以解決splay tree的問題，同樣也可以解決大部分二元平衡樹的問題，學一個treap抵過學一堆樹。</p><ul><li><p><strong>基本原理</strong><br>  Treap = tree + heap。<br>  亦即同時擁有BST與heap性質的資料結構。</p><blockquote><p>heap: 父節點的<code>pri</code>值大於子結點<br>BST: 左子樹<code>key</code>值均小於等於父節點，右子樹則大於父節點。</p></blockquote><p>  一般二元平衡樹為了避免退化，會利用 <strong>旋轉</strong> 操作去維持深度。</p><p>  而treap因為擁有BST與heap的性質，所以既能擁有BST的查找功能，又能像heap一樣維持深度，</p><ul><li><p><strong>treap最重要的兩個操作:</strong></p><ul><li><p>merge(a, b):<br>  合併兩顆treap，注意此函式必須滿足 <strong>a的所有key值小於b的所有key</strong></p></li><li><p>split(t, k):<br>  將treap t分成兩顆treap， <strong>一顆裡的key均小於等於k，另一顆的均大於</strong>。</p><p>兩種操作都因為BST的特性所以實作難度降低許多。</p></li></ul></li></ul><ul><li><p><strong>基本架構</strong></p><ul><li><strong>node:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Treap</span></span><br><span class="line">&#123;</span><br><span class="line">    Treap *l, *r;</span><br><span class="line">    <span class="type">int_t</span> key, pri;</span><br><span class="line">    <span class="built_in">Treap</span>(<span class="type">int_t</span> _key)</span><br><span class="line">    &#123;</span><br><span class="line">        l = r = <span class="literal">nullptr</span>;</span><br><span class="line">        key = _key;</span><br><span class="line">        pri = <span class="built_in">rand</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>merge:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Treap* <span class="title">merge</span><span class="params">(Treap* a, Treap* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> || b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a ? a : b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;pri &gt; b-&gt;pri)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">merge</span>(a-&gt;r, b);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="built_in">merge</span>(a, b-&gt;l);</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>split:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(Treap* t, <span class="type">int_t</span> k, Treap* &amp;a, Treap* &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = b = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t-&gt;key &lt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        a = t;</span><br><span class="line">        <span class="built_in">split</span>(t-&gt;r, k, a-&gt;r, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = t;</span><br><span class="line">        <span class="built_in">split</span>(t-&gt;l, k, a, b-&gt;l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有上面兩種操作，基本就寫完了。</p></li><li><strong>insert:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Treap *t, <span class="type">int_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Treap *lt, *rt;</span><br><span class="line">    <span class="built_in">split</span>(t, k, lt, rt);</span><br><span class="line">    <span class="built_in">merge</span>(<span class="built_in">merge</span>(lt, <span class="keyword">new</span> <span class="built_in">Treap</span>(k)), tr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>remove:</strong>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Treap *t, <span class="type">int_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Treap *lt, *rt;</span><br><span class="line">    <span class="built_in">split</span>(t, k - <span class="number">1</span>, lt, t);</span><br><span class="line">    <span class="built_in">split</span>(t, k, t, rt);</span><br><span class="line">    t = <span class="built_in">merge</span>(lt, rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>treap，就是這麼簡單。</strong></li></ul><p>在平衡樹的問題中，常常遇見尋找第k小元素的要求，就跟BST一樣treap一樣是用節點size去判斷，所以我們現在需要維護treap上節點的size，這樣可以跟BST一樣找kth了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int_t</span> <span class="title">Size</span><span class="params">(Treap *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t == <span class="literal">nullptr</span> ? <span class="number">0</span> : t-&gt;sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Treap *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;sz = <span class="number">1</span> + <span class="built_in">Size</span>(t-&gt;l) + <span class="built_in">Size</span>(t-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>真正實作</strong><br>  <strong>node:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Treap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Treap mem[MAXN], *ptr;</span><br><span class="line">    Treap *l, *r;</span><br><span class="line">    <span class="type">int_t</span> pri, key, siz;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Treap</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Treap</span>(<span class="type">int_t</span> _key)</span><br><span class="line">    &#123;</span><br><span class="line">        l = r = <span class="literal">nullptr</span>;</span><br><span class="line">        pri = <span class="built_in">rand</span>();    <span class="comment">//可以用其他隨機方法，保證更好的隨機性</span></span><br><span class="line">        key = _key;</span><br><span class="line">        siz = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Treap::mem[MAXN], *Treap::ptr = Treap::mem;</span><br></pre></td></tr></table></figure><p>  <strong>split:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//與上面唯一有差別的只有當某顆treap的結構改變時，需要呼叫pull()去更新資訊</span></span><br><span class="line"><span class="comment">//例如 呼叫完split()後</span></span><br></pre></td></tr></table></figure><p>  <strong>merge:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//與上面唯一有差別的只有當某顆treap的結構改變時，需要呼叫pull()去更新資訊</span></span><br><span class="line"><span class="comment">//例如 呼叫完merge()後</span></span><br></pre></td></tr></table></figure><p>  <strong>kth:</strong> (第k小)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int_t</span> <span class="title">kth</span><span class="params">(Treap *t, <span class="type">int_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int_t</span> lsz = <span class="built_in">sz</span>(t-&gt;l) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (lsz &lt; k) <span class="keyword">return</span> <span class="built_in">kth</span>(t-&gt;r, k - lsz);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(lsz == k) <span class="keyword">return</span> t-&gt;key;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">kth</span>(t-&gt;l, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>以上是treap當平衡樹的版本</strong></p></li></ul><hr><ul><li><p><strong>treap區間維護</strong></p><p>  上面提過，treap不只可以解決平衡樹問題，也可以解決序列操作問題。</p><p>  我們只需要在node裡多加一個<code>val</code>當作序列上的值、<code>key</code>當作序列上的索引值、<code>mx/mn/sum</code>當作要維護的值即可。</p><p>  <strong>treap，就是這麼簡單。</strong></p><p>  但是當我們遇到區間加值怎麼辦?<br>  線段樹巧妙的用 <strong>lazy tag</strong> 解決了，同樣的treap也可以!</p><p>  只要用好好維護我們的tag即可。</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(Treap *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    t-&gt;val += t-&gt;lazy;</span><br><span class="line">    t-&gt;mx += t-&gt;lazy;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;l != <span class="literal">nullptr</span>)</span><br><span class="line">        t-&gt;l-&gt;lazy += t-&gt;lazy;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;r != <span class="literal">nullptr</span>)</span><br><span class="line">        t-&gt;r-&gt;lazy += t-&gt;lazy;</span><br><span class="line">    t-&gt;lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pull</span><span class="params">(Treap *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t-&gt;sz = <span class="number">1</span> + <span class="built_in">Size</span>(t-&gt;l) + <span class="built_in">Size</span>(t-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>node:</strong> (改)</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Treap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Treap mem[MAXN], *ptr;</span><br><span class="line">    Treap *l, *r;</span><br><span class="line">    <span class="type">int_t</span> pri, key, siz, lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int_t</span> val;    <span class="comment">//新增這兩個</span></span><br><span class="line">    <span class="type">int_t</span> mx;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Treap</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Treap</span>(<span class="type">int_t</span> _key, <span class="type">int_t</span> _val)</span><br><span class="line">    &#123;</span><br><span class="line">        l = r = <span class="literal">nullptr</span>;</span><br><span class="line">        pri = <span class="built_in">rand</span>();</span><br><span class="line">        key = _key;</span><br><span class="line">        siz = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        val = mx = _val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Treap::mem[MAXN], *Treap::ptr = Treap::mem;</span><br></pre></td></tr></table></figure><p>  <strong>build:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Treap *t = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int_t</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    t = <span class="built_in">merge</span>(t, <span class="built_in">new</span> (Treap::ptr++) <span class="built_in">node</span>(i, a[i])));</span><br></pre></td></tr></table></figure><p>  上面用到了placement new的技巧，通過先開記憶池再去new一個node，可以降低系統分配記憶體的開銷。</p><p>  <strong>區間加值:</strong></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_range</span><span class="params">(Treap *t, <span class="type">int_t</span> l, <span class="type">int_t</span> r, <span class="type">int_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Treap *lt, *rt;</span><br><span class="line">    <span class="built_in">split</span>(t, l - <span class="number">1</span>, lt, t);</span><br><span class="line">    <span class="built_in">split</span>(t, r, t, rt);</span><br><span class="line">    t-&gt;lazy += val;</span><br><span class="line">    <span class="built_in">merge</span>(<span class="built_in">merge</span>(lt, t), rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>翻轉吧! treap</strong></p><p>  有沒有觀察到我們剛剛 <strong>build</strong> 時，<code>key</code>直接放1, 2, 3…，仔細想想這樣<code>key</code>的意義不就是 <strong>在treap中有幾個比他小</strong>。<br>  那只要維護好<code>size</code>就可以不用管<code>key</code>了。<br>  所以<code>split(t, k)</code>的意義也就變成了:<strong>在t中切開前$k$個節點與後$n - k$個節點</strong>。</p><ul><li><p>只用<code>size</code>的好處<br>  不必再被<code>key</code>綁手綁腳的，當我們遇到什麼區間翻轉、區間剪下貼上，就真的直接剪下去、或轉下去(正常還是會打標)。</p><p><strong>treap，就是這麼簡單</strong></p><p><strong>node:</strong> (改)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Treap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Treap mem[MAXN], *ptr;</span><br><span class="line">    Treap *l, *r;</span><br><span class="line">    <span class="type">int_t</span> pri, siz, lazy;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int_t</span> val;</span><br><span class="line">    <span class="type">int_t</span> mx;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> rev;    <span class="comment">//翻轉標記</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Treap</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Treap</span>(<span class="type">int_t</span> _key, <span class="type">int_t</span> _val)</span><br><span class="line">    &#123;</span><br><span class="line">        l = r = <span class="literal">nullptr</span>;</span><br><span class="line">        pri = <span class="built_in">rand</span>();</span><br><span class="line">        siz = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        val = mx = _val;</span><br><span class="line">        </span><br><span class="line">        rev = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Treap::mem[MAXN], *Treap::ptr = Treap::mem;</span><br></pre></td></tr></table></figure><p><strong>split:</strong> (改)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(node *t, node *&amp;a, node *&amp;b, <span class="type">int_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!t) &#123; a = b = <span class="literal">nullptr</span>; <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">push</span>(t);</span><br><span class="line">    <span class="comment">//此節點的左子樹數量大於等於k</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>(t-&gt;l) &gt;= k)</span><br><span class="line">    &#123;</span><br><span class="line">        b = t;</span><br><span class="line">        <span class="built_in">push</span>(b);</span><br><span class="line">        <span class="comment">//將b指向整個樹，向左子樹處理。</span></span><br><span class="line">        <span class="built_in">split</span>(t-&gt;l, k, a, b-&gt;l);</span><br><span class="line">        <span class="built_in">pull</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = t;</span><br><span class="line">        <span class="built_in">push</span>(a);</span><br><span class="line">        <span class="built_in">split</span>(t-&gt;r, k - <span class="built_in">size</span>(t-&gt;l) - <span class="number">1</span>, a-&gt;r, b);</span><br><span class="line">        <span class="built_in">pull</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這部分的<code>split()</code>比較難理解，可以畫圖看看或直接貼程式，輸出中間過程。</p></li></ul></li></ul><p>!翻轉其實就是左右子樹交換</p><p>練習題: <a href="https://www.luogu.com.cn/problem/P3391">luogu P3391</a>(模板), <a href="http://codeforces.com/problemset/problem/702/F">cf 702F</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序</title>
      <link href="/2020/04/19/base-articles/"/>
      <url>/2020/04/19/base-articles/</url>
      
        <content type="html"><![CDATA[<p>這是原blog <a href="https://emiliatancoding.blogspot.com/">https://emiliatancoding.blogspot.com/</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
